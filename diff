Common subdirectories: Src/Chombo and ../old/Chombo
Common subdirectories: Src/Cooling and ../old/Cooling
Only in ../old: Dust
Common subdirectories: Src/EOS and ../old/EOS
Common subdirectories: Src/Fargo and ../old/Fargo
Only in ../old: Forced_Turb
Common subdirectories: Src/HD and ../old/HD
Common subdirectories: Src/MHD and ../old/MHD
Common subdirectories: Src/Math_Tools and ../old/Math_Tools
Common subdirectories: Src/Parallel and ../old/Parallel
Common subdirectories: Src/Particles and ../old/Particles
Common subdirectories: Src/RHD and ../old/RHD
Common subdirectories: Src/RMHD and ../old/RMHD
Common subdirectories: Src/States and ../old/States
Common subdirectories: Src/Templates and ../old/Templates
Common subdirectories: Src/Thermal_Conduction and ../old/Thermal_Conduction
Common subdirectories: Src/Time_Stepping and ../old/Time_Stepping
Common subdirectories: Src/Viscosity and ../old/Viscosity
diff Src/adv_flux.c ../old/adv_flux.c
31,33c31,33
<   \author A. Mignone (mignone@ph.unito.it)\n
<           O. Tesileanu
<   \date   02 April, 2015
---
>   \author  A. Mignone (mignone@ph.unito.it)\n
>            O. Tesileanu
>   \date    Feb 28, 2017
47c47
< void AdvectFlux (const State_1D *state, int beg, int end, Grid *grid)
---
> void AdvectFlux (const Sweep *sweep, int beg, int end, Grid *grid)
50c50
<  * \param [in,out] state
---
>  * \param [in,out] sweep
52a53
>  * \param [in]      grid   Pointer to Grid structure
67,69c68,70
<     flux = state->flux[i];
<     vL   = state->vL[i];
<     vR   = state->vR[i];
---
>     flux = sweep->flux[i];
>     vL   = sweep->stateL.v[i];
>     vR   = sweep->stateR.v[i];
77c78
<      /* -----   He   -----  */
---
>     /* -----   He   -----  */
79,80c80,81
<      phi = ts[X_HeI] + ts[X_HeII];
<      for (nv = X_HeI; nv <= X_HeII; nv++) flux[nv] /= phi;
---
>     phi = ts[X_HeI] + ts[X_HeII];
>     for (nv = X_HeI; nv <= X_HeII; nv++) flux[nv] /= phi;
82c83
<      /* -----   C   -----  */
---
>     /* -----   C   -----  */
84,86c85,87
<      phi = 0.0;
<      for (nv = X_CI; nv < X_CI + C_IONS; nv++) phi += ts[nv]; 
<      for (nv = X_CI; nv < X_CI + C_IONS; nv++) flux[nv] /= phi;
---
>     phi = 0.0;
>     for (nv = X_CI; nv < X_CI + C_IONS; nv++) phi += ts[nv]; 
>     for (nv = X_CI; nv < X_CI + C_IONS; nv++) flux[nv] /= phi;
88c89
<      /* -----   N   -----  */
---
>     /* -----   N   -----  */
90,92c91,93
<      phi = 0.0;
<      for (nv = X_NI; nv < X_NI+N_IONS; nv++) phi += ts[nv]; 
<      for (nv = X_NI; nv < X_NI+N_IONS; nv++) flux[nv] /= phi;
---
>     phi = 0.0;
>     for (nv = X_NI; nv < X_NI+N_IONS; nv++) phi += ts[nv]; 
>     for (nv = X_NI; nv < X_NI+N_IONS; nv++) flux[nv] /= phi;
94c95
<      /* -----   O   -----  */
---
>     /* -----   O   -----  */
96,98c97,99
<      phi = 0.0;
<      for (nv = X_OI; nv < X_OI+O_IONS; nv++) phi += ts[nv]; 
<      for (nv = X_OI; nv < X_OI+O_IONS; nv++) flux[nv] /= phi;
---
>     phi = 0.0;
>     for (nv = X_OI; nv < X_OI+O_IONS; nv++) phi += ts[nv]; 
>     for (nv = X_OI; nv < X_OI+O_IONS; nv++) flux[nv] /= phi;
100c101
<      /* -----   Ne   -----  */
---
>     /* -----   Ne   -----  */
102,104c103,105
<      phi = 0.0;
<      for (nv = X_NeI; nv < X_NeI+Ne_IONS; nv++) phi += ts[nv];
<      for (nv = X_NeI; nv < X_NeI+Ne_IONS; nv++) flux[nv] /= phi;
---
>     phi = 0.0;
>     for (nv = X_NeI; nv < X_NeI+Ne_IONS; nv++) phi += ts[nv];
>     for (nv = X_NeI; nv < X_NeI+Ne_IONS; nv++) flux[nv] /= phi;
106c107
<      /* -----   S   -----  */
---
>     /* -----   S   -----  */
108,110c109,111
<      phi = 0.0;
<      for (nv = X_SI; nv < X_SI+S_IONS; nv++) phi += ts[nv]; 
<      for (nv = X_SI; nv < X_SI+S_IONS; nv++) flux[nv] /= phi;
---
>     phi = 0.0;
>     for (nv = X_SI; nv < X_SI+S_IONS; nv++) phi += ts[nv]; 
>     for (nv = X_SI; nv < X_SI+S_IONS; nv++) flux[nv] /= phi;
118a120,125
>     #if COOLING == KROME
>      phi = 0.0;
>      for (nv = X_H; nv < X_H + NIONS; nv++) phi += ts[nv];
>      for (nv = X_H; nv < X_H + NIONS; nv++) flux[nv] /= phi;
>     #endif
> 
126,127c133,134
<      if (flux[RHO] >= 0.0) flux[ENTR] = state->vL[i][ENTR]*flux[RHO];
<      else                  flux[ENTR] = state->vR[i][ENTR]*flux[RHO];
---
>     if (flux[RHO] >= 0.0) flux[ENTR] = vL[ENTR]*flux[RHO];
>     else                  flux[ENTR] = vR[ENTR]*flux[RHO];
130a138,206
> 
> /* ********************************************************************* */
> void StoreAMRFlux (double **flux, double **aflux, int sign,
>                     int nvar_beg, int nvar_end, int beg, int end, Grid *grid)
> /*!
>  * \param [in]  flux      pointer to a 1D flux array
>  * \param [out] aflux     pointer to a 1D flux array for AMR refluxing
>  *                        operation
>  * \param [in]  sign      an integer equal to 0, +1 or -1.
>  *                        When equal to 0, flux is initialized, otherwise
>  *                        it is added (+1) or subtracted (-1)
>  * \param [in]  nvar_beg  the starting variable index
>  * \param [in]  nvar_end  the final variable index
>  * \param [in]  grid      a pointer to the grid structure.
>  *
>  *********************************************************************** */
> {
>   int i,j,k,nv;
>   int nxf, nyf, nzf;
>   int nxb, nyb, nzb;
>   int *in;
>   long int indf, ind1;
>   double w;  
> 
> #ifdef CTU                      /* With CTU, fluxes are saved at the */
>   if (g_intStage == 1) return;  /* corrector step.                   */ 
> #endif
> 
>   nxf = grid->np_int[IDIR] + (g_dir == IDIR);
>   nyf = grid->np_int[JDIR] + (g_dir == JDIR);
>   nzf = grid->np_int[KDIR] + (g_dir == KDIR);
> 
>   nxb = grid->lbeg[IDIR] - (g_dir == IDIR);
>   nyb = grid->lbeg[JDIR] - (g_dir == JDIR);
>   nzb = grid->lbeg[KDIR] - (g_dir == KDIR);
> 
>   i = g_i; j = g_j; k = g_k;
>   if (g_dir == IDIR) in = &i;
>   if (g_dir == JDIR) in = &j;
>   if (g_dir == KDIR) in = &k;
> 
> #if TIME_STEPPING == RK2
>   w = 0.5;
> #else 
>   w = 1.0;
> #endif
> 
>   if (sign == 0){
> 
>     for ((*in) = beg; (*in) <= end; (*in)++) {
>       ind1 = (k - nzb)*nyf*nxf + (j - nyb)*nxf + (i - nxb);
>       for (nv = nvar_beg; nv <= nvar_end; nv++){
>         indf = nv*nzf*nyf*nxf + ind1;
>         aflux[g_dir][indf] = w*flux[*in][nv];
>       }
>     }
> 
>   }else{ 
> 
>     for ((*in) = beg; (*in) <= end; (*in)++) {
>       ind1 = (k - nzb)*nyf*nxf + (j - nyb)*nxf + (i - nxb);
>       for (nv = nvar_beg; nv <= nvar_end; nv++){
>         indf = nv*nzf*nyf*nxf + ind1;
>         aflux[g_dir][indf] += sign*w*flux[*in][nv];
>       }
>     }
> 
>   }
> }
diff Src/arrays.c ../old/arrays.c
101c101
<      for (i = nx; i--; ) q[i] = i*1.e18 - 1.e16;
---
>      for (i = nx; i--; ) q[i] =sqrt(-1.0); // i*1.e18 - 1.e16;
140c140
<        q[i][j] = i*j*1.e18 + 1.e16*j;
---
>        q[i][j] = sqrt(-1.0); // i*j*1.e18 + 1.e16*j;
214c214
<        q[i][j][k] = 1.e18*i + 1.e17*j + 1.e16*k + 1.e15;
---
>        q[i][j][k] = sqrt(-1.0); // 1.e18*i + 1.e17*j + 1.e16*k + 1.e15;
331c331
<        q[i][j][k][l] = l*1.e18*i + 1.e17*i*j - 1.e16*k*j + 1.e17;
---
>        q[i][j][k][l] = sqrt(-1.0); // l*1.e18*i + 1.e17*i*j - 1.e16*k*j + 1.e17;
538,539c538,539
<                           int ncl, int nch,
<                           int ndl, int ndh, double *uptr)
---
>                       int ncl, int nch,
>                       int ndl, int ndh, double *uptr)
587,588c587,588
<                                       int ncl, int nch,
<                                       int ndl,int ndh)
---
>                                   int ncl, int nch,
>                                   int ndl,int ndh)
diff Src/bin_io.c ../old/bin_io.c
25c25
<   \date   June 21, 2014
---
>   \date   Oct 22, 2015
31c31,86
< FILE *OpenBinaryFile (char *filename, int sz, char *mode)
---
> int FileClose (FILE *fbin, int sz) 
> /*!
>  * Close file.
>  *
>  * \param [in] fbin     pointer to the FILE that needs to be closed (serial
>  *                      mode only)
>  * \param [in] sz       the distributed array descriptor for parallel mode
>  *
>  * \return Returns 0 on success
>  *********************************************************************** */
> {
>   #ifdef PARALLEL 
>    AL_File_close(sz); 
>   #else
>    fclose (fbin);
>   #endif
>   return(0);
> }
> 
> /* ********************************************************************* */
> float ***Convert_dbl2flt (double ***Vdbl, double unit, int swap_endian)
> /*!
>  * Convert the a double-precision 3D array into single precision.
>  * Swap endianity if swap_endian == 1.
>  *
>  * \param [in] Vdbl         pointer to a 3D double precision aray
>  * \param [in] unit         a multiplicative constant typically used 
>  *                          to write in c.g.s units.
>  * \param [in] swap_endian  when set to 1, swap endianity during the 
>  *                          conversion.
>  * \return a pointer to a 3D array in single precision.
>  *********************************************************************** */
> {
>   int i, j, k;
>   float  flt;
>   static float ***Vflt;
>   
>   if (Vflt == NULL) Vflt = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, float);
> 
>   if (!swap_endian){
>     DOM_LOOP(k,j,i){
>       Vflt[k][j][i] = (float)(Vdbl[k][j][i]*unit);
>     }
>   }else{
>     DOM_LOOP(k,j,i){
>       flt = (float)(Vdbl[k][j][i]*unit);
>       SWAP_VAR(flt);
>       Vflt[k][j][i] = flt;
>     }
>   }
> 
>   return (Vflt);
> }
> 
> /* ********************************************************************* */
> FILE *FileOpen (char *filename, int sz, char *mode)  
53c108
<       print1 ("! OpenBinaryFile: file %s does not exists\n", filename);
---
>       print ("! FileOpen(): file %s does not exists\n", filename);
63,94c118,139
<   #ifdef PARALLEL
<    AL_File_open(filename, sz); 
<    return NULL;
<   #else
<    if      (strcmp(mode,"w") == 0) fp = fopen(filename, "wb");
<    else if (strcmp(mode,"r") == 0) fp = fopen(filename, "rb");
<    if (fp == NULL){
<      print1 ("! Cannot find file %s\n",filename);
<      QUIT_PLUTO(1);
<    }
<    return (fp);
<   #endif
< }
< 
< /* ********************************************************************* */
< int CloseBinaryFile (FILE *fbin, int sz)
< /*!
<  * Close file.
<  *
<  * \param [in] fbin     pointer to the FILE that needs to be closed (serial
<  *                      mode only)
<  * \param [in] sz       the distributed array descriptor for parallel mode
<  *
<  * \return Returns 0 on success
<  *********************************************************************** */
< {
<   #ifdef PARALLEL 
<    AL_File_close(sz); 
<   #else
<    fclose (fbin);
<   #endif
<   return(0);
---
> #ifdef PARALLEL
> /*  CANNOT USE IT HERE SINCE FILE IS OPENED AND CLOSED FOR APPENDING SEVERAL TIMES
>   if (strcmp(mode,"w") == 0){
> print ("Deleting file...\n");
>     MPI_File fh;
>     MPI_File_open(MPI_COMM_WORLD, filename,
>                   MPI_MODE_CREATE | MPI_MODE_WRONLY | MPI_MODE_DELETE_ON_CLOSE,
>                   MPI_INFO_NULL, &fh);
>     MPI_File_close(&fh);
>   }  
> */      
>   AL_File_open(filename, sz); 
>   return NULL;
> #else
>   if      (strcmp(mode,"w") == 0) fp = fopen(filename, "wb");
>   else if (strcmp(mode,"r") == 0) fp = fopen(filename, "rb");
>   if (fp == NULL){
>     print ("! Cannot find file %s\n",filename);
>     QUIT_PLUTO(1);
>   }
>   return (fp);
> #endif
98c143,144
< void WriteBinaryArray (void *V, size_t dsize, int sz, FILE *fl, int istag)
---
> void FileReadData (void *V, size_t dsize, int sz, FILE *fl, int istag,
>                    int swap_endian) 
100,146c146
<  * Write an array to disk in binary format.
<  *
<  * \param [in] V      single pointer to a 3D array,
<  *                    V[k][j][i] -->  V[i + NX1*j + NX1*NX2*k]. Must
<  *                    start with index 0
<  * \param [in] dsize  the size of the each buffer element   
<  *                    (sizeof(double) or sizeof(float)). This
<  *                    parameter is used only in serial mode.
<  * \param [in] sz     the distributed array descriptor. This parameter
<  *                    replaces dsize in parallel mode
<  * \param [in] fl     a valid FILE pointer
<  * \param [in] istag  a flag to identify cell-centered (istag = -1) or
<  *                    staggered field data (istag = 0,1 or 2 for staggering 
<  *                    in the x1, x2 or x3 directions) 
<  *
<  * \return This function has no return value.
<  *
<  * \remark The data array is assumed to start \a always with index 0 for
<  *         both cell-centered and staggered arrays.
<  *********************************************************************** */
< {
<   int i, j, k;
<   int ioff, joff, koff;
<   char *Vc;
< 
<   #ifdef PARALLEL
<    MPI_Barrier (MPI_COMM_WORLD);
<    AL_Write_array (V, sz, istag);
<    return;
<   #else
<    Vc = (char *) V;
<    ioff = (istag == 0); 
<    joff = (istag == 1); 
<    koff = (istag == 2);
< 
<    for (k = KBEG; k <= KEND + koff; k++) {
<    for (j = JBEG; j <= JEND + joff; j++) {
<      i = IBEG + (NX1_TOT + ioff)*(j + (NX2_TOT + joff)*k);
<      fwrite (Vc + i*dsize, dsize, NX1 + ioff, fl);
<    }}
<   #endif
< }
< /* ********************************************************************* */
< void ReadBinaryArray (void *V, size_t dsize, int sz, FILE *fl, int istag,
<                       int swap_endian)
< /*!
<  * Read a double-precision array from binary file. 
---
>  * Read a 3D grid data array V[k][j][i] from a binary file. 
176,178c176,178
<   #ifdef PARALLEL 
<    AL_Read_array (V, sz, istag);
<   #else
---
> #ifdef PARALLEL 
>   AL_Read_array (V, sz, istag);
> #else
184,194c184,194
<    Vc = (char *) V;
<    ioff = (istag == 0); 
<    joff = (istag == 1); 
<    koff = (istag == 2);
< 
<    for (k = KBEG; k <= KEND + koff; k++) {
<    for (j = JBEG; j <= JEND + joff; j++) {
<      i = IBEG + (NX1_TOT + ioff)*(j + (NX2_TOT + joff)*k);
<      fread (Vc + i*dsize, dsize, NX1 + ioff, fl);
<    }}
<   #endif
---
>   Vc = (char *) V;
>   ioff = (istag == 0); 
>   joff = (istag == 1); 
>   koff = (istag == 2);
> 
>   for (k = KBEG; k <= KEND + koff; k++) {
>   for (j = JBEG; j <= JEND + joff; j++) {
>     i = IBEG + (NX1_TOT + ioff)*(j + (NX2_TOT + joff)*k);
>     fread (Vc + i*dsize, dsize, NX1 + ioff, fl);
>   }}
> #endif
216c216
< float ***Convert_dbl2flt (double ***Vdbl, double unit, int swap_endian)
---
> void FileWriteData (void *V, size_t dsize, int sz, FILE *fl, int istag)
218,219c218
<  * Convert the a double-precision 3D array into single precision.
<  * Swap endianity if swap_endian == 1.
---
>  * Write a 3D grid data array V[k][j][i] to a binary file. 
221,226c220,236
<  * \param [in] Vdbl         pointer to a 3D double precision aray
<  * \param [in] unit         a multiplicative constant typically used 
<  *                          to write in c.g.s units.
<  * \param [in] swap_endian  when set to 1, swap endianity during the 
<  *                          conversion.
<  * \return a pointer to a 3D array in single precision.
---
>  * \param [in] V      single pointer to a 3D array,
>  *                    V[k][j][i] -->  V[i + NX1*j + NX1*NX2*k]. Must
>  *                    start with index 0
>  * \param [in] dsize  the size of the each buffer element   
>  *                    (sizeof(double) or sizeof(float)). This
>  *                    parameter is used only in serial mode.
>  * \param [in] sz     the distributed array descriptor. This parameter
>  *                    replaces dsize in parallel mode
>  * \param [in] fl     a valid FILE pointer
>  * \param [in] istag  a flag to identify cell-centered (istag = -1) or
>  *                    staggered field data (istag = 0,1 or 2 for staggering 
>  *                    in the x1, x2 or x3 directions) 
>  *
>  * \return This function has no return value.
>  *
>  * \remark The data array is assumed to start \a always with index 0 for
>  *         both cell-centered and staggered arrays.
230,231c240,304
<   float  flt;
<   static float ***Vflt;
---
>   int ioff, joff, koff;
>   char *Vc;
> 
> #ifdef PARALLEL
>   MPI_Barrier (MPI_COMM_WORLD);
>   AL_Write_array (V, sz, istag);
>   return;
> #else
>   Vc = (char *) V;
>   ioff = (istag == 0); 
>   joff = (istag == 1); 
>   koff = (istag == 2);
> 
>   for (k = KBEG; k <= KEND + koff; k++) {
>   for (j = JBEG; j <= JEND + joff; j++) {
>     i = IBEG + (NX1_TOT + ioff)*(j + (NX2_TOT + joff)*k);
>     fwrite (Vc + i*dsize, dsize, NX1 + ioff, fl);
>   }}
> #endif
> }
> 
> 
> /* ********************************************************************* */
> int FileDelete (char *fname)
> /*!
>  * Delete a file (parallel mode only).
>  * Useful on some architecture where MPI_File_open will just overwrite
>  * the file without erasing it.
>  * 
>  *
>  * \param [in] filename a valid file name
>  *
>  * \return The pointer to the file.
>  *********************************************************************** */
> {
> #ifdef PARALLEL
>   MPI_File fp;
> 
>   MPI_File_open(MPI_COMM_WORLD, fname,
>                 MPI_MODE_CREATE | MPI_MODE_WRONLY | MPI_MODE_DELETE_ON_CLOSE,
>                 MPI_INFO_NULL, &fp);
>   MPI_File_close(&fp);
> #endif
> }
> 
> /* ********************************************************************* */
> void FileWriteArray(void *buf, long int offset, int cnt, size_t size, char *fname)
> /*!
>  *  Write an array to file using raw binary format.
>  *  No AL distributed array descriptor is used here.
>  *
>  * \param [in]   buf      address of buffer to be written
>  * \param [in]   offset   file offset (in bytes)
>  * \param [in]   cnt      the number of element to be written
>  * \param [in]   size     the sizeof() datatype
>  * \param [in]   fname    the file name 
>  *********************************************************************** */
> {
>   char *cbuf = (char *) buf;
>   cnt *= size;  /* Convert number of elements to byte */
> 
> #ifdef PARALLEL
>   MPI_File fhw;
>   MPI_Status status;
>   MPI_Offset start;   /* Store end of file position */
233c306,320
<   if (Vflt == NULL) Vflt = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, float);
---
>   
>   MPI_File_open(MPI_COMM_WORLD, fname, 
>                 MPI_MODE_WRONLY | MPI_MODE_APPEND, MPI_INFO_NULL, &fhw);
>   MPI_File_get_position(fhw, &start);
>     
>   MPI_File_set_view (fhw, start+offset, MPI_BYTE, MPI_CHAR, "native", MPI_INFO_NULL);
>   MPI_File_write_all(fhw, cbuf, cnt, MPI_CHAR, &status);
>   MPI_File_close(&fhw);
> #else
>   FILE *fp = fopen (fname,"ab"); /* -- Open for appending in binary mode -- */
>   fwrite (cbuf, sizeof(char), cnt, fp);
>   fclose (fp);    
> #endif
>   
> }
235,238c322,354
<   if (!swap_endian){
<     DOM_LOOP(k,j,i){
<       Vflt[k][j][i] = (float)(Vdbl[k][j][i]*unit);
<     }
---
> /* ********************************************************************* */
> void FileWriteHeader(char *buffer, char fname[], int mode)
> /*!
>  *  Write or Append an ASCII header to a file.
>  *
>  * \param [in]   buffer  the input buffer (a string). 
>  * \param [in]   fname   the file name
>  * \param [in]   mode    an integer specifying if the file has to be
>  *                       opened for the first time (mode = -1) or
>  *                       appended (mode >= 0)
>  * 
>  *********************************************************************** */
> {
>   int nelem = strlen(buffer);
> #ifdef PARALLEL
>   MPI_File fhw;
>   MPI_Status status;
>   MPI_Offset start; /* Used to store end of file position */
> 
>   if (mode < 0){
>   
>   /* -- Open file and delete it -- */
>   
>     MPI_File_open(MPI_COMM_WORLD, fname,
>                   MPI_MODE_CREATE | MPI_MODE_WRONLY | MPI_MODE_DELETE_ON_CLOSE,
>                   MPI_INFO_NULL, &fhw);
>     MPI_File_close(&fhw);
>     
>   /* -- Open file for writing -- */    
> 
>     MPI_File_open(MPI_COMM_WORLD, fname, 
>                   MPI_MODE_CREATE | MPI_MODE_WRONLY, MPI_INFO_NULL, &fhw);
>     start = 0;
240,244c356,358
<     DOM_LOOP(k,j,i){
<       flt = (float)(Vdbl[k][j][i]*unit);
<       SWAP_VAR(flt);
<       Vflt[k][j][i] = flt;
<     }
---
>     MPI_File_open(MPI_COMM_WORLD, fname, 
>                   MPI_MODE_WRONLY | MPI_MODE_APPEND, MPI_INFO_NULL, &fhw);
>     MPI_File_get_position(fhw, &start);
247c361,376
<   return (Vflt);
---
>   MPI_Barrier(MPI_COMM_WORLD);
>   MPI_File_set_view(fhw, start, MPI_BYTE, MPI_CHAR, "native", MPI_INFO_NULL);
>   if( prank == 0 ){
>     MPI_File_write(fhw, buffer, nelem, MPI_CHAR, &status); 
>   }
>   MPI_File_close(&fhw);
> #else
>   FILE *fp;
>   if (mode < 0){
>     fp = fopen (fname,"wb"); /* -- Open for the first time -- */
>   }else{
>     fp = fopen(fname, "ab"); /* -- for appending in binary mode -- */
>   }
>   fwrite (buffer, sizeof(char), nelem, fp);
>   fclose (fp);    
> #endif
diff Src/boundary.c ../old/boundary.c
11,12c11,12
<   given grid is specified by the integers <c> grid[dir].lbound </c> or 
<   <c> grid[dir].rbound </c>, respectively.
---
>   given grid is specified by the integers <c> grid.lbound[dir] </c> or 
>   <c> grid.rbound[dir] </c>, respectively.
30c30
<   \date   Dec 18, 2014
---
>   \date   Nov 23, 2017
33a34,38
> 
> static void OutflowBound   (double ***, RBox *, int);
> static void ReflectiveBound(double ***, int, RBox *, int);
> static void PeriodicBound  (double ***, RBox *, int);
> static void FlipSign       (int, int, int *);
52c57
<  * \param [in]  grid   pointer to an array of grid structures.
---
>  * \param [in]  grid   pointer to grid structure.
55c60
<   int  is, nv, fargo_velocity_has_changed;
---
>   int  is, nv;
59c64,65
<   double ***q;
---
>   int  ib,ie,jb,je,kb,ke;
>   RBox center_box, x1face_box, x2face_box, x3face_box;
61,82c67,69
< /* ---------------------------------------------------
<     Check the number of processors in each direction
<    --------------------------------------------------- */
< 
<   D_EXPAND(par_dim[0] = grid[IDIR].nproc > 1;  ,
<            par_dim[1] = grid[JDIR].nproc > 1;  ,
<            par_dim[2] = grid[KDIR].nproc > 1;)
< 
< /* -------------------------------------------------
<     With FARGO, boundary conditions must be set on 
<     total velocity. 
<     We temporarily add the background motion if 
<     the input array contains the deviation only.
<    ------------------------------------------------- */
<    
<    #ifdef FARGO
<     fargo_velocity_has_changed = NO;
<     if (FARGO_HasTotalVelocity() == NO) {
<       FARGO_AddVelocity (d,grid);
<       fargo_velocity_has_changed = YES;
<     }
<    #endif
---
> /* --------------------------------------------------------
>    0. Check the number of processors in each direction
>    -------------------------------------------------------- */
84,86c71,73
< /* -------------------------------------------------
<     Call userdef internal boundary with side == 0
<    -------------------------------------------------  */
---
>   D_EXPAND(par_dim[0] = grid->nproc[IDIR] > 1;  ,
>            par_dim[1] = grid->nproc[JDIR] > 1;  ,
>            par_dim[2] = grid->nproc[KDIR] > 1;)
88,90c75,92
<   #if INTERNAL_BOUNDARY == YES
<    UserDefBoundary (d, NULL, 0, grid);
<   #endif
---
> /* --------------------------------------------------------
>    1. When FARGO is on, boundary conditions must be set 
>       on total velocity. 
>    -------------------------------------------------------- */
> 
> #ifdef FARGO
>   if (g_hydroStep && FARGO_TotalVelocityIsSet() == 0){
>     FARGO_AddVelocity (d,grid);
>   }
> #endif
> 
> /* --------------------------------------------------------
>    2. Call userdef internal boundary with side == 0
>    --------------------------------------------------------  */
> 
> #if INTERNAL_BOUNDARY == YES
>   UserDefBoundary (d, NULL, 0, grid);
> #endif
92,94c94,96
< /* -------------------------------------
<      Exchange data between processors 
<    ------------------------------------- */
---
> /* --------------------------------------------------------
>    3.  Exchange data between processors 
>    -------------------------------------------------------- */
96,107c98,107
<   #ifdef PARALLEL
<    MPI_Barrier (MPI_COMM_WORLD);
<    for (nv = 0; nv < NVAR; nv++) {
<      AL_Exchange_dim ((char *)d->Vc[nv][0][0], par_dim, SZ);
<    }
<    #ifdef STAGGERED_MHD 
<     D_EXPAND(
<       AL_Exchange_dim ((char *)(d->Vs[BX1s][0][0] - 1), par_dim, SZ_stagx);  ,
<       AL_Exchange_dim ((char *)d->Vs[BX2s][0][-1]     , par_dim, SZ_stagy);  ,
<       AL_Exchange_dim ((char *)d->Vs[BX3s][-1][0]     , par_dim, SZ_stagz);)
<    #endif
<    MPI_Barrier (MPI_COMM_WORLD);
---
> #ifdef PARALLEL
>   MPI_Barrier (MPI_COMM_WORLD);
>   for (nv = 0; nv < NVAR; nv++) {
>     AL_Exchange_dim ((char *)d->Vc[nv][0][0], par_dim, SZ);
>   }
>   #ifdef STAGGERED_MHD 
>   D_EXPAND(
>     AL_Exchange_dim ((char *)(d->Vs[BX1s][0][0] - 1), par_dim, SZ_stagx);  ,
>     AL_Exchange_dim ((char *)d->Vs[BX2s][0][-1]     , par_dim, SZ_stagy);  ,
>     AL_Exchange_dim ((char *)d->Vs[BX3s][-1][0]     , par_dim, SZ_stagz);)
108a109,110
>   MPI_Barrier (MPI_COMM_WORLD);
> #endif
110,115c112,119
< /* ----------------------------------------------------------------
<      When idim == ALL_DIR boundaries are imposed on ALL sides:
<      a loop from sbeg = 0 to send = 2*DIMENSIONS - 1 is performed. 
<      When idim = n, boundaries are imposed at the beginning and 
<      the end of the i-th direction.
<    ---------------------------------------------------------------- */ 
---
> /* ---------------------------------------------------------
>    4. When idim == ALL_DIR boundaries are imposed on ALL 
>       sides: a loop from sbeg = 0 to send = 2*DIMENSIONS - 1 
>       is performed. 
>      
>       When idim = n, boundaries are imposed at the 
>       beginning and the end of the i-th direction.
>    -------------------------------------------------------- */ 
126c130
<         Main loop on computational domain sides
---
>    5. Main loop on computational domain sides
129,131c133,135
<   type[0] = grid[IDIR].lbound; type[1] = grid[IDIR].rbound;
<   type[2] = grid[JDIR].lbound; type[3] = grid[JDIR].rbound;
<   type[4] = grid[KDIR].lbound; type[5] = grid[KDIR].rbound;
---
>   type[0] = grid->lbound[IDIR]; type[1] = grid->rbound[IDIR];
>   type[2] = grid->lbound[JDIR]; type[3] = grid->rbound[JDIR];
>   type[4] = grid->lbound[KDIR]; type[5] = grid->rbound[KDIR];
137,149c141,180
<     if (type[is] == OUTFLOW) {
< 
<     /* -------------------------------
<          OUTFLOW boundary condition 
<        ------------------------------- */
<  
<       for (nv = 0; nv < NVAR; nv++){
<         OutflowBound (d->Vc[nv], side[is], CENTER, grid + (is/2));   
<       }
<       #ifdef STAGGERED_MHD 
<        D_EXPAND(OutflowBound (d->Vs[BX1s], side[is], X1FACE, grid+(is/2)); ,
<                 OutflowBound (d->Vs[BX2s], side[is], X2FACE, grid+(is/2)); ,
<                 OutflowBound (d->Vs[BX3s], side[is], X3FACE, grid+(is/2));)
---
>   /* ----------------------------------------------
>      5a. Define boundary boxes, sweeping direction. 
>      ---------------------------------------------- */
> 
>     ib = 0; ie = NX1_TOT-1;
>     jb = 0; je = NX2_TOT-1;
>     kb = 0; ke = NX3_TOT-1;
> 
>     if      (side[is] == X1_BEG) {ib = IBEG-1; ie = 0;}         /* Backward */
>     else if (side[is] == X1_END) {ib = IEND+1; ie = NX1_TOT-1;} /* Forward */
>     else if (side[is] == X2_BEG) {jb = JBEG-1; je = 0;}         /* Backward */
>     else if (side[is] == X2_END) {jb = JEND+1; je = NX2_TOT-1;} /* Forward */
>     else if (side[is] == X3_BEG) {kb = KBEG-1; ke = 0;}         /* Backward */
>     else if (side[is] == X3_END) {kb = KEND+1; ke = NX3_TOT-1;} /* Forward */
> 
>     RBoxDefine (ib, ie, jb, je, kb, ke, CENTER, &center_box);
> #ifdef STAGGERED_MHD
>     /* -- Define RBoxes for staggered field (! Note the backward/forward order) -- */
>     if (ib < ie) RBoxDefine (ib-1, ie  , jb  , je  , kb  , ke  , X1FACE, &x1face_box);
>     else         RBoxDefine (ib  , ie-1, jb  , je  , kb  , ke  , X1FACE, &x1face_box);
>     if (jb < je) RBoxDefine (ib  , ie  , jb-1, je  , kb  , ke  , X2FACE, &x2face_box);
>     else         RBoxDefine (ib  , ie  , jb  , je-1, kb  , ke  , X2FACE, &x2face_box);
>     if (kb < ke) RBoxDefine (ib  , ie  , jb  , je  , kb-1, ke  , X3FACE, &x3face_box);
>     else         RBoxDefine (ib  , ie  , jb  , je  , kb  , ke-1, X3FACE, &x3face_box);
> #endif
> 
>   /* --------------------------------------------------------
>      5b. Apply boundary conditions.
>      -------------------------------------------------------- */
> 
>     if (type[is] == OUTFLOW) {    /* ---- Outflow B.C. ---- */
> 
>       NVAR_LOOP(nv) OutflowBound (d->Vc[nv], &center_box, side[is]);
> #ifdef STAGGERED_MHD
>       D_EXPAND(if (side[is] != X1_BEG && side[is] != X1_END)
>                  OutflowBound (d->Vs[BX1s], &x1face_box, side[is]); ,
>                if (side[is] != X2_BEG && side[is] != X2_END)
>                  OutflowBound (d->Vs[BX2s], &x2face_box, side[is]); ,
>                if (side[is] != X3_BEG && side[is] != X3_END)                 
>                  OutflowBound (d->Vs[BX3s], &x3face_box, side[is]);)
152,153c183,185
<         average normal field only since transverse components
<         are assigned consistently with cell-centered quantities.
---
>         Recover normal magnetic field and average it to cell
>         center. Transverse components are assigned consistently
>         with cell-centered quantities.
155,157c187,190
<             
<        CT_AverageNormalMagField (d, side[is], grid);
<       #endif
---
> 
>       FillMagneticField (d, side[is], grid);
>       CT_AverageNormalMagField (d, side[is], grid);
> #endif
161,165c194
<              || (type[is] == EQTSYMMETRIC)){
< 
<     /* -------------------------------------
<         REFLECTIVE-type boundary conditions 
<        ------------------------------------- */
---
>              || (type[is] == EQTSYMMETRIC)){ /* ---- Reflective B.C. ---- */
168,177c197,207
<       for (nv = 0; nv < NVAR; nv++){
<         ReflectiveBound (d->Vc[nv], vsign[nv], side[is], CENTER);
<       }
<       #ifdef STAGGERED_MHD  
<        D_EXPAND(ReflectiveBound(d->Vs[BX1s], vsign[BX1], side[is], X1FACE);  ,
<                 ReflectiveBound(d->Vs[BX2s], vsign[BX2], side[is], X2FACE);  ,
<                 ReflectiveBound(d->Vs[BX3s], vsign[BX3], side[is], X3FACE);)
<       #endif
< 
<     }else if (type[is] == PERIODIC) {
---
>       NVAR_LOOP(nv) ReflectiveBound (d->Vc[nv], vsign[nv], &center_box, side[is]);
> #ifdef STAGGERED_MHD
>       D_EXPAND(if (side[is] != X1_BEG && side[is] != X1_END)
>                  ReflectiveBound(d->Vs[BX1s], vsign[BX1], &x1face_box, side[is]);  ,
>                if (side[is] != X2_BEG && side[is] != X2_END)  
>                  ReflectiveBound(d->Vs[BX2s], vsign[BX2], &x2face_box, side[is]);  ,
>                if (side[is] != X3_BEG && side[is] != X3_END)
>                  ReflectiveBound(d->Vs[BX3s], vsign[BX3], &x3face_box, side[is]);)
>                   
>       FillMagneticField (d, side[is], grid);
> #endif
179,182c209
<     /* ----------------------------------------
<         PERIODIC boundary condition (only for 
<         one processor in the direction) 
<        ---------------------------------------- */
---
>     }else if (type[is] == PERIODIC){  /* -- Periodic B.C. (serial or 1 proc) -- */
185,193c212,217
<         for (nv = 0; nv < NVAR; nv++){
<           PeriodicBound (d->Vc[nv], side[is], CENTER);
<         }
<         #ifdef STAGGERED_MHD
<          D_EXPAND(PeriodicBound (d->Vs[BX1s], side[is], X1FACE);  ,
<                   PeriodicBound (d->Vs[BX2s], side[is], X2FACE);  ,
<                   PeriodicBound (d->Vs[BX3s], side[is], X3FACE);)
<         #endif
<  
---
>         NVAR_LOOP(nv)  PeriodicBound(d->Vc[nv], &center_box, side[is]);
> #ifdef STAGGERED_MHD
>         D_EXPAND(PeriodicBound(d->Vs[BX1s], &x1face_box, side[is]);  ,
>                  PeriodicBound(d->Vs[BX2s], &x2face_box, side[is]);  ,
>                  PeriodicBound(d->Vs[BX3s], &x3face_box, side[is]);)
> #endif
196c220
<     }else if (type[is] == SHEARING) {  /* -- shearingbox boundary -- */
---
>     }else if (type[is] == SHEARING) {  /* -- Shearingbox B.C. -- */
206,221c230,243
<       #ifdef SHEARINGBOX
<        if (side[is] != X1_BEG && side[is] != X1_END){
<          print1 ("! BOUNDARY: shearingbox can only be assigned at an X1 boundary\n");
<          QUIT_PLUTO(1);
<        }
<        if (grid[IDIR].nproc == 1){
<          for (nv = 0; nv < NVAR; nv++) {
<            PeriodicBound (d->Vc[nv], side[is], CENTER);
<          }
<          #ifdef STAGGERED_MHD
<           D_EXPAND(                                             ;  ,
<                    PeriodicBound (d->Vs[BX2s], side[is], X2FACE);  ,
<                    PeriodicBound (d->Vs[BX3s], side[is], X3FACE);)
<          #endif
<        }
<        SB_Boundary (d, side[is], grid);
---
> #ifdef SHEARINGBOX
>       if (side[is] != X1_BEG && side[is] != X1_END){
>         print ("! Boundary(): shearingbox can only be assigned at an X1 boundary\n");
>         QUIT_PLUTO(1);
>       }
>       if (grid->nproc[IDIR] == 1){
>         NVAR_LOOP(nv) PeriodicBound(d->Vc[nv], &center_box, side[is]);
>       #ifdef STAGGERED_MHD
>         D_EXPAND(                                                 ;  ,
>                  PeriodicBound(d->Vs[BX2s], &x2face_box, side[is]);  ,
>                  PeriodicBound(d->Vs[BX3s], &x3face_box, side[is]);)
>       #endif
>       }
>       SB_Boundary (d, side[is], grid);
226,233c248,256
<        #ifdef STAGGERED_MHD
<         FillMagneticField (d, side[is], grid);  
<         CT_AverageNormalMagField (d, side[is], grid);
<         CT_AverageTransverseMagField (d, side[is], grid);
<        #endif
<       #endif  /* def SHEARINGBOX */
< 
<     }else if (type[is] == USERDEF) {
---
>       #ifdef STAGGERED_MHD
>       FillMagneticField (d, side[is], grid);  
>       CT_AverageNormalMagField (d, side[is], grid);
>       CT_AverageTransverseMagField (d, side[is], grid);
>       #endif
> #else
>       print ("! Boundary(): shearingbox module not loaded\n");
>       QUIT_PLUTO(1);
> #endif  /* #ifdef SHEARINGBOX */
235,237c258
<     /* --------------------------------------------------------------
<              USER-DEFINED boundary condition
<        -------------------------------------------------------------- */
---
>     }else if (type[is] == USERDEF) { /* ---- User-defined B.C. ---- */
240a262
> /*
248a271,275
> */
>        BOX_LOOP(&center_box, k, j, i) d->Vc[PSI_GLM][k][j][i] = 0.0;
>        #ifdef PHI_GLM
>        BOX_LOOP(&center_box, k, j, i) d->Vc[PHI_GLM][k][j][i] = 0.0;
>        #endif
252,260c279,283
<       RBox *box = GetRBox(side[is], CENTER);
<       UserDefBoundary (d, box, side[is], grid);
<       #ifdef STAGGERED_MHD
<         D_EXPAND(box = GetRBox(side[is], X1FACE);
<                  UserDefBoundary (d, box, side[is], grid);  ,
<                  box = GetRBox(side[is], X2FACE);
<                  UserDefBoundary (d, box, side[is], grid);  ,
<                  box = GetRBox(side[is], X3FACE);
<                  UserDefBoundary (d, box, side[is], grid);)
---
>       UserDefBoundary (d, &center_box, side[is], grid);
> #ifdef STAGGERED_MHD
>       D_EXPAND(UserDefBoundary (d, &x1face_box, side[is], grid);  , /* Only 2 needed */
>                UserDefBoundary (d, &x2face_box, side[is], grid);  ,
>                UserDefBoundary (d, &x3face_box, side[is], grid);)
265,268c288,291
<        FillMagneticField (d, side[is], grid);  
<        CT_AverageNormalMagField (d, side[is], grid);
<        CT_AverageTransverseMagField (d, side[is], grid);
<       #endif
---
>       FillMagneticField (d, side[is], grid);  
>       CT_AverageNormalMagField (d, side[is], grid);
>       CT_AverageTransverseMagField (d, side[is], grid);
> #endif
272,373c295,297
< /* --------------------------------------------------
<     With FARGO, restore velocity deviation if the 
<     original input array to Boundary() did not 
<     contain the background velocity.
<    -------------------------------------------------- */
<    
<    #ifdef FARGO
<     if (fargo_velocity_has_changed){
<       if (FARGO_HasTotalVelocity() == YES) FARGO_SubtractVelocity(d,grid);
<     }
<    #endif
< 
< /* -------------------------------------------------------
<     Compute entropy for the next time level
<    ------------------------------------------------------- */
< 
<   #if ENTROPY_SWITCH
<    ComputeEntropy (d, grid);
<   #endif
<     
< }
< 
< /* ********************************************************************* */
< void OutflowBound (double ***q, int side, int vpos, Grid *grid)
< /*! 
<  * Impose zero-gradient boundary conditions on 'q' on 
<  * the boundary side specified by box->side.
<  * The staggered component of magnetic field is assigned
<  * using the div.B = 0 condition in a different loop.
<  *
<  * \param [in,out] q   a 3D array representing a flow variable
<  * \param [in]    box pointer to a RBox structure defining the extent
<  *                    of the boundary region and the variable position
<  *                    inside the cell
<  * \param [in]    grid  pointer to an array of Grid structures
<  *********************************************************************** */
< {
<   int  i, j, k;
<   double dB, *A, *dV;
<   RBox *box = GetRBox (side, vpos);
< 
<   A  = grid->A;
<   dV = grid->dV;
< 
<   if (side == X1_BEG) { 
<     if (box->vpos != X1FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][j][IBEG];   
<     }else{
<       BOX_LOOP(box,k,j,i){
<         #if GEOMETRY == CARTESIAN
<          q[k][j][i] = 2.0*q[k][j][i+1] - q[k][j][i+2];
<         #else
<          dB = (A[i+2]*q[k][j][i+2] - A[i+1]*q[k][j][i+1])/dV[i+2];
<          q[k][j][i] = (q[k][j][i+1]*A[i+1] - dV[i+1]*dB)/A[i];
<         #endif
<       }
<     }
< 
<   }else if (side == X1_END){
< 
<     if (box->vpos != X1FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][j][IEND];   
<     }else{
<       BOX_LOOP(box,k,j,i){
<         #if GEOMETRY == CARTESIAN
<          q[k][j][i] = 2.0*q[k][j][i-1] - q[k][j][i-2];
<         #else
<          dB = (A[i-1]*q[k][j][i-1] - A[i-2]*q[k][j][i-2])/dV[i-1];
<          q[k][j][i] = (q[k][j][i-1]*A[i-1] + dV[i]*dB)/A[i];
<         #endif
<       }
<     }
< 
<   }else if (side == X2_BEG){
< 
<     if (box->vpos != X2FACE) {
<       BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][JBEG][i];
<     }else{
<       BOX_LOOP(box,k,j,i) {
<         #if GEOMETRY == CARTESIAN
<          q[k][j][i] = 2.0*q[k][j+1][i] - q[k][j+2][i];
<         #else
<          dB = (A[j+2]*q[k][j+2][i] - A[j+1]*q[k][j+1][i])/dV[j+2];
<          q[k][j][i] = (q[k][j+1][i]*A[j+1] - dV[j+1]*dB)/A[j];
<         #endif
<       }
<     }
< 
<   }else if (side == X2_END){
< 
<     if (box->vpos != X2FACE) {
<       BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][JEND][i];
<     }else{
<       BOX_LOOP(box,k,j,i){
<         #if GEOMETRY == CARTESIAN
<          q[k][j][i] = 2.0*q[k][j-1][i] - q[k][j-2][i];
<         #else
<          dB = (A[j-1]*q[k][j-1][i] - A[j-2]*q[k][j-2][i])/dV[j-1];
<          q[k][j][i] = (q[k][j-1][i]*A[j-1] + dV[j]*dB)/A[j];
<         #endif
<       }
<     }
---
> /* --------------------------------------------------------
>    6. Compute entropy for the next time level
>    -------------------------------------------------------- */
375c299,301
<   }else if (side == X3_BEG){
---
> #if ENTROPY_SWITCH
>   ComputeEntropy (d, grid);
> #endif
377,388c303,307
<     if (box->vpos != X3FACE) {
<       BOX_LOOP(box,k,j,i) q[k][j][i] = q[KBEG][j][i];
<     }else{
<       BOX_LOOP(box,k,j,i) {
<         #if GEOMETRY == CARTESIAN
<          q[k][j][i] = 2.0*q[k+1][j][i] - q[k+2][j][i];
<         #else
<          dB = (A[k+2]*q[k+2][j][i] - A[k+1]*q[k+1][j][i])/dV[k+2];
<          q[k][j][i] = (q[k+1][j][i]*A[k+1] - dV[k+1]*dB)/A[k];
<         #endif
<       }
<     }
---
> /* --------------------------------------------------------
>    7. Subtract velocity if we're doing an hydro step
>       (but not if we're doing an operator-split parabolic
>        step)
>    -------------------------------------------------------- */
390c309,313
<   }else if (side == X3_END){
---
> #ifdef FARGO
>   if (g_hydroStep && FARGO_TotalVelocityIsSet() == 1) {
>     FARGO_SubtractVelocity(d, grid);
>   }  
> #endif
392,404d314
<     if (box->vpos != X3FACE) {
<       BOX_LOOP(box,k,j,i) q[k][j][i] = q[KEND][j][i];
<     }else{
<       BOX_LOOP(box,k,j,i) {
<         #if GEOMETRY == CARTESIAN
<          q[k][j][i] = 2.0*q[k-1][j][i] - q[k-2][j][i];  
<         #else
<          dB = (A[k-1]*q[k-1][j][i] - A[k-2]*q[k-2][j][i])/dV[k-1];
<          q[k][j][i] = (q[k-1][j][i]*A[k-1] + dV[k]*dB)/A[k];
<         #endif
<       }
<     }
<   }
414,416c324,326
<  *   o   Vn -> -Vn,  Bn -> -Bn  \n
<  *   o   Vp ->  Vp,  Bp ->  Bp  \n 
<  *   o   Vt ->  Vt,  Bt ->  Bt
---
>  *   o   Vn -> -Vn,  Bn -> -Bn,  En ->  En  \n
>  *   o   Vp ->  Vp,  Bp ->  Bp,  Ep -> -Ep  \n 
>  *   o   Vt ->  Vt,  Bt ->  Bt,  Et -> -Et
419,421c329,331
<  *   o   Vn -> -Vn,  Bn -> -Bn \n
<  *   o   Vp ->  Vp,  Bp ->  Bp \n
<  *   o   Vt -> -Vt,  Bt -> -Bt
---
>  *   o   Vn -> -Vn,  Bn -> -Bn,  En -> -En \n
>  *   o   Vp ->  Vp,  Bp ->  Bp,  Ep ->  Ep \n
>  *   o   Vt -> -Vt,  Bt -> -Bt,  Et -> -Et
424,426c334,336
<  *   o   Vn -> -Vn,  Bn ->  Bn  \n
<  *   o   Vp ->  Vp,  Bp -> -Bp  \n
<  *   o   Vt ->  Vt,  Bt -> -Bt
---
>  *   o   Vn -> -Vn,  Bn ->  Bn,  En -> -En  \n
>  *   o   Vp ->  Vp,  Bp -> -Bp,  Ep ->  Ep  \n
>  *   o   Vt ->  Vt,  Bt -> -Bt,  Et ->  Et
438a349
> #if PHYSICS == MHD || PHYSICS == RMHD
439a351,354
> #endif
> #if PHYSICS == RMHD || RESISTIVITY != NO
>   int En, Ep, Et;
> #endif
441,444c356,359
<   #if PHYSICS == ADVECTION
<    for (nv = 0; nv < NVAR; nv++) vsign[nv] = 1.0;
<    return;
<   #endif
---
> #if PHYSICS == ADVECTION
>   for (nv = 0; nv < NVAR; nv++) vsign[nv] = 1.0;
>   return;
> #endif
454c369
<      Bn = BX1; Bp = BX2; Bt = BX3;
---
>     Bn = BX1; Bp = BX2; Bt = BX3;
455a371,373
>     #if PHYSICS == RMHD && RESISTIVITY != NO
>     En = EX1; Ep = EX2; Et = EX3;
>     #endif 
459c377
<      Bn = BX2; Bp = BX1; Bt = BX3;
---
>     Bn = BX2; Bp = BX1; Bt = BX3;
460a379,381
>     #if PHYSICS == RMHD && RESISTIVITY != NO
>     En = EX2; Ep = EX1; Et = EX3;
>     #endif 
464c385
<      Bn = BX3; Bp = BX1; Bt = BX2;
---
>     Bn = BX3; Bp = BX1; Bt = BX2;
465a387,389
>     #if PHYSICS == RMHD && RESISTIVITY != NO
>     En = EX3; Ep = EX1; Et = EX2;
>     #endif 
476,485c400
<    vsign[Bn] = -1.0;
<   #endif
< 
<   #if COMPONENTS == 3
<    if (type == AXISYMMETRIC){
<      vsign[Vt] = -1.0;
<      #if PHYSICS == MHD || PHYSICS == RMHD
<       vsign[Bt] = -1.0;
<      #endif
<    }
---
>   vsign[Bn] = -1.0;
486a402,421
>   
>   if (type == REFLECTIVE){
>     #if PHYSICS == RMHD && RESISTIVITY != NO
>     vsign[Ep] = -1.0;
>     vsign[Et] = -1.0;
>     #endif 
>   }  
> 
> #if COMPONENTS == 3
>   if (type == AXISYMMETRIC){
>     vsign[Vt] = -1.0;
>     #if PHYSICS == MHD || PHYSICS == RMHD
>     vsign[Bt] = -1.0;
>     #endif
>     #if PHYSICS == RMHD && RESISTIVITY != NO
>     vsign[En] = -1.0;
>     vsign[Et] = -1.0;
>     #endif 
>   }
> #endif
488,497c423,435
<   #if PHYSICS == MHD || PHYSICS == RMHD
<    if (type == EQTSYMMETRIC){
<      EXPAND(vsign[Bn] =  1.0; ,
<             vsign[Bp] = -1.0; ,
<             vsign[Bt] = -1.0;)
<      #ifdef GLM_MHD 
<       vsign[PSI_GLM] = -1.0;
<      #endif
<    }
<   #endif
---
>   if (type == EQTSYMMETRIC){
>     #if PHYSICS == MHD || PHYSICS == RMHD
>     EXPAND(vsign[Bn] =  1.0; ,
>            vsign[Bp] = -1.0; ,
>            vsign[Bt] = -1.0;)
>     #ifdef GLM_MHD 
>     vsign[PSI_GLM] = -1.0;
>     #endif
>     #if PHYSICS == RMHD && RESISTIVITY != NO
>     vsign[En] = -1.0;
>     #endif 
>     #endif
>   }
501,505c439,444
< void ReflectiveBound (double ***q, int s, int side, int vpos)
< /*!
<  * Make symmetric (s = 1) or anti-symmetric (s=-1) profiles 
<  * with respect to the boundary plane specified by box->side.
<  * The sign is set by the FlipSign() function. 
---
> void OutflowBound (double ***q, RBox *box, int side)
> /*! 
>  * Impose zero-gradient boundary conditions on 'q' on 
>  * the boundary side specified by 'side'.
>  * The input array 'q' must not represent the normal component
>  * of a staggered magnetic fied.
507,511c446,449
<  * \param [in,out] q   a 3D flow quantity
<  * \param [in] box pointer to box structure
<  * \param [in] s   an integer taking only the values +1 (symmetric 
<  *                 profile) or -1 (antisymmetric profile)
<  *   
---
>  * \param [in,out] q     a 3D array requiring ghost zone filling
>  * \param [in]     box   pointer to a RBox structure defining the
>  *                       extent of the boundary region
>  * \param [in]     side  the side of the computational domain.
514,515c452
<   int   i, j, k;
<   RBox *box = GetRBox(side, vpos);
---
>   int  i, j, k;
517c454
<   if (side == X1_BEG) {   
---
>   if (side == X1_BEG) { 
519,523c456
<     if (box->vpos != X1FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][j][2*IBEG-i-1];
<     }else{
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][j][2*IBEG-i-2];
<     }
---
>     BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][j][IBEG];   
525c458
<   }else if (side == X1_END){  
---
>   }else if (side == X1_END){
527,531c460
<     if (box->vpos != X1FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][j][2*IEND-i+1];
<     }else{
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][j][2*IEND-i];
<     }
---
>     BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][j][IEND];   
533c462
<   }else if (side == X2_BEG){  
---
>   }else if (side == X2_BEG){
535,539c464
<     if (box->vpos != X2FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][2*JBEG-j-1][i];
<     }else{
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][2*JBEG-j-2][i];
<     }
---
>     BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][JBEG][i];
543,547c468,469
<     if (box->vpos != X2FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][2*JEND-j+1][i];
<     }else{
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][2*JEND-j][i];
<     }
---
>     BOX_LOOP(box,k,j,i) q[k][j][i] = q[k][JEND][i];
> 
550,554c472
<     if (box->vpos != X3FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[2*KBEG-k-1][j][i];
<     }else{
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[2*KBEG-k-2][j][i];
<     }
---
>     BOX_LOOP(box,k,j,i) q[k][j][i] = q[KBEG][j][i];
558,562c476
<     if (box->vpos != X3FACE){
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[2*KEND-k+1][j][i];
<     }else{
<       BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[2*KEND-k][j][i];
<     }
---
>     BOX_LOOP(box,k,j,i) q[k][j][i] = q[KEND][j][i];
568c482
< void PeriodicBound (double ***q, int side, int vpos)
---
> void PeriodicBound (double ***q, RBox *box, int side)
570c484,485
<  * Implements periodic boundary conditions in serial mode.
---
>  * Implements periodic boundary conditions in serial mode or when 
>  * one processor only handle the periodic direction.
571a487,490
>  * \param [in,out] q     a 3D array requiring ghost zone filling
>  * \param [in]     box   pointer to a RBox structure defining the
>  *                       extent of the boundary region
>  * \param [in]     side  the side of the computational domain.
575d493
<   RBox *box = GetRBox(side, vpos);
584c502
<     
---
> 
603a522,565
> /* ********************************************************************* */
> void ReflectiveBound (double ***q, int s, RBox *box, int side)
> /*!
>  * Make symmetric (s = 1) or anti-symmetric (s=-1) profiles 
>  * with respect to the boundary plane specified by box->side.
>  * The sign is set by the FlipSign() function. 
>  *
>  * \param [in,out] q     a 3D array requiring ghost zone filling
>  * \param [in]     s     an integer taking only the values +1 (symmetric 
>  *                       profile) or -1 (antisymmetric profile)
>  * \param [in]     box   pointer to a RBox structure defining the
>  *                       extent of the boundary region
>  * \param [in]     side  the side of the computational domain.
>  *********************************************************************** */
> {
>   int   i, j, k;
> 
>   if (side == X1_BEG) {   
> 
>     BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][j][2*IBEG-i-1];
> 
>   }else if (side == X1_END){  
> 
>     BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][j][2*IEND-i+1];
> 
>   }else if (side == X2_BEG){  
> 
>     BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][2*JBEG-j-1][i];
> 
>   }else if (side == X2_END){
> 
>     BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[k][2*JEND-j+1][i];
> 
>   }else if (side == X3_BEG){
> 
>     BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[2*KBEG-k-1][j][i];
> 
>   }else if (side == X3_END){
> 
>     BOX_LOOP(box,k,j,i) q[k][j][i] = s*q[2*KEND-k+1][j][i];
> 
>   }
> }
> 
diff Src/check_states.c ../old/check_states.c
0a1,14
> /* ///////////////////////////////////////////////////////////////////// */
> /*! 
>   \file  
>   \brief Check if primitive states are physically admissible.
> 
>   This function is called at the end of the Hancock or Characteristic
>   Tracing functions to verify that the L/R states at the half-step
>   are physically admissible.
>   
>   \authors A. Mignone (mignone@ph.unito.it)
> 
>   \date   Sept 7, 2015
> */
> /* ///////////////////////////////////////////////////////////////////// */
5,11c19
< /*
<  *
<  *  PURPOSE
<  *
<  *   check if primitive states vL and vR are physically
<  *   admissible. 
<  *   Replace their value with v0 otherwise.
---
> /*!
29c37
<   /*  ----  Prevent unphysical states by revertin to first
---
>   /*  ----  Prevent unphysical states by reverting to first
32,34c40,42
<     #if HAVE_ENERGY
<      switch_to_1st = (ap[PRS] < 0.0) || (am[PRS] < 0.0) ;
<     #endif
---
> #if HAVE_ENERGY
>     switch_to_1st = (ap[PRS] < 0.0) || (am[PRS] < 0.0) ;
> #endif
41c49
<     #if RECONSTRUCT_4VEL == NO    
---
>     #if RECONSTRUCT_4VEL == NO
46c54
<     #endif  
---
>     #endif
50,56c58
< /*
<       WARNING (
<         print (" ! CheckPrimStates: Unphysical state, ");
<         Where (i,NULL);
<       )
< */              
<       #ifdef STAGGERED_MHD 
---
> #ifdef STAGGERED_MHD 
59c61
<       #endif
---
> #endif
61,63c63
<       for (nv = 0; nv < NVAR; nv++){
<         am[nv] = ap[nv] = ac[nv];
<       }
---
>       NVAR_LOOP(nv) am[nv] = ap[nv] = ac[nv];
65c65
<       #ifdef STAGGERED_MHD
---
> #ifdef STAGGERED_MHD
68c68
<       #endif
---
> #endif
diff Src/cmd_line_opt.c ../old/cmd_line_opt.c
10c10
<   \date    July 17, 2013
---
>   \date    March 16, 2018
41c41
<   cmd->maxsteps  = 0 ;
---
>   cmd->maxsteps  = -1;
45d44
<   cmd->show_dec  = NO;
106c105
<         if (cmd->maxsteps == 0) {
---
>         if (cmd->maxsteps < 0) {
108,109c107,108
<             printf ("! You must specify -maxsteps nn, with nn > 0 \n");
<           QUIT_PLUTO(0);
---
>             printf ("! You must specify -maxsteps nn, with nn >= 0 \n");
>             QUIT_PLUTO(0);
129,132d127
<     } else if (!strcmp(argv[i],"-show-dec")) {
< 
<       cmd->show_dec = YES;
< 
diff Src/cooling_ode_solver.c ../old/cooling_ode_solver.c
59c59
<     FOR_EACH(nv,0,vars) v1[nv] = v0[nv] + dt*b21*k1[nv];
---
>     FOR_EACH(nv,vars) v1[nv] = v0[nv] + dt*b21*k1[nv];
64c64
<     FOR_EACH(nv,0,vars) v1[nv] = v0[nv] + dt*(b31*k1[nv] + b32*k2[nv]);
---
>     FOR_EACH(nv,vars) v1[nv] = v0[nv] + dt*(b31*k1[nv] + b32*k2[nv]);
69c69
<     FOR_EACH(nv, 0, vars){
---
>     FOR_EACH(nv,vars){
76c76
<     FOR_EACH(nv,0, vars) {
---
>     FOR_EACH(nv,vars) {
84c84
<     FOR_EACH(nv,0,vars){
---
>     FOR_EACH(nv,vars){
95c95
<     FOR_EACH(nv,0,vars){
---
>     FOR_EACH(nv,vars){
102c102
<     FOR_EACH(nv,0,vars){
---
>     FOR_EACH(nv,vars){
123c123
<     FOR_EACH(nv,0,vars){
---
>     FOR_EACH(nv,vars){
153c153
<       FOR_EACH(nv,0,vars) v0[nv] = v5th[nv];
---
>       FOR_EACH(nv,vars) v0[nv] = v5th[nv];
171,172c171
<     int i;
<     print ("! SolveODE_CK45: number of substeps is %d\n", ksub);
---
> //    print ("! SolveODE_CK45: number of substeps is %d\n", ksub);
203c202
<   FOR_EACH(nv,0,var_list) v1[nv] = v0[nv] + 0.5*dt*k1[nv];
---
>   FOR_EACH(nv,var_list) v1[nv] = v0[nv] + 0.5*dt*k1[nv];
208c207
<   FOR_EACH(nv,0,var_list) v1[nv] = v0[nv] + 0.5*dt*k2[nv];
---
>   FOR_EACH(nv,var_list) v1[nv] = v0[nv] + 0.5*dt*k2[nv];
213c212
<   FOR_EACH(nv,0,var_list) v1[nv] = v0[nv] + 0.5*dt*k3[nv];
---
>   FOR_EACH(nv,var_list) v1[nv] = v0[nv] + 0.5*dt*k3[nv];
218c217
<   FOR_EACH(nv,0,var_list) {
---
>   FOR_EACH(nv,var_list) {
248c247
<   FOR_EACH(nv, 0, vars)  v1[nv] = v0[nv] + 0.5*dt*k1[nv];
---
>   FOR_EACH(nv,vars)  v1[nv] = v0[nv] + 0.5*dt*k1[nv];
254c253
<   FOR_EACH(nv, 0, vars) v2nd[nv] = v0[nv] + dt*k2[nv];
---
>   FOR_EACH(nv,vars) v2nd[nv] = v0[nv] + dt*k2[nv];
258c257
<   FOR_EACH(nv, 0, vars) v1st[nv] = v0[nv] + dt*k1[nv];
---
>   FOR_EACH(nv,vars) v1st[nv] = v0[nv] + dt*k1[nv];
270c269
<   FOR_EACH(nv,0,vars){
---
>   FOR_EACH(nv,vars){
313c312
<   FOR_EACH(nv,0,vars) v1[nv] = v0[nv] + dt*k1[nv]; 
---
>   FOR_EACH(nv,vars) v1[nv] = v0[nv] + dt*k1[nv]; 
319c318
<   FOR_EACH(nv,0,vars) v1[nv] = v0[nv] + dt_4*(k1[nv] + k2[nv]);
---
>   FOR_EACH(nv,vars) v1[nv] = v0[nv] + dt_4*(k1[nv] + k2[nv]);
325c324
<   FOR_EACH(nv,0,vars) v3rd[nv] = v0[nv] + dt_6*(k1[nv] + k2[nv] + 4.0*k3[nv]);
---
>   FOR_EACH(nv,vars) v3rd[nv] = v0[nv] + dt_6*(k1[nv] + k2[nv] + 4.0*k3[nv]);
329c328
<   FOR_EACH(nv,0,vars) v2nd[nv] = v0[nv] + 0.5*dt*(k1[nv] + k2[nv]);
---
>   FOR_EACH(nv,vars) v2nd[nv] = v0[nv] + 0.5*dt*(k1[nv] + k2[nv]);
341c340
<   FOR_EACH(nv,0,vars){
---
>   FOR_EACH(nv,vars){
617d615
< 
diff Src/cooling_source.c ../old/cooling_source.c
38c38
< void CoolingSource (const Data *d, double dt, Time_Step *Dts, Grid *GXYZ)
---
> void CoolingSource (const Data *d, double dt, timeStep *Dts, Grid *GXYZ)
44c44
<  * \param [out]    Dts  pointer to the Time_Step structure
---
>  * \param [out]    Dts  pointer to the timeStep structure
59d58
<   printf("BLah - got to cooling source\n");
84c83
<      if (d->flag[k][j][i] & FLAG_INTERNAL_BOUNDARY) continue;
---
>     if (d->flag[k][j][i] & FLAG_INTERNAL_BOUNDARY) continue;
98c97
<      v0[RHOE] = v1[RHOE] = prs/(g_gamma-1.0);
---
>     v0[RHOE] = v1[RHOE] = prs/(g_gamma-1.0);
100c99
<      v1[RHOE] = v0[RHOE] = InternalEnergy(v0, T0);
---
>     v1[RHOE] = v0[RHOE] = InternalEnergy(v0, T0);
diff Src/doxy-comment.c ../old/doxy-comment.c
39c39
<  * \param [in]      state pointer to State_1D structure
---
>  * \param [in]      sweep pointer to Sweep structure
diff Src/entropy_switch.c ../old/entropy_switch.c
96c96
<       print1 ("! EntropyOhmicHeating: only CT supported in this geometry.\n")
---
>       print ("! EntropyOhmicHeating: only CT supported in this geometry.\n")
diff Src/fd_flux.c ../old/fd_flux.c
17c17
<   \date   April 02, 2015
---
>   \date    Fen 28, 2017
23,24c23,24
< void FD_Flux (const State_1D *state, int beg, int end, 
<                double *cmax, Grid *grid)
---
> void FD_Flux (const Sweep *sweep, int beg, int end, 
>               double *cmax, Grid *grid)
29c29
<  * \param [in]  state   pointer to State_1D structure
---
>  * \param [in]  sweep   pointer to Sweep structure
33c33
<  * \param [in]    grid  pointer to an array of Grid structures
---
>  * \param [in]    grid  pointer to Grid structure
44c44
<   int    nv, i, j, k, np_tot;
---
>   int   nv, i, j, k, np_tot;
46c46,58
<   double **v, **flux, *press;
---
> 
>   const State *stateC = &(sweep->stateC);
>   const State *stateL = &(sweep->stateL);
>   const State *stateR = &(sweep->stateR);
>   static State *stateLR;
> 
>   double **v = stateC->v;
>   double **u = stateC->u;
>   double **F = stateC->flux;
>   double  *p = stateC->prs;
>   double **Uave, **Vave;
> 
>   double **flux, *press;
49,50c61,62
<   static double *Fp, *Fm, **F, *a2, **u;
<   static double **Uave, **Vave, **lp;
---
>   static double *Fp, *Fm;
>   static double *psim, *Bm, **lp;
52d63
<   static double *psim, *Bm; 
55,78c66,89
< /* ------------------------------------------------------------------
<            Check compatibility with other modules 
<    ------------------------------------------------------------------ */
< 
<   #if TIME_STEPPING != RK3 && TIME_STEPPING != SSP_RK4
<    print1 ("! Finite Difference schemes work with RK3 only \n");
<    QUIT_PLUTO(1);
<   #endif
<   #if GEOMETRY != CARTESIAN
<    print1 ("! Finite Difference schemes work in Cartesian coordinates only\n");
<    QUIT_PLUTO(1);
<   #endif
<   #if PHYSICS == RMHD || PHYSICS == RHD
<    print1 ("! Finite difference schemes work only for HD od MHD modules\n");
<    QUIT_PLUTO(1);
<   #endif   
<   #ifdef STAGGERED_MHD
<    print1 ("! Finite difference schemes work only with cell-centered schemes\n");
<    QUIT_PLUTO(1);
<   #endif   
<   #if PHYSICS == MHD && BACKGROUND_FIELD == YES
<    print1 ("! Background field splitting not supported with FD schemes\n");
<    QUIT_PLUTO(1);
<   #endif  
---
> /* -----------------------------------------------
>    0. Check compatibility with other modules 
>    ----------------------------------------------- */
> 
> #if TIME_STEPPING != RK3 && TIME_STEPPING != SSP_RK4
>   print ("! Finite Difference schemes work with RK3 only \n");
>   QUIT_PLUTO(1);
> #endif
> #if GEOMETRY != CARTESIAN
>   print ("! Finite Difference schemes work in Cartesian coordinates only\n");
>   QUIT_PLUTO(1);
> #endif
> #if PHYSICS == RMHD || PHYSICS == RHD
>   print ("! Finite difference schemes work only for HD od MHD modules\n");
>   QUIT_PLUTO(1);
> #endif   
> #ifdef STAGGERED_MHD
>   print ("! Finite difference schemes work only with cell-centered schemes\n");
>   QUIT_PLUTO(1);
> #endif   
> #if PHYSICS == MHD && BACKGROUND_FIELD == YES
>   print ("! Background field splitting not supported with FD schemes\n");
>   QUIT_PLUTO(1);
> #endif  
81,83c92,94
<      - Define pointer to reconstruction function
<      - Determine the stencil for interpolation
<        For a given S, the stencil is: i-S <= i <= i+S+1
---
>    1. Define pointer to reconstruction function and 
>       compute the stencil for interpolation.
>       For given S, the stencil is: i-S <= i <= i+S+1
86,99c97,110
<   dx = grid[g_dir].dx[beg];
<   #if RECONSTRUCTION == WENO3_FD
<    REC = WENO3_Reconstruct;
<    S   = 1;
<   #elif RECONSTRUCTION == LIMO3_FD
<    REC = LIMO3_Reconstruct;
<    S   = 1;
<   #elif RECONSTRUCTION == WENOZ_FD
<    REC = WENOZ_Reconstruct;
<    S   = 2;
<   #elif RECONSTRUCTION == MP5_FD
<    REC = MP5_Reconstruct;
<    S   = 2;
<   #endif
---
>   dx = grid->dx[g_dir][beg];
> #if RECONSTRUCTION == WENO3_FD
>   REC = WENO3_Reconstruct;
>   S   = 1;
> #elif RECONSTRUCTION == LIMO3_FD
>   REC = LIMO3_Reconstruct;
>   S   = 1;
> #elif RECONSTRUCTION == WENOZ_FD
>   REC = WENOZ_Reconstruct;
>   S   = 2;
> #elif RECONSTRUCTION == MP5_FD
>   REC = MP5_Reconstruct;
>   S   = 2;
> #endif
101c112,119
<   if (F == NULL){
---
> /* ----------------------------------------------------
>    2. Allocate memory / set pointer shortcuts
>    ---------------------------------------------------- */
> 
>   if (Fp == NULL){
>     stateLR = malloc(sizeof(struct State_));
>     StateStructAllocate (stateLR);
> 
104d121
<     F    = ARRAY_2D(NMAX_POINT, NVAR, double);
108,111d124
<     a2   = ARRAY_1D(NMAX_POINT, double);
<     Uave = ARRAY_2D(NMAX_POINT, NVAR, double);
<     Vave = ARRAY_2D(NMAX_POINT, NVAR, double);
<     u    = ARRAY_2D(NMAX_POINT, NVAR, double);
114,125c127,140
<   np_tot = grid[g_dir].np_tot;
<   flux   = state->flux;
<   press  = state->press;
<   v      = state->v;
< 
< /* ------------------------------------------------------
<     Compute cell-centered fluxes. Pressure is added to 
<     the normal component of momentum.
<     To save computational time, we also solve the linear 
<     GLM-MHD subsystem here and use the solution in the 
<     nonlinear fluxes later.
<    ------------------------------------------------------ */
---
>   np_tot = grid->np_tot[g_dir];
>   flux   = sweep->flux;
>   press  = sweep->press;
>   Uave   = stateLR->u;
>   Vave   = stateLR->v;
>   memset ((void *)stateLR->Rp[0][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
>   memset ((void *)stateLR->Lp[0][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
> 
> /* ---------------------------------------------------------------------
>    3. Compute cell-centered fluxes. Pressure is added to the normal
>       component of momentum.
>       To save computational time, we also solve the linear GLM-MHD
>       subsystem here and use the solution in the nonlinear fluxes later.
>    --------------------------------------------------------------------- */
128,133c143,144
<   SoundSpeed2 (v, a2, NULL, 0, np_tot-1, CELL_CENTER, grid);
<   #if PHYSICS == MHD
<    Flux (u, v, a2, NULL, F, press, 0, np_tot-1);
<   #else
<    Flux (u, v, a2, F, press, 0, np_tot-1);
<   #endif
---
>   SoundSpeed2 (stateC, 0, np_tot-1, CELL_CENTER, grid);
>   Flux (stateC, 0, np_tot-1);
136,137c147,148
<     F[i][MXn] += press[i];
<     press[i]  = 0.0;
---
>     F[i][MXn] += p[i];
>     p[i]       = press[i] = 0.0;
139c150
<      fs = g_gamma*v[i][PRS]/v[i][RHO];
---
>     fs = g_gamma*v[i][PRS]/v[i][RHO];
141c152
<      fs = g_isoSoundSpeed*g_isoSoundSpeed;
---
>     fs = g_isoSoundSpeed*g_isoSoundSpeed;
146,148c157,159
<      j = np_tot - 1 - i;
<      Fp[i] = 0.5*(u[i][PSI_GLM] + glm_ch*u[i][BXn]);
<      Fm[j] = 0.5*(u[i][PSI_GLM] - glm_ch*u[i][BXn]);
---
>     j = np_tot - 1 - i;
>     Fp[i] = 0.5*(u[i][PSI_GLM] + glm_ch*u[i][BXn]);
>     Fm[j] = 0.5*(u[i][PSI_GLM] - glm_ch*u[i][BXn]);
152,174c163,180
<   #ifdef GLM_MHD
<    for (i = beg; i <= end; i++){
<      fp = REC(Fp, dx, i); 
<      fm = REC(Fm, dx, np_tot - i - 2); 
<      #if SHOCK_FLATTENING == MULTID
<       if (state->flag[i] & FLAG_MINMOD){
<         fp = WENO3_Reconstruct(Fp, dx, i);
<         fm = WENO3_Reconstruct(Fm, dx, np_tot - i - 2); 
<       }
<      #endif
<      Bm[i]   = (fp - fm)/glm_ch;
<      psim[i] =  fp + fm;
<      #if COMPUTE_DIVB == YES
<       state->bn[i] = Bm[i];
<      #endif
<    }
<    #if COMPUTE_DIVB == YES
<     if (g_intStage == 1) GLM_ComputeDivB(state, grid);
<    #endif
< 
<    Kmax = KPSI_GLMM;
<   #else
<    Kmax = NFLX;
---
> #ifdef GLM_MHD
>   for (i = beg; i <= end; i++){
>     fp = REC(Fp, dx, i); 
>     fm = REC(Fm, dx, np_tot - i - 2); 
>     #if SHOCK_FLATTENING == MULTID
>     if (sweep->flag[i] & FLAG_MINMOD){
>       fp = WENO3_Reconstruct(Fp, dx, i);
>       fm = WENO3_Reconstruct(Fm, dx, np_tot - i - 2); 
>     }
>     #endif
>     Bm[i]   = (fp - fm)/glm_ch;
>     psim[i] =  fp + fm;
>     #if GLM_COMPUTE_DIVB == YES
>     sweep->bn[i] = Bm[i];
>     #endif
>   }
>   #if GLM_COMPUTE_DIVB == YES
>   if (g_intStage == 1) GLM_ComputeDivB(sweep, grid);
176a183,187
>   Kmax = KPSI_GLMM;
> #else
>   Kmax = NFLX;
> #endif 
> 
178c189
<               Compute average state
---
>    4. Compute average state
183,184c194,195
<       Uave[i][nv] = 0.5*(u[i][nv] + u[i + 1][nv]);
<       Vave[i][nv] = 0.5*(v[i][nv] + v[i + 1][nv]);
---
>       Uave[i][nv] = 0.5*(u[i][nv] + u[i+1][nv]);
>       Vave[i][nv] = 0.5*(v[i][nv] + v[i+1][nv]);
186d196
< 
188,189c198,199
<      Uave[i][BXn]      = Vave[i][BXn]      = Bm[i];
<      Uave[i][PSI_GLM] = Vave[i][PSI_GLM] = psim[i];
---
>     Uave[i][BXn]     = Vave[i][BXn]     = Bm[i];
>     Uave[i][PSI_GLM] = Vave[i][PSI_GLM] = psim[i];
194c204
<      compute sound speed
---
>    5. Compute sound speed
197c207
<   SoundSpeed2 (Vave, a2, NULL, beg, end, FACE_CENTER, grid);
---
>   SoundSpeed2 (stateLR, beg, end, FACE_CENTER, grid);
200c210
<          Compute eigenvectors and eigenvalues
---
>    6. Compute eigenvectors and eigenvalues
204,205c214,215
<     L = state->Lp[i];
<     R = state->Rp[i];
---
>     L = stateLR->Lp[i];
>     R = stateLR->Rp[i];
207c217
<     ConsEigenvectors(Uave[i], Vave[i], a2[i], L, R, lp[i]);
---
>     ConsEigenvectors(Uave[i], Vave[i], stateLR->a2[i], L, R, lp[i]);
211c221
<       fs = MAX(fs, fabs(state->lmax[k]));
---
>       fs = MAX(fs, fabs(sweep->lmax[k]));
218,220c228,230
<     Main spatial loop.
<     At each interface construct, for each characteristic 
<     field k, the positive and negative part of the flux:
---
>    6. Main spatial loop.
>       At each interface construct, for each characteristic 
>       field k, the positive and negative part of the flux:
222,223c232,233
<       F_{+,j} = 1/2 L.[F(j)  + a*u(j)]
<       F_{-,j} = 1/2 L.[F(j') - a*u(j')]
---
>         F_{+,j} = 1/2 L.[F(j)  + a*u(j)]
>         F_{-,j} = 1/2 L.[F(j') - a*u(j')]
225,227c235,237
<     a is the global maximum eigenvalue for the k-th 
<     characteristic.
<     Reconstruct F_{+,j} and F_{-,j}.
---
>       a is the global maximum eigenvalue for the k-th 
>       characteristic.
>       Reconstruct F_{+,j} and F_{-,j}.
231,233c241,242
<     L = state->Lp[i];
<     R = state->Rp[i];
< 
---
>     L = stateLR->Lp[i];
>     R = stateLR->Rp[i];
235c244
<       fs = state->lmax[k];
---
>       fs = sweep->lmax[k];
244,246c253,255
<        if ( (state->flag[i] & FLAG_MINMOD) || (state->flag[i+1] & FLAG_MINMOD)){
<          fs = LIN_Reconstruct(Fp, dx, i) + LIN_Reconstruct(Fm, dx, i); 
<        }else
---
>       if ( (sweep->flag[i] & FLAG_MINMOD) || (sweep->flag[i+1] & FLAG_MINMOD)){
>         fs = LIN_Reconstruct(Fp, dx, i) + LIN_Reconstruct(Fm, dx, i); 
>       }else
258,259c267,268
<      flux[i][BXn]      = psim[i];
<      flux[i][PSI_GLM] = glm_ch*glm_ch*Bm[i];
---
>     flux[i][BXn]     = psim[i];
>     flux[i][PSI_GLM] = glm_ch*glm_ch*Bm[i];
274c283
< #if NSCL > 0 
---
>     #if NSCL > 0 
278,279c287,288
<         state->vL[i][k] = REC(Fp, dx, i);
<         state->vR[i][k] = v[i+1][k];
---
>         stateL->v[i][k] = REC(Fp, dx, i);
>         stateR->v[i][k] = v[i+1][k];
284,285c293,294
<         state->vL[i][k] = v[i][k];
<         state->vR[i][k] = REC(Fm, dx, i);
---
>         stateL->v[i][k] = v[i][k];
>         stateR->v[i][k] = REC(Fm, dx, i);
288,289c297,298
< #endif
<   }
---
>     #endif
>   }  /* End loop on i=beg,end */
293c302
< void FD_GetMaxEigenvalues (const Data *d, State_1D *state, Grid *grid)
---
> void FD_GetMaxEigenvalues (const Data *d, Sweep *sweep, Grid *grid)
305a315
>   State state;
313,317c323
<   for (nv = NVAR; nv--;  ) state->lmax[nv] = 0.0;
< 
<   x1 = grid[IDIR].x;
<   x2 = grid[JDIR].x;
<   x3 = grid[KDIR].x;
---
>   NVAR_LOOP(nv) sweep->lmax[nv] = 0.0;
318a325,331
>   x1 = grid->x[IDIR];
>   x2 = grid->x[JDIR];
>   x3 = grid->x[KDIR];
> 
>   state.v = v;
>   state.lambda = lambda;
>   state.a2 = a2;
320,321c333,334
<     IDOM_LOOP(i) for (nv = NVAR; nv--;  ) v[i][nv] = d->Vc[nv][k][j][i];
<     SoundSpeed2  (v, a2, NULL, IBEG, IEND, CELL_CENTER, grid);
---
>     IDOM_LOOP(i) NVAR_LOOP(nv) v[i][nv] = d->Vc[nv][k][j][i];
>     SoundSpeed2  (&state, IBEG, IEND, CELL_CENTER, grid);
325c338
<         state->lmax[nv] = MAX(fabs(lambda[i][nv]), state->lmax[nv]);
---
>         sweep->lmax[nv] = MAX(fabs(lambda[i][nv]), sweep->lmax[nv]);
330,331c343,344
<    MPI_Allreduce (state->lmax, lambda[0], NFLX, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<    for (nv = 0; nv < NFLX; nv++) state->lmax[nv] = lambda[0][nv];
---
>    MPI_Allreduce (sweep->lmax, lambda[0], NFLX, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
>    for (nv = 0; nv < NFLX; nv++) sweep->lmax[nv] = lambda[0][nv];
diff Src/flag_shock.c ../old/flag_shock.c
64c64
<   \date    July 28, 2015
---
>   \date    March 1, 2017
81c81,82
<  *
---
>  * \param [in,out] d     pointer to data structure
>  * \param [in]     grid  pointer to grid structure
88,93c89,103
<   double dpx1, *dx1, *dV1, ***vx1, pt_min1, dvx1;
<   double dpx2, *dx2, *dV2, ***vx2, pt_min2, dvx2;
<   double dpx3, *dx3, *dV3, ***vx3, pt_min3, dvx3;
<   
<   double *dVx, *dVy, *dVz;
<   double *Ar, *Ath, *r, *th, s;
---
>   double dpx1, pt_min1, dvx1;
>   double dpx2, pt_min2, dvx2;
>   double dpx3, pt_min3, dvx3;
>   EXPAND(double ***vx1 = d->Vc[VX1];  ,
>          double ***vx2 = d->Vc[VX2];  ,
>          double ***vx3 = d->Vc[VX3];)
> 
>   double *dx1 = grid->dx[IDIR];
>   double *dx2 = grid->dx[JDIR];
>   double *dx3 = grid->dx[KDIR];
> 
>   double ***Ax1 = grid->A[IDIR];
>   double ***Ax2 = grid->A[JDIR];
>   double ***Ax3 = grid->A[KDIR];
> 
97c107
<    0. Define pointers to variables and allocate memory
---
>    0. Allocate memory
100,112d109
<   dx1 = grid[IDIR].dx; dV1 = grid[IDIR].dV;
<   dx2 = grid[JDIR].dx; dV2 = grid[JDIR].dV; 
<   dx3 = grid[KDIR].dx; dV3 = grid[KDIR].dV; 
<   
<   Ar  = grid[IDIR].A;
<   r   = grid[IDIR].x;
<   Ath = grid[JDIR].A;
<   th  = grid[JDIR].x;
< 
<   EXPAND(vx1 = d->Vc[VX1];  ,
<          vx2 = d->Vc[VX2];  ,
<          vx3 = d->Vc[VX3];)
< 
121c118
< #if EOS == ISOTHERMAL
---
>     #if EOS == ISOTHERMAL
123,127c120,124
< #else
<   #if HAVE_ENERGY 
<      pt[k][j][i] = d->Vc[PRS][k][j][i];
<   #endif    
< #endif
---
>     #else
>     #if HAVE_ENERGY 
>     pt[k][j][i] = d->Vc[PRS][k][j][i];
>     #endif    
>     #endif
129c126
< #if (ENTROPY_SWITCH == SELECTIVE) || (ENTROPY_SWITCH == ALWAYS)
---
>     #if (ENTROPY_SWITCH == SELECTIVE) || (ENTROPY_SWITCH == ALWAYS)
131c128
< #endif
---
>     #endif
146,171c143,145
<      D_EXPAND(dvx1 = vx1[k][j][i + 1] - vx1[k][j][i - 1];   ,
<               dvx2 = vx2[k][j + 1][i] - vx2[k][j - 1][i];   ,
<               dvx3 = vx3[k + 1][j][i] - vx3[k - 1][j][i];)
< 
<     #elif GEOMETRY == CYLINDRICAL
< 
<      D_EXPAND(dvx1 =   Ar[i]  *(vx1[k][j][i + 1] + vx1[k][j][i])
<                      - Ar[i-1]*(vx1[k][j][i - 1] + vx1[k][j][i]);   ,
<               dvx2 = vx2[k][j + 1][i] - vx2[k][j - 1][i];           , 
<               dvx3 = vx3[k + 1][j][i] - vx3[k - 1][j][i];)
< 
<     #elif GEOMETRY == POLAR
< 
<      D_EXPAND(dvx1 =  Ar[i]  *(vx1[k][j][i + 1] + vx1[k][j][i])
<                     - Ar[i-1]*(vx1[k][j][i - 1] + vx1[k][j][i]);  ,
<               dvx2 = (vx2[k][j + 1][i] - vx2[k][j - 1][i])/r[i];      ,
<               dvx3 =  vx3[k + 1][j][i] - vx3[k - 1][j][i];)
< 
<     #elif GEOMETRY == SPHERICAL
< 
<      D_EXPAND(dvx1 =  Ar[i]  *(vx1[k][j][i + 1] + vx1[k][j][i])
<                     - Ar[i-1]*(vx1[k][j][i - 1] + vx1[k][j][i]);               ,
<               dvx2 = (  Ath[j] *(vx2[k][j + 1][i] + vx2[k][j][i])
<                      - Ath[j-1]*(vx2[k][j - 1][i] + vx2[k][j][i]))/fabs(r[i]); ,
<               s    = th[j];
<               dvx3 = (vx3[k + 1][j][i] - vx3[k - 1][j][i])/(r[i]*sin(s));)
---
>     D_EXPAND(dvx1 = (vx1[k][j][i+1] - vx1[k][j][i-1])/dx1[i];   ,
>              dvx2 = (vx2[k][j+1][i] - vx2[k][j-1][i])/dx2[j];   ,
>              dvx3 = (vx3[k+1][j][i] - vx3[k-1][j][i])/dx3[k];)
172a147,167
>     divv = D_EXPAND(dvx1, + dvx2, + dvx3);
>     #else 
>     
>     D_EXPAND(dvx1 =   Ax1[k][j][i]*  (vx1[k][j][i+1] + vx1[k][j][i])
>                     - Ax1[k][j][i-1]*(vx1[k][j][i-1] + vx1[k][j][i]);  ,
> 
>              dvx2 =   Ax2[k][j][i]*  (vx2[k][j+1][i] + vx2[k][j][i])
>                     - Ax2[k][j-1][i]*(vx2[k][j-1][i] + vx2[k][j][i]);  ,
> 
>              dvx3 =   Ax3[k][j][i]*  (vx3[k+1][j][i] + vx3[k][j][i])
>                     - Ax3[k-1][j][i]*(vx3[k-1][j][i] + vx3[k][j][i]))
> 
> /*
> double dvz1 = dvx2/grid->dV[k][j][i];
> double dvz2 = (vx2[k][j+1][i] - vx2[k][j-1][i])/dx2[j];
> if (fabs(dvz1-dvz2) > 1.e-10){
>   print ("!!\n");
>   QUIT_PLUTO(1);
> }
> */
>     divv = (D_EXPAND(dvx1, + dvx2, + dvx3))/grid->dV[k][j][i];
175d169
<     divv = D_EXPAND(dvx1/dV1[i], + dvx2/dV2[j], + dvx3/dV3[k]);
200,201c194,195
<        if (gradp > EPS_PSHOCK_FLATTEN*pt_min) {
<          d->flag[k][j][i]   |= FLAG_HLL;
---
>       if (gradp > EPS_PSHOCK_FLATTEN*pt_min) {
>         d->flag[k][j][i]   |= FLAG_HLL;
203,211c197,205
<          d->flag[k][j][i]   |= FLAG_MINMOD;
<          D_EXPAND(
<            d->flag[k][j][i+1] |= FLAG_MINMOD;
<            d->flag[k][j][i-1] |= FLAG_MINMOD;  ,
<            d->flag[k][j-1][i] |= FLAG_MINMOD;  
<            d->flag[k][j+1][i] |= FLAG_MINMOD;  ,
<            d->flag[k-1][j][i] |= FLAG_MINMOD;
<            d->flag[k+1][j][i] |= FLAG_MINMOD;)
<        }
---
>         d->flag[k][j][i]   |= FLAG_MINMOD;
>         D_EXPAND(
>           d->flag[k][j][i+1] |= FLAG_MINMOD;
>           d->flag[k][j][i-1] |= FLAG_MINMOD;  ,
>           d->flag[k][j-1][i] |= FLAG_MINMOD;  
>           d->flag[k][j+1][i] |= FLAG_MINMOD;  ,
>           d->flag[k-1][j][i] |= FLAG_MINMOD;
>           d->flag[k+1][j][i] |= FLAG_MINMOD;)
>       }
214,218c208,212
<   /* -----------------------------------------------------
<       When using entropy, we unflag those zones lying in 
<       a shock as well as one neighbour cells to the left
<       and to the right for each dimension.
<      ----------------------------------------------------- */
---
>     /* -----------------------------------------------------
>         When using entropy, we unflag those zones lying in 
>         a shock as well as one neighbour cells to the left
>         and to the right for each dimension.
>        ----------------------------------------------------- */
221,231c215,225
<        if (gradp > EPS_PSHOCK_ENTROPY*pt_min) { /* -- unflag zone -- */
<          d->flag[k][j][i] &= ~(FLAG_ENTROPY);
<          D_EXPAND(
<            d->flag[k][j][i-1] &= ~(FLAG_ENTROPY);
<            d->flag[k][j][i+1] &= ~(FLAG_ENTROPY); ,
<            d->flag[k][j+1][i] &= ~(FLAG_ENTROPY);
<            d->flag[k][j-1][i] &= ~(FLAG_ENTROPY); ,
<            d->flag[k+1][j][i] &= ~(FLAG_ENTROPY);
<            d->flag[k-1][j][i] &= ~(FLAG_ENTROPY);
<          )
<        }
---
>       if (gradp > EPS_PSHOCK_ENTROPY*pt_min) { /* -- unflag zone -- */
>         d->flag[k][j][i] &= ~(FLAG_ENTROPY);
>         D_EXPAND(
>           d->flag[k][j][i-1] &= ~(FLAG_ENTROPY);
>           d->flag[k][j][i+1] &= ~(FLAG_ENTROPY); ,
>           d->flag[k][j+1][i] &= ~(FLAG_ENTROPY);
>           d->flag[k][j-1][i] &= ~(FLAG_ENTROPY); ,
>           d->flag[k+1][j][i] &= ~(FLAG_ENTROPY);
>           d->flag[k-1][j][i] &= ~(FLAG_ENTROPY);
>         )
>       }
233c227
<     } 
---
>     } /* end if (divV < 0) */
237,239c231,233
<   #ifdef PARALLEL
<    AL_Exchange (d->flag[0][0], SZ_char);
<   #endif
---
> #ifdef PARALLEL
>   AL_Exchange (d->flag[0][0], SZ_char);
> #endif
diff Src/get_nghost.c ../old/get_nghost.c
102,105d101
<   #if (defined CH_SPACEDIM) && (TIME_STEPPING == RK_MIDPOINT) 
<    nghost++;  /* AMR + RK_MIDPOINT */
<   #endif  
< 
diff Src/globals.h ../old/globals.h
67c67
<     normal ("n"), tangent ("t") and bi-tangent ("b") directions.
---
>     normal ("n"), tangent ("t") and binormal ("b") directions.
76c76,77
< #if DUST == YES
---
> int EXn, EXt, EXb;
> #if DUST_FLUID == YES
93,98c94,99
< int      g_maxRiemannIter;  /**< Maximum number of iterations for 
<                                  iterative Riemann Solver.       */
< int      g_maxRootIter;  /**< Maximum number of iterations for root finder */
< long int g_usedMemory;   /**< Amount of used memory in bytes. */
< long int g_stepNumber;  /**< Gives the current integration step number. */
< int      g_intStage;    /**< Gives the current integration stage of the time
---
> double g_dt;       /**< The current integration time step. */
> 
> int    g_hydroStep = 0;   /**< Tells whether we're in a hydro step (=1)
>                            or SplitSource step (=0)                  */
> 
> int    g_intStage;    /**< Gives the current integration stage of the time
101,103d101
< int      g_operatorStep; /**< Gives the current operator step. 
<                               (HYPERBOLIC_STEP/PARABOLIC_STEP/SOURCE_STEP). */
< 
107a106,111
> 
> int    g_maxIMEXIter;     /**< Maximum number if iterations in IMEX scheme */    
> int    g_maxRiemannIter;  /**< Maximum number of iterations for 
>                                  iterative Riemann Solver.       */
> int    g_maxRootIter;     /**< Maximum number of iterations for root finder */
> int    g_nprocs;          /**< The total number of processors */
117,119c121,124
< double g_time;     /**< The current integration time. */
< double g_dt;       /**< The current integration time step. */
< double g_maxMach;  /**< The maximum Mach number computed during integration. */
---
> long int g_stepNumber;  /**< Gives the current integration step number. */
> double   g_time;        /**< The current integration time. */
> long int g_usedMemory;  /**< Amount of used memory in bytes. */
> double   g_maxMach;     /**< The maximum Mach number computed during integration. */
152a158,175
> #if DEBUG == TRUE
>   int d_indent;        /**< Number of indentation space using during debug printing */
>   int d_condition=1;   /**< Enable/disable printing when a certain cond. is verified */
> #endif
> 
> #ifdef  PARTICLES
>   long int p_nparticles = 0;  /**< Total number of particles on local
>                                     processor domain */
>   long int p_idCounter = 0;     /**< Total number of particle ids created since
>                                       beginning [global] */
> 
>   int p_nrestart   = 0;
>   int p_intStage;
>  #ifdef PARALLEL   
>   MPI_Datatype MPI_PARTICLE;
>   MPI_Datatype PartOutputType;
>  #endif
> #endif	
diff Src/hdf5_io.c ../old/hdf5_io.c
31c31
<   \date    May 22, 2014
---
>   \date   Feb 28, 2017
78c78
<   int  rank, nd, nv, ns, nc, ngh, ii, jj, kk;
---
>   int  rank, nd, nr, nv, ns, nc, ngh, ii, jj, kk;
80d79
<   Grid *wgrid[3];
82c81
<  
---
> 
90,92c89,91
<     n1p = NX1 + (grid[IDIR].rbound != 0);
<     n2p = NX2 + (grid[JDIR].rbound != 0);
<     n3p = NX3 + (grid[KDIR].rbound != 0);
---
>     n1p = NX1 + (grid->rbound[IDIR] != 0);
>     n2p = NX2 + (grid->rbound[JDIR] != 0);
>     n3p = NX3 + (grid->rbound[KDIR] != 0);
97,99c96,98
<     for (kk = 0; kk < n3p; kk++) {  x3 = grid[KDIR].xl[KBEG+kk];
<     for (jj = 0; jj < n2p; jj++) {  x2 = grid[JDIR].xl[JBEG+jj];
<     for (ii = 0; ii < n1p; ii++) {  x1 = grid[IDIR].xl[IBEG+ii];
---
>     for (kk = 0; kk < n3p; kk++) {  x3 = grid->xl[KDIR][KBEG+kk];
>     for (jj = 0; jj < n2p; jj++) {  x2 = grid->xl[JDIR][JBEG+jj];
>     for (ii = 0; ii < n1p; ii++) {  x1 = grid->xl[IDIR][IBEG+ii];
123c122
<        print1 ("! HDF5_IO: Unknown geometry\n");
---
>        print ("! HDF5_IO: Unknown geometry\n");
128,130c127,129
<     for (kk = 0; kk < NX3; kk++) {  x3 = grid[KDIR].x[KBEG+kk];
<     for (jj = 0; jj < NX2; jj++) {  x2 = grid[JDIR].x[JBEG+jj];
<     for (ii = 0; ii < NX1; ii++) {  x1 = grid[IDIR].x[IBEG+ii];
---
>     for (kk = 0; kk < NX3; kk++) {  x3 = grid->x[KDIR][KBEG+kk];
>     for (jj = 0; jj < NX2; jj++) {  x2 = grid->x[JDIR][JBEG+jj];
>     for (ii = 0; ii < NX1; ii++) {  x1 = grid->x[IDIR][IBEG+ii];
154c153
<        print1 ("! HDF5_IO: Unknown geometry\n");
---
>        print ("! HDF5_IO: Unknown geometry\n");
166,167d164
<   for (nd = 0; nd < DIMENSIONS; nd++) wgrid[nd] = grid + DIMENSIONS - nd - 1;
< 
213c210,213
<   for (nd = 0; nd < DIMENSIONS; nd++) dimens[nd] = wgrid[nd]->np_int_glob;
---
>   for (nd = 0; nd < DIMENSIONS; nd++) {
>     nr = DIMENSIONS-nd-1;
>     dimens[nd] = grid->np_int_glob[nr];
>   }
219c219,220
<      start[nd]  = wgrid[nd]->beg - wgrid[nd]->nghost;
---
>      nr = DIMENSIONS-nd-1;
>      start[nd]  = grid->beg[nr] - grid->nghost[nr];
221c222
<      count[nd]  = wgrid[nd]->np_int;
---
>      count[nd]  = grid->np_int[nr];
227c228,231
<   for (nd = 0; nd < DIMENSIONS; nd++) dimens[nd] = wgrid[nd]->np_tot;
---
>   for (nd = 0; nd < DIMENSIONS; nd++) {
>     nr = DIMENSIONS-nd-1;
>     dimens[nd] = grid->np_tot[nr];
>   }
232c236,237
<     start[nd]  = wgrid[nd]->nghost;
---
>     nr = DIMENSIONS-nd-1;
>     start[nd]  = grid->nghost[nr];
234c239
<     count[nd]  = wgrid[nd]->np_int;
---
>     count[nd]  = grid->np_int[nr];
315c320,321
<        dimens[nd] = wgrid[nd]->np_int_glob + (ns == (DIMENSIONS-1-nd));
---
>        nr = DIMENSIONS-nd-1;
>        dimens[nd] = grid->np_int_glob[nr] + (ns == nr);
321c327,328
<         start[nd]  = wgrid[nd]->beg - wgrid[nd]->nghost;
---
>         nr = DIMENSIONS-nd-1;
>         start[nd]  = grid->beg[nr] - grid->nghost[nr];
323,326c330,333
<         count[nd]  = wgrid[nd]->np_int;
<         if (ns == DIMENSIONS-1-nd){
<            if (grid[ns].lbound != 0) count[nd] += 1;
<            else                      start[nd] += 1;
---
>         count[nd]  = grid->np_int[nr];
>         if (ns == nr){
>            if (grid->lbound[ns] != 0) count[nd] += 1;
>            else                       start[nd] += 1;
334c341,342
<        dimens[nd] = wgrid[nd]->np_tot + (ns==(DIMENSIONS-1-nd));
---
>        nr = DIMENSIONS-nd-1;
>        dimens[nd] = grid->np_tot[nr] + (ns==nr);
339c347,348
<        start[nd]  = wgrid[nd]->nghost;
---
>        nr = DIMENSIONS-nd-1;
>        start[nd]  = grid->nghost[nr];
341,342c350,351
<        count[nd]  = wgrid[nd]->np_int;
<        if (ns == (DIMENSIONS-1-nd) && grid[ns].lbound != 0) {
---
>        count[nd]  = grid->np_int[nr];
>        if (ns == nr && grid->lbound[ns] != 0) {
390c399,402
<   for (nd = 0; nd < DIMENSIONS; nd++) dimens[nd] = wgrid[nd]->np_int_glob;
---
>   for (nd = 0; nd < DIMENSIONS; nd++) {
>     nr = DIMENSIONS-nd-1;
>     dimens[nd] = grid->np_int_glob[nr];
>   }
395c407,408
<      start[nd]  = wgrid[nd]->beg - wgrid[nd]->nghost;
---
>      nr = DIMENSIONS-nd-1;
>      start[nd]  = grid->beg[nr] - grid->nghost[nr];
397c410
<      count[nd]  = wgrid[nd]->np_int;
---
>      count[nd]  = grid->np_int[nr];
403c416,419
<   for (nd = 0; nd < DIMENSIONS; nd++) dimens[nd] = wgrid[nd]->np_int;
---
>   for (nd = 0; nd < DIMENSIONS; nd++){
>     nr = DIMENSIONS-nd-1;
>     dimens[nd] = grid->np_int[nr];
>   }
438c454,457
<   for (nd = 0; nd < DIMENSIONS; nd++) dimens[nd] = wgrid[nd]->np_int_glob+1;
---
>   for (nd = 0; nd < DIMENSIONS; nd++){
>     nr = DIMENSIONS-nd-1;
>     dimens[nd] = grid->np_int_glob[nr] + 1;
>   }
442,448c461,468
<   #ifdef PARALLEL
<    for (nd = 0; nd < DIMENSIONS; nd++) {
<      start[nd]  = wgrid[nd]->beg - wgrid[nd]->nghost;
<      stride[nd] = 1;
<      count[nd]  = wgrid[nd]->np_int;
<      if (wgrid[nd]->rbound != 0) count[nd] += 1;
<    }
---
> #ifdef PARALLEL
>   for (nd = 0; nd < DIMENSIONS; nd++) {
>     nr = DIMENSIONS-nd-1;
>     start[nd]  = grid->beg[nr] - grid->nghost[nr];
>     stride[nd] = 1;
>     count[nd]  = grid->np_int[nr];
>     if (grid->rbound[nr] != 0) count[nd] += 1;
>   }
450,451c470,471
<    err = H5Sselect_hyperslab(dataspace, H5S_SELECT_SET,
<                              start, stride, count, NULL);
---
>   err = H5Sselect_hyperslab(dataspace, H5S_SELECT_SET,
>                             start, stride, count, NULL);
455,456c475,477
<    dimens[nd] = wgrid[nd]->np_int;
<    if (wgrid[nd]->rbound != 0) dimens[nd] += 1;
---
>     nr = DIMENSIONS-nd-1;
>     dimens[nd] = grid->np_int[nr];
>     if (grid->rbound[nr] != 0) dimens[nd] += 1;
483c504
<  #if MPI_POSIX == NO
---
> #if MPI_POSIX == NO
485c506
<  #endif
---
> #endif
489d509
< 
515c535
<              wgrid[0]->np_int_glob+1, wgrid[1]->np_int_glob+1);
---
>              grid->np_int_glob[JDIR]+1, grid->np_int_glob[IDIR]+1);
519c539
<               wgrid[0]->np_int_glob+1, wgrid[1]->np_int_glob+1 );
---
>               grid->np_int_glob[JDIR]+1, grid->np_int_glob[IDIR]+1 );
525c545,547
<              wgrid[0]->np_int_glob+1, wgrid[1]->np_int_glob+1, wgrid[2]->np_int_glob+1);
---
>              grid->np_int_glob[KDIR]+1,
>              grid->np_int_glob[JDIR]+1,
>              grid->np_int_glob[IDIR]+1);
529c551,553
<                wgrid[0]->np_int_glob+1, wgrid[1]->np_int_glob+1, wgrid[2]->np_int_glob+1 );
---
>                grid->np_int_glob[KDIR]+1,
>                grid->np_int_glob[JDIR]+1,
>                grid->np_int_glob[IDIR]+1 );
541c565,566
<                wgrid[0]->np_int_glob, wgrid[1]->np_int_glob, nprec);
---
>                grid->np_int_glob[JDIR],
>                grid->np_int_glob[IDIR], nprec);
544c569,571
<                wgrid[0]->np_int_glob, wgrid[1]->np_int_glob, wgrid[2]->np_int_glob, nprec);
---
>                grid->np_int_glob[KDIR],
>                grid->np_int_glob[JDIR],
>                grid->np_int_glob[IDIR], nprec);
555c582
<                wgrid[0]->np_int_glob, wgrid[1]->np_int_glob);
---
>                grid->np_int_glob[JDIR], grid->np_int_glob[IDIR]);
558c585,587
<                wgrid[0]->np_int_glob, wgrid[1]->np_int_glob, wgrid[2]->np_int_glob);
---
>                grid->np_int_glob[KDIR],
>                grid->np_int_glob[JDIR],
>                grid->np_int_glob[IDIR]);
576c605
<      print1 (" [%5.2f sec]",difftime(tend,tbeg));
---
>      print (" [%5.2f sec]",difftime(tend,tbeg));
606,607c635
<   int ierr, rank, nd, nv, ns;
<   Grid *wgrid[3];
---
>   int ierr, rank, nd, nv, ns, nr;
614,616c642
<   for (nd = 0; nd < DIMENSIONS; nd++) wgrid[nd] = grid + DIMENSIONS - nd - 1;
< 
<   print1 ("> restarting from file #%d (dbl.h5)\n",output->nfile);
---
>   print ("> restarting from file #%d (dbl.h5)\n",output->nfile);
635c661
<     print1 ("! HDF5_READ: file %s does not exist\n");
---
>     print ("! HDF5_READ: file %s does not exist\n");
659c685,686
<        start[nd]  = wgrid[nd]->beg - wgrid[nd]->nghost;
---
>        nr = DIMENSIONS-nd-1;
>        start[nd]  = grid->beg[nr] - grid->nghost[nr];
661c688
<        count[nd]  = wgrid[nd]->np_int;
---
>        count[nd]  = grid->np_int[nr];
666c693,696
<     for (nd = 0; nd < DIMENSIONS; nd++) dimens[nd] = wgrid[nd]->np_tot;
---
>     for (nd = 0; nd < DIMENSIONS; nd++) {
>       nr = DIMENSIONS-nd-1;
>       dimens[nd] = grid->np_tot[nr];
>     } 
671c701,702
<       start[nd]  = wgrid[nd]->nghost;
---
>       nr = DIMENSIONS-nd-1;
>       start[nd]  = grid->nghost[nr];
673c704
<       count[nd]  = wgrid[nd]->np_int;
---
>       count[nd]  = grid->np_int[nr];
710c741,742
<         start[nd]  = wgrid[nd]->beg - wgrid[nd]->nghost;
---
>         nr = DIMENSIONS-nd-1;
>         start[nd]  = grid->beg[nr] - grid->nghost[nr];
712c744
<         count[nd]  = wgrid[nd]->np_int;
---
>         count[nd]  = grid->np_int[nr];
722,723c754,757
<      for (nd = 0; nd < DIMENSIONS; nd++)
<        dimens[nd] = wgrid[nd]->np_tot + (ns == (DIMENSIONS-1-nd));
---
>      for (nd = 0; nd < DIMENSIONS; nd++){
>        nr = DIMENSIONS-nd-1;
>        dimens[nd] = grid->np_tot[nr] + (ns == nr);
>      }
727,728c761,763
<      for (nd = 0; nd < DIMENSIONS; nd++){ 
<        start[nd]  = wgrid[nd]->nghost;
---
>      for (nd = 0; nd < DIMENSIONS; nd++){
>        nr = DIMENSIONS-nd-1;
>        start[nd]  = grid->nghost[nr];
730,731c765,766
<        count[nd]  = wgrid[nd]->np_int;
<        if (ns == DIMENSIONS-1-nd && grid[ns].lbound != 0) {
---
>        count[nd]  = grid->np_int[nr];
>        if (ns == nr && grid->lbound[ns] != 0) {
diff Src/hdf5_io.vChombo3.1.c ../old/hdf5_io.vChombo3.1.c
122c122
<        print1 ("! HDF5_IO: Unknown geometry\n");
---
>        print ("! HDF5_IO: Unknown geometry\n");
153c153
<        print1 ("! HDF5_IO: Unknown geometry\n");
---
>        print ("! HDF5_IO: Unknown geometry\n");
560c560
<      print1 (" [%5.2f sec]",difftime(tend,tbeg));
---
>      print (" [%5.2f sec]",difftime(tend,tbeg));
600c600
<   print1 ("> restarting from file #%d (dbl.h5)\n",output->nfile);
---
>   print ("> restarting from file #%d (dbl.h5)\n",output->nfile);
618c618
<     print1 ("! HDF5_READ: file %s does not exist\n");
---
>     print ("! HDF5_READ: file %s does not exist\n");
diff Src/initialize.c ../old/initialize.c
29c29,30
<   \date   Aug 24, 2015
---
>           B. Vaidya
>   \date   May 21, 2018
82c83
<   #ifdef PARALLEL
---
> #ifdef PARALLEL
86c87
<    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
---
>   MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
90,91c91,92
<    if (prank == 0) RuntimeSetup (runtime, cmd_line, ini_file);
<    MPI_Bcast (runtime,  sizeof (struct RUNTIME) , MPI_BYTE, 0, MPI_COMM_WORLD);
---
>   if (prank == 0) RuntimeSetup (runtime, cmd_line, ini_file);
>   MPI_Bcast (runtime,  sizeof (Runtime) , MPI_BYTE, 0, MPI_COMM_WORLD);
95,97c96,98
<    nghost = GetNghost();
<    MPI_Allreduce (&nghost, &idim, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
<    nghost = idim;
---
>   nghost = GetNghost();
>   MPI_Allreduce (&nghost, &idim, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
>   nghost = idim;
99,105c100,106
<    for (idim = 0; idim < DIMENSIONS; idim++) {
<      gsize[idim]   = runtime->npoint[idim];
<      ghosts[idim]  = nghost;
<      periods[idim] =    (runtime->left_bound[idim] == PERIODIC ? 1:0)
<                      || (runtime->left_bound[idim] == SHEARING ? 1:0);
<      pardim[idim]  = cmd_line->parallel_dim[idim];
<    }
---
>   for (idim = 0; idim < DIMENSIONS; idim++) {
>     gsize[idim]   = runtime->npoint[idim];
>     ghosts[idim]  = nghost;
>     periods[idim] =    (runtime->left_bound[idim] == PERIODIC ? 1:0)
>                     || (runtime->left_bound[idim] == SHEARING ? 1:0);
>     pardim[idim]  = cmd_line->parallel_dim[idim];
>   }
109c110
<    decomp_mode = GetDecompMode(cmd_line, procs);
---
>   decomp_mode = GetDecompMode(cmd_line, procs);
117,130c118,131
<    AL_Sz_init (MPI_COMM_WORLD, &SZ);
<    AL_Set_type (MPI_DOUBLE, 1, SZ);
<    AL_Set_dimensions (DIMENSIONS, SZ);
<    AL_Set_global_dim (gsize, SZ);
<    AL_Set_ghosts (ghosts, SZ);
<    AL_Set_periodic_dim (periods, SZ);
<    AL_Set_parallel_dim (pardim, SZ);
< 
<    AL_Decompose (SZ, procs, decomp_mode);
<    AL_Get_local_dim (SZ, lsize);
<    AL_Get_bounds (SZ, beg, end, ghosts, AL_C_INDEXES);
<    AL_Get_lbounds (SZ, lbeg, lend, ghosts, AL_C_INDEXES);
<    AL_Get_gbounds (SZ, gbeg, gend, ghosts, AL_C_INDEXES);
<    AL_Is_boundary (SZ, is_gbeg, is_gend);
---
>   AL_Sz_init (MPI_COMM_WORLD, &SZ);
>   AL_Set_type (MPI_DOUBLE, 1, SZ);
>   AL_Set_dimensions (DIMENSIONS, SZ);
>   AL_Set_global_dim (gsize, SZ);
>   AL_Set_ghosts (ghosts, SZ);
>   AL_Set_periodic_dim (periods, SZ);
>   AL_Set_parallel_dim (pardim, SZ);
> 
>   AL_Decompose (SZ, procs, decomp_mode);
>   AL_Get_local_dim (SZ, lsize);
>   AL_Get_bounds (SZ, beg, end, ghosts, AL_C_INDEXES);
>   AL_Get_lbounds (SZ, lbeg, lend, ghosts, AL_C_INDEXES);
>   AL_Get_gbounds (SZ, gbeg, gend, ghosts, AL_C_INDEXES);
>   AL_Is_boundary (SZ, is_gbeg, is_gend);
134,147c135,148
<    AL_Sz_init (MPI_COMM_WORLD, &SZ_float);
<    AL_Set_type (MPI_FLOAT, 1, SZ_float);
<    AL_Set_dimensions (DIMENSIONS, SZ_float);
<    AL_Set_global_dim (gsize, SZ_float);
<    AL_Set_ghosts (ghosts, SZ_float);
<    AL_Set_periodic_dim (periods, SZ_float);
<    AL_Set_parallel_dim (pardim, SZ_float);
< 
<    AL_Decompose (SZ_float, procs, decomp_mode);
<    AL_Get_local_dim (SZ_float, lsize);
<    AL_Get_bounds (SZ_float, beg, end, ghosts, AL_C_INDEXES);
<    AL_Get_lbounds (SZ_float, lbeg, lend, ghosts, AL_C_INDEXES);
<    AL_Get_gbounds (SZ_float, gbeg, gend, ghosts, AL_C_INDEXES);
<    AL_Is_boundary (SZ_float, is_gbeg, is_gend);
---
>   AL_Sz_init (MPI_COMM_WORLD, &SZ_float);
>   AL_Set_type (MPI_FLOAT, 1, SZ_float);
>   AL_Set_dimensions (DIMENSIONS, SZ_float);
>   AL_Set_global_dim (gsize, SZ_float);
>   AL_Set_ghosts (ghosts, SZ_float);
>   AL_Set_periodic_dim (periods, SZ_float);
>   AL_Set_parallel_dim (pardim, SZ_float);
> 
>   AL_Decompose (SZ_float, procs, decomp_mode);
>   AL_Get_local_dim (SZ_float, lsize);
>   AL_Get_bounds (SZ_float, beg, end, ghosts, AL_C_INDEXES);
>   AL_Get_lbounds (SZ_float, lbeg, lend, ghosts, AL_C_INDEXES);
>   AL_Get_gbounds (SZ_float, gbeg, gend, ghosts, AL_C_INDEXES);
>   AL_Is_boundary (SZ_float, is_gbeg, is_gend);
151,164c152,165
<    AL_Sz_init (MPI_COMM_WORLD, &SZ_char);
<    AL_Set_type (MPI_CHAR, 1, SZ_char);
<    AL_Set_dimensions (DIMENSIONS, SZ_char);
<    AL_Set_global_dim (gsize, SZ_char);
<    AL_Set_ghosts (ghosts, SZ_char);
<    AL_Set_periodic_dim (periods, SZ_char);
<    AL_Set_parallel_dim (pardim, SZ_char);
< 
<    AL_Decompose (SZ_char, procs, decomp_mode);
<    AL_Get_local_dim (SZ_char, lsize);
<    AL_Get_bounds (SZ_char, beg, end, ghosts, AL_C_INDEXES);
<    AL_Get_lbounds (SZ_char, lbeg, lend, ghosts, AL_C_INDEXES);
<    AL_Get_gbounds (SZ_char, gbeg, gend, ghosts, AL_C_INDEXES);
<    AL_Is_boundary (SZ_char, is_gbeg, is_gend);
---
>   AL_Sz_init (MPI_COMM_WORLD, &SZ_char);
>   AL_Set_type (MPI_CHAR, 1, SZ_char);
>   AL_Set_dimensions (DIMENSIONS, SZ_char);
>   AL_Set_global_dim (gsize, SZ_char);
>   AL_Set_ghosts (ghosts, SZ_char);
>   AL_Set_periodic_dim (periods, SZ_char);
>   AL_Set_parallel_dim (pardim, SZ_char);
> 
>   AL_Decompose (SZ_char, procs, decomp_mode);
>   AL_Get_local_dim (SZ_char, lsize);
>   AL_Get_bounds (SZ_char, beg, end, ghosts, AL_C_INDEXES);
>   AL_Get_lbounds (SZ_char, lbeg, lend, ghosts, AL_C_INDEXES);
>   AL_Get_gbounds (SZ_char, gbeg, gend, ghosts, AL_C_INDEXES);
>   AL_Is_boundary (SZ_char, is_gbeg, is_gend);
168,169c169,170
<    MPI_Type_contiguous (3, MPI_FLOAT, &Float_Vect_type);
<    MPI_Type_commit (&Float_Vect_type);
---
>   MPI_Type_contiguous (3, MPI_FLOAT, &Float_Vect_type);
>   MPI_Type_commit (&Float_Vect_type);
171,201c172,202
<    AL_Sz_init (MPI_COMM_WORLD, &SZ_Float_Vect);
<    AL_Set_type (MPI_FLOAT, 3, SZ_Float_Vect);
<    AL_Set_dimensions (DIMENSIONS, SZ_Float_Vect);
<    AL_Set_global_dim (gsize, SZ_Float_Vect);
<    AL_Set_ghosts (ghosts, SZ_Float_Vect);
<    AL_Set_periodic_dim (periods, SZ_Float_Vect);
<    AL_Set_parallel_dim (pardim, SZ_Float_Vect);
< 
<    AL_Decompose (SZ_Float_Vect, procs, decomp_mode);
<    AL_Get_local_dim (SZ_Float_Vect, lsize);
<    AL_Get_bounds  (SZ_Float_Vect, beg, end, ghosts, AL_C_INDEXES);
<    AL_Get_lbounds (SZ_Float_Vect, lbeg, lend, ghosts, AL_C_INDEXES);
<    AL_Get_gbounds (SZ_Float_Vect, gbeg, gend, ghosts, AL_C_INDEXES);
<    AL_Is_boundary (SZ_Float_Vect, is_gbeg, is_gend);
< 
<    for (idim = 0; idim < DIMENSIONS; idim++) {
<      grid[idim].nghost      = nghost;
<      grid[idim].np_tot      = lsize[idim] + 2*ghosts[idim];
<      grid[idim].np_int      = lsize[idim];
<      grid[idim].np_tot_glob = runtime->npoint[idim] + 2*ghosts[idim];
<      grid[idim].np_int_glob = runtime->npoint[idim];
<      grid[idim].beg         = beg[idim];
<      grid[idim].end         = end[idim];
<      grid[idim].gbeg        = gbeg[idim];
<      grid[idim].gend        = gend[idim];
<      grid[idim].lbeg        = lbeg[idim];
<      grid[idim].lend        = lend[idim];
<      grid[idim].lbound = runtime->left_bound[idim]*is_gbeg[idim];
<      grid[idim].rbound = runtime->right_bound[idim]*is_gend[idim];
<      grid[idim].nproc  = procs[idim];
<    }
---
>   AL_Sz_init (MPI_COMM_WORLD, &SZ_Float_Vect);
>   AL_Set_type (MPI_FLOAT, 3, SZ_Float_Vect);
>   AL_Set_dimensions (DIMENSIONS, SZ_Float_Vect);
>   AL_Set_global_dim (gsize, SZ_Float_Vect);
>   AL_Set_ghosts (ghosts, SZ_Float_Vect);
>   AL_Set_periodic_dim (periods, SZ_Float_Vect);
>   AL_Set_parallel_dim (pardim, SZ_Float_Vect);
> 
>   AL_Decompose (SZ_Float_Vect, procs, decomp_mode);
>   AL_Get_local_dim (SZ_Float_Vect, lsize);
>   AL_Get_bounds  (SZ_Float_Vect, beg, end, ghosts, AL_C_INDEXES);
>   AL_Get_lbounds (SZ_Float_Vect, lbeg, lend, ghosts, AL_C_INDEXES);
>   AL_Get_gbounds (SZ_Float_Vect, gbeg, gend, ghosts, AL_C_INDEXES);
>   AL_Is_boundary (SZ_Float_Vect, is_gbeg, is_gend);
> 
>   for (idim = 0; idim < DIMENSIONS; idim++) {
>     grid->nghost[idim]      = nghost;
>     grid->np_tot[idim]      = lsize[idim] + 2*ghosts[idim];
>     grid->np_int[idim]      = lsize[idim];
>     grid->np_tot_glob[idim] = runtime->npoint[idim] + 2*ghosts[idim];
>     grid->np_int_glob[idim] = runtime->npoint[idim];
>     grid->beg[idim]         = beg[idim];
>     grid->end[idim]         = end[idim];
>     grid->gbeg[idim]        = gbeg[idim];
>     grid->gend[idim]        = gend[idim];
>     grid->lbeg[idim]        = lbeg[idim];
>     grid->lend[idim]        = lend[idim];
>     grid->lbound[idim] = runtime->left_bound[idim]*is_gbeg[idim];
>     grid->rbound[idim] = runtime->right_bound[idim]*is_gend[idim];
>     grid->nproc[idim]  = procs[idim];
>   }
207c208
<    #ifdef STAGGERED_MHD
---
>   #ifdef STAGGERED_MHD
212,241c213,242
<      D_EXPAND(stagdim[IDIR] = AL_TRUE;  ,
<               stagdim[JDIR] = AL_FALSE; , 
<               stagdim[KDIR] = AL_FALSE;)
< 
<      DIM_LOOP(idim) gsize[idim] = runtime->npoint[idim];
<      gsize[IDIR] += 1;
< 
<      #ifdef SHEARINGBOX
<       periods[IDIR] = 0;
<      #endif
< 
<      AL_Sz_init (MPI_COMM_WORLD, &SZ_stagx);
<      AL_Set_type (MPI_DOUBLE, 1, SZ_stagx);
<      AL_Set_dimensions (DIMENSIONS, SZ_stagx);
<      AL_Set_global_dim (gsize, SZ_stagx);
<      AL_Set_ghosts (ghosts, SZ_stagx);
<      AL_Set_staggered_dim(stagdim, SZ_stagx);
<      AL_Set_periodic_dim (periods, SZ_stagx);
<      AL_Set_parallel_dim (pardim, SZ_stagx);
< 
<      AL_Decompose (SZ_stagx, procs, decomp_mode);
<      AL_Get_local_dim (SZ_stagx, lsize);
<      AL_Get_bounds (SZ_stagx, beg, end, ghosts, AL_C_INDEXES);
<      AL_Get_lbounds (SZ_stagx, lbeg, lend, ghosts, AL_C_INDEXES);
<      AL_Get_gbounds (SZ_stagx, gbeg, gend, ghosts, AL_C_INDEXES);
<      AL_Is_boundary (SZ_stagx, is_gbeg, is_gend);
< 
<      #ifdef SHEARINGBOX
<       periods[IDIR] = 1;
<      #endif
---
>     D_EXPAND(stagdim[IDIR] = AL_TRUE;  ,
>              stagdim[JDIR] = AL_FALSE; , 
>              stagdim[KDIR] = AL_FALSE;)
> 
>     DIM_LOOP(idim) gsize[idim] = runtime->npoint[idim];
>     gsize[IDIR] += 1;
> 
>     #ifdef SHEARINGBOX
>     periods[IDIR] = 0;
>     #endif
> 
>     AL_Sz_init (MPI_COMM_WORLD, &SZ_stagx);
>     AL_Set_type (MPI_DOUBLE, 1, SZ_stagx);
>     AL_Set_dimensions (DIMENSIONS, SZ_stagx);
>     AL_Set_global_dim (gsize, SZ_stagx);
>     AL_Set_ghosts (ghosts, SZ_stagx);
>     AL_Set_staggered_dim(stagdim, SZ_stagx);
>     AL_Set_periodic_dim (periods, SZ_stagx);
>     AL_Set_parallel_dim (pardim, SZ_stagx);
> 
>     AL_Decompose (SZ_stagx, procs, decomp_mode);
>     AL_Get_local_dim (SZ_stagx, lsize);
>     AL_Get_bounds (SZ_stagx, beg, end, ghosts, AL_C_INDEXES);
>     AL_Get_lbounds (SZ_stagx, lbeg, lend, ghosts, AL_C_INDEXES);
>     AL_Get_gbounds (SZ_stagx, gbeg, gend, ghosts, AL_C_INDEXES);
>     AL_Is_boundary (SZ_stagx, is_gbeg, is_gend);
> 
>     #ifdef SHEARINGBOX
>      periods[IDIR] = 1;
>     #endif
245,266c246,267
<      D_EXPAND(stagdim[IDIR] = AL_FALSE;  ,
<               stagdim[JDIR] = AL_TRUE;   , 
<               stagdim[KDIR] = AL_FALSE;)
< 
<      DIM_LOOP(idim) gsize[idim] = runtime->npoint[idim];
<      gsize[JDIR] += 1;
< 
<      AL_Sz_init (MPI_COMM_WORLD, &SZ_stagy);
<      AL_Set_type (MPI_DOUBLE, 1, SZ_stagy);
<      AL_Set_dimensions (DIMENSIONS, SZ_stagy);
<      AL_Set_global_dim (gsize, SZ_stagy);
<      AL_Set_ghosts (ghosts, SZ_stagy);
<      AL_Set_staggered_dim(stagdim, SZ_stagy);
<      AL_Set_periodic_dim (periods, SZ_stagy);
<      AL_Set_parallel_dim (pardim, SZ_stagy);
< 
<      AL_Decompose (SZ_stagy, procs, decomp_mode);
<      AL_Get_local_dim (SZ_stagy, lsize);
<      AL_Get_bounds  (SZ_stagy, beg, end, ghosts, AL_C_INDEXES);
<      AL_Get_lbounds (SZ_stagy, lbeg, lend, ghosts, AL_C_INDEXES);
<      AL_Get_gbounds (SZ_stagy, gbeg, gend, ghosts, AL_C_INDEXES);
<      AL_Is_boundary (SZ_stagy, is_gbeg, is_gend);
---
>     D_EXPAND(stagdim[IDIR] = AL_FALSE;  ,
>              stagdim[JDIR] = AL_TRUE;   , 
>              stagdim[KDIR] = AL_FALSE;)
> 
>     DIM_LOOP(idim) gsize[idim] = runtime->npoint[idim];
>     gsize[JDIR] += 1;
> 
>     AL_Sz_init (MPI_COMM_WORLD, &SZ_stagy);
>     AL_Set_type (MPI_DOUBLE, 1, SZ_stagy);
>     AL_Set_dimensions (DIMENSIONS, SZ_stagy);
>     AL_Set_global_dim (gsize, SZ_stagy);
>     AL_Set_ghosts (ghosts, SZ_stagy);
>     AL_Set_staggered_dim(stagdim, SZ_stagy);
>     AL_Set_periodic_dim (periods, SZ_stagy);
>     AL_Set_parallel_dim (pardim, SZ_stagy);
> 
>     AL_Decompose (SZ_stagy, procs, decomp_mode);
>     AL_Get_local_dim (SZ_stagy, lsize);
>     AL_Get_bounds  (SZ_stagy, beg, end, ghosts, AL_C_INDEXES);
>     AL_Get_lbounds (SZ_stagy, lbeg, lend, ghosts, AL_C_INDEXES);
>     AL_Get_gbounds (SZ_stagy, gbeg, gend, ghosts, AL_C_INDEXES);
>     AL_Is_boundary (SZ_stagy, is_gbeg, is_gend);
270,291c271,292
<      D_EXPAND(stagdim[IDIR] = AL_FALSE;  ,
<               stagdim[JDIR] = AL_FALSE;  , 
<               stagdim[KDIR] = AL_TRUE;)
< 
<      DIM_LOOP(idim) gsize[idim] = runtime->npoint[idim];
<      gsize[KDIR] += 1;
< 
<      AL_Sz_init (MPI_COMM_WORLD, &SZ_stagz);
<      AL_Set_type (MPI_DOUBLE, 1, SZ_stagz);
<      AL_Set_dimensions (DIMENSIONS, SZ_stagz);
<      AL_Set_global_dim (gsize, SZ_stagz);
<      AL_Set_ghosts (ghosts, SZ_stagz);
<      AL_Set_staggered_dim(stagdim, SZ_stagz);
<      AL_Set_periodic_dim (periods, SZ_stagz);
<      AL_Set_parallel_dim (pardim, SZ_stagz);
< 
<      AL_Decompose (SZ_stagz, procs, decomp_mode);
<      AL_Get_local_dim (SZ_stagz, lsize);
<      AL_Get_bounds  (SZ_stagz, beg, end, ghosts, AL_C_INDEXES);
<      AL_Get_lbounds (SZ_stagz, lbeg, lend, ghosts, AL_C_INDEXES);
<      AL_Get_gbounds (SZ_stagz, gbeg, gend, ghosts, AL_C_INDEXES);
<      AL_Is_boundary (SZ_stagz, is_gbeg, is_gend);
---
>     D_EXPAND(stagdim[IDIR] = AL_FALSE;  ,
>              stagdim[JDIR] = AL_FALSE;  , 
>              stagdim[KDIR] = AL_TRUE;)
> 
>     DIM_LOOP(idim) gsize[idim] = runtime->npoint[idim];
>     gsize[KDIR] += 1;
> 
>     AL_Sz_init (MPI_COMM_WORLD, &SZ_stagz);
>     AL_Set_type (MPI_DOUBLE, 1, SZ_stagz);
>     AL_Set_dimensions (DIMENSIONS, SZ_stagz);
>     AL_Set_global_dim (gsize, SZ_stagz);
>     AL_Set_ghosts (ghosts, SZ_stagz);
>     AL_Set_staggered_dim(stagdim, SZ_stagz);
>     AL_Set_periodic_dim (periods, SZ_stagz);
>     AL_Set_parallel_dim (pardim, SZ_stagz);
> 
>     AL_Decompose (SZ_stagz, procs, decomp_mode);
>     AL_Get_local_dim (SZ_stagz, lsize);
>     AL_Get_bounds  (SZ_stagz, beg, end, ghosts, AL_C_INDEXES);
>     AL_Get_lbounds (SZ_stagz, lbeg, lend, ghosts, AL_C_INDEXES);
>     AL_Get_gbounds (SZ_stagz, gbeg, gend, ghosts, AL_C_INDEXES);
>     AL_Is_boundary (SZ_stagz, is_gbeg, is_gend);
293,294c294
< 
<    #endif /* STAGGERED_MHD */
---
>   #endif /* STAGGERED_MHD */
310c310
<       grid[idim].rank_coord = coords[idim];
---
>       grid->rank_coord[idim] = coords[idim];
314c314
<   #else  /* if NOT PARALLEL */
---
> #else  /* if NOT PARALLEL */
320,321c320,321
<    RuntimeSetup (runtime, cmd_line, ini_file);
<    nghost = GetNghost();
---
>   RuntimeSetup (runtime, cmd_line, ini_file);
>   nghost = GetNghost();
323,334c323,334
<    for (idim = 0; idim < DIMENSIONS; idim++) {
<      grid[idim].nghost  = nghost;
<      grid[idim].np_int  = grid[idim].np_int_glob = runtime->npoint[idim];
<      grid[idim].np_tot  = grid[idim].np_tot_glob = runtime->npoint[idim] + 2*nghost;
<      grid[idim].beg     = grid[idim].gbeg = grid[idim].lbeg = nghost;
<      grid[idim].end     = grid[idim].gend = grid[idim].lend 
<                         = (grid[idim].lbeg - 1) + grid[idim].np_int;
<      grid[idim].lbound  = runtime->left_bound[idim];
<      grid[idim].rbound  = runtime->right_bound[idim];
<      grid[idim].nproc   = 1;
<    }
<    nprocs = 1;
---
>   for (idim = 0; idim < DIMENSIONS; idim++) {
>     grid->nghost[idim]  = nghost;
>     grid->np_int[idim]  = grid->np_int_glob[idim] = runtime->npoint[idim];
>     grid->np_tot[idim]  = grid->np_tot_glob[idim] = runtime->npoint[idim] + 2*nghost;
>     grid->beg[idim]     = grid->gbeg[idim] = grid->lbeg[idim] = nghost;
>     grid->end[idim]     = grid->gend[idim] = grid->lend[idim] 
>                         = (grid->lbeg[idim] - 1) + grid->np_int[idim];
>     grid->lbound[idim]  = runtime->left_bound[idim];
>     grid->rbound[idim]  = runtime->right_bound[idim];
>     grid->nproc[idim]   = 1;
>   }
>   nprocs = 1;
336c336
<   #endif
---
> #endif
344c344
<   SetLogFile  (runtime->output_dir, cmd_line);
---
>   SetLogFile  (runtime->log_dir, cmd_line);
351c351
<   print1 ("\n> Generating grid...\n\n");
---
>   print ("\n> Generating grid...\n\n");
356c356
<     print1 ("\n> Done < \n");
---
>     print ("\n> Done < \n");
367a368
>   g_nprocs         = nprocs;
369,380c370,381
< 
<   IBEG = grid[IDIR].lbeg; IEND = grid[IDIR].lend;
<   JBEG = grid[JDIR].lbeg; JEND = grid[JDIR].lend;
<   KBEG = grid[KDIR].lbeg; KEND = grid[KDIR].lend;
< 
<   NX1 = grid[IDIR].np_int;
<   NX2 = grid[JDIR].np_int;
<   NX3 = grid[KDIR].np_int;
< 
<   NX1_TOT = grid[IDIR].np_tot; 
<   NX2_TOT = grid[JDIR].np_tot;
<   NX3_TOT = grid[KDIR].np_tot;
---
>   
>   IBEG = grid->lbeg[IDIR]; IEND = grid->lend[IDIR];
>   JBEG = grid->lbeg[JDIR]; JEND = grid->lend[JDIR];
>   KBEG = grid->lbeg[KDIR]; KEND = grid->lend[KDIR];
> 
>   NX1 = grid->np_int[IDIR];
>   NX2 = grid->np_int[JDIR];
>   NX3 = grid->np_int[KDIR];
> 
>   NX1_TOT = grid->np_tot[IDIR]; 
>   NX2_TOT = grid->np_tot[JDIR];
>   NX3_TOT = grid->np_tot[KDIR];
390,395d390
< /* ---------------------------------------------
<     Define the RBox structures.
<    --------------------------------------------- */
< 
<   SetRBox();
< 
417,422c412,417
<   #ifdef PARALLEL
<    MPI_Allreduce (dxmin, dxming, 3, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<    dxmin[IDIR] = dxming[IDIR];
<    dxmin[JDIR] = dxming[JDIR];
<    dxmin[KDIR] = dxming[KDIR];
<   #endif
---
> #ifdef PARALLEL
>   MPI_Allreduce (dxmin, dxming, 3, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
>   dxmin[IDIR] = dxming[IDIR];
>   dxmin[JDIR] = dxming[JDIR];
>   dxmin[KDIR] = dxming[KDIR];
> #endif
424,426c419,421
<   grid[IDIR].dl_min = dxmin[IDIR];
<   grid[JDIR].dl_min = dxmin[JDIR];
<   grid[KDIR].dl_min = dxmin[KDIR];
---
>   grid->dl_min[IDIR] = dxmin[IDIR];
>   grid->dl_min[JDIR] = dxmin[JDIR];
>   grid->dl_min[KDIR] = dxmin[KDIR];
434,436c429,431
<   #if RECONSTRUCTION == PARABOLIC
<    PPM_CoefficientsSet (grid);  
<   #endif
---
> #if RECONSTRUCTION == PARABOLIC
>   PPM_CoefficientsSet (grid);  
> #endif
448c443
<   print1 ("\n> Memory allocation\n");
---
>   print ("\n> Memory allocation\n");
452,466c447,465
<   #ifdef STAGGERED_MHD
<    data->Vs = ARRAY_1D(DIMENSIONS, double ***);
<    D_EXPAND(
<      data->Vs[BX1s] = ArrayBox( 0, NX3_TOT-1, 0, NX2_TOT-1,-1, NX1_TOT-1); ,
<      data->Vs[BX2s] = ArrayBox( 0, NX3_TOT-1,-1, NX2_TOT-1, 0, NX1_TOT-1); ,
<      data->Vs[BX3s] = ArrayBox(-1, NX3_TOT-1, 0, NX2_TOT-1, 0, NX1_TOT-1);)
<   #endif  
< 
<   #if UPDATE_VECTOR_POTENTIAL == YES 
<    D_EXPAND(                                                  ,
<      data->Ax3 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);  , 
<      data->Ax1 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);  
<      data->Ax2 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);  
<    )
<   #endif
---
> #ifdef STAGGERED_MHD
>   data->Vs = ARRAY_1D(DIMENSIONS, double ***);
>   D_EXPAND(
>     data->Vs[BX1s] = ArrayBox( 0, NX3_TOT-1, 0, NX2_TOT-1,-1, NX1_TOT-1); ,
>     data->Vs[BX2s] = ArrayBox( 0, NX3_TOT-1,-1, NX2_TOT-1, 0, NX1_TOT-1); ,
>     data->Vs[BX3s] = ArrayBox(-1, NX3_TOT-1, 0, NX2_TOT-1, 0, NX1_TOT-1);
>   )
> 
>   data->Ex1 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
>   data->Ex2 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
>   data->Ex3 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
> 
>   data->emf = malloc(sizeof(EMF));
>   CT_Allocate (data->emf);
> #endif  
> 
> /* ------------------------------------------------------------
>     Allocate memory for vector potential.
>    ------------------------------------------------------------ */
468,469c467,496
<   #if RESISTIVITY != NO
<    data->J = ARRAY_4D(3,NX3_TOT, NX2_TOT, NX1_TOT, double);
---
> #if UPDATE_VECTOR_POTENTIAL == YES || ASSIGN_VECTOR_POTENTIAL == YES
>   data->Ax3 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);   
>   data->Ax1 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);  
>   data->Ax2 = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);  
> #endif
> 
> #if RESISTIVITY || HALL_MHD
>   data->J = ARRAY_4D(3,NX3_TOT, NX2_TOT, NX1_TOT, double);
> #endif
> 
> #if THERMAL_CONDUCTION
>   data->Tc = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
> #endif
> 
> #if FORCED_TURB == YES
>   data->Ft = malloc(sizeof(ForcedTurb));
> #endif
> 
> #ifdef PARTICLES
>   data->PHead = NULL;
>   data->pstr  = NULL;
>   #if PARTICLES_TYPE == COSMIC_RAYS
>   data->Ecr = ARRAY_4D(3, NX3_TOT, NX2_TOT, NX1_TOT, double);
>   data->Fcr = ARRAY_4D(4, NX3_TOT, NX2_TOT, NX1_TOT, double);
>   data->Jcr = ARRAY_4D(3, NX3_TOT, NX2_TOT, NX1_TOT, double);
>   data->qcr = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
>   #endif
>   #if PARTICLES_TYPE == DUST
>   data->Vdust = ARRAY_4D(3, NX3_TOT, NX2_TOT, NX1_TOT, double);
>   data->Fdust = ARRAY_4D(3, NX3_TOT, NX2_TOT, NX1_TOT, double);
470a498
> #endif
478,484c506,510
<   #if EOS == PVTE_LAW && NIONS == 0
<    #if TV_ENERGY_TABLE == YES
<     MakeInternalEnergyTable();
<    #else
<     MakeEV_TemperatureTable();
<    #endif
<    MakePV_TemperatureTable();
---
> #if EOS == PVTE_LAW && NIONS == 0
>   #if TV_ENERGY_TABLE == YES
>   MakeInternalEnergyTable();
>   #else
>   MakeEV_TemperatureTable();
485a512,513
>   MakePV_TemperatureTable();
> #endif
488c516,518
<               Assign initial conditions
---
>     Assign initial conditions.
>     We also compute the average orbital velocity in case
>     output requires writing the residual.
491a522,527
> #ifdef PARTICLES
>   if (cmd_line->restart == NO) Particles_Set(data, grid); 
> #endif
> #ifdef FARGO
>   FARGO_ComputeVelocity(data, grid);
> #endif
493,495c529,532
< /* ------------------------------------------------------------ 
<     Set output attributes (names, images, number of outputs...)
<    ------------------------------------------------------------ */
---
> /* --------------------------------------------------------
>     Set output attributes (names, images, number of
>     outputs...)
>    -------------------------------------------------------- */
497a535,538
> #ifdef PARTICLES
>   Particles_SetOutput(data, runtime);
> #endif
>   ChangeOutputVar();
499c540
< /* -----------------------------------
---
> /* --------------------------------------------------------
501c542
<    ----------------------------------- */
---
>    -------------------------------------------------------- */
505,517c546,568
<   print1 ("> Number of processors: %d\n",nprocs);
<   D_EXPAND(print1 ("> Typical proc size:    %d",grid[IDIR].np_int);  ,
<            print1 (" X %d", grid[JDIR].np_int);                      ,
<            print1 (" X %d", grid[KDIR].np_int);)
<   print1 ("\n");
<   #ifdef PARALLEL
<    print1 ("> Parallel Directions: ");
<    D_EXPAND(if (pardim[IDIR]) print1 (" X1");  ,
<             if (pardim[JDIR]) print1 ("/X2");  ,
<             if (pardim[KDIR]) print1 ("/X3");)
<    print1 ("\n");
<   #endif   
<   if (cmd_line->show_dec) ShowDomainDecomposition (nprocs, grid);
---
>   print ("> Number of processors: %d\n",nprocs);
>   D_EXPAND(
>            print ("> Proc size:            %d",grid->np_int[IDIR]);  ,
>            print (" X %d", grid->np_int[JDIR]);                      ,
>            print (" X %d", grid->np_int[KDIR]);)
>   print ("\n");
> #ifdef PARALLEL
>   print ("> Parallel Directions: ");
>   D_EXPAND(if (pardim[IDIR]) print (" X1");  ,
>            if (pardim[JDIR]) print ("/X2");  ,
>            if (pardim[KDIR]) print ("/X3");)
>   print ("\n");
> #endif
> 
> /* --------------------------------------------------------
>    Enable writing of grid information to be read by
>    gnuplot. This is done for educational purposes only.
>    -------------------------------------------------------- */
> 
> #if !(defined CHOMBO) && (defined GNUPLOT)
>   GnuplotSetting(grid);
> #endif
> 
diff Src/input_data.c ../old/input_data.c
6,7c6,7
<   Collects a number of functions for opening, reading and assigning 
<   initial conditions from user-supplied data file(s).
---
>   Collects a number of functions for opening, reading and interpolating
>   initial conditions from user-supplied binary data file(s).
12c12,13
<   conventions employed by PLUTO. 
---
>   conventions employed by PLUTO.
>   Specifically:
14,16c15,18
<   - Gridfile: coordinates should be written using the PLUTO 4.0 grid format.
<   - Datafile: variables should be written in sequence in a single binary 
<               file using single or double precision. 
---
>   - Gridfile: coordinates should be written using the standard
>               PLUTO 4 grid format.
>   - Datafile: variables should be written in single or multiple
>               binary data file using eighter single or double precision.
20,28c22,33
<     Note that not all of the variables should be present and the input
<     array ::get_var specifies which ones are to be searched for.
< 
<   The InputDataSet() initialize the module and by assigning values to 
<   global variables such as size, geometry and dimensions of the input grid.
<   Data values are read through the function InputDataRead() while
<   InputDataInterpolate() can be finally used to map input data onto the
<   grid employed by PLUTO using bi- or tri-linear interpolation to fill the 
<   data array at the desired coordinate location.
---
>   InputDataOpen() initializes the inputData structure for a given
>   input field (e.g. density) iby reading grid size and coordinates,
>   geometry, precision, endianity, etc..
> 
>   InputDataInterpolate() is used to interpolate the given field from the
>   input coordinates to the desired coordinate location using bi- or
>   tri-linear interpolation to fill the data array.
> 
>   The input data is stored in a buffer by reading ::ID_NZ_MAX planes at
>   a time to save computational memory.
>   The value of ::ID_NZ_MAX can be changed from your personal \c definitions.h.
>   This task is performed in the InputDataReadSlice() function.
31,32c36
<            P. Tzeferacos 
<   \date   Aug 27, 2012
---
>   \date    Nov 17, 2016
36d39
< #define ID_MAX_NVAR 256 
38,48c41,62
< static int id_nvar; /**< Number of variables to be read on input. */
< static int id_var_indx[ID_MAX_NVAR]; /**< The variable index. */
< static int id_nx1; /**< Size of input grid in the x1 direction. */
< static int id_nx2; /**< Size of input grid in the x2 direction. */
< static int id_nx3; /**< Size of input grid in the x3 direction. */
< 
< static int id_geom;   /**< Geometry of the input grid. */
< 
< static double *id_x1; /**< Array of point coordinates of the x1 input grid. */
< static double *id_x2; /**< Array of point coordinates of the x2 input grid. */
< static double *id_x3; /**< Array of point coordinates of the x3 input grid. */
---
> #define ID_NVAR_MAX 64
> #ifndef ID_NZ_MAX
>  #define ID_NZ_MAX   4  /**< Maximum size (in the 3rd dimension) of the
>                              input buffer. */
> #endif
> 
> typedef struct inputData_{
>   char fname[64];
>   size_t dsize;
>   int nx1;
>   int nx2; 
>   int nx3;
>   int geom;
>   int swap_endian;
>   int klast;        /**< The index of the last read plane */
>   double *x1;
>   double *x2;
>   double *x3;
>   double ***Vin;    /**< Input buffer array (containing at most ::ID_NZ_MAX
>                          planes at a time */
>   long int offset;
> } inputData;
50,51c64
< static double ***Vin[ID_MAX_NVAR]; /**< An array of 3D data values containing the
<                                         initial data file variables. */
---
> static inputData id_stack[ID_NVAR_MAX];
54c67
< void InputDataSet (char *grid_fname, int *get_var)
---
> int InputDataOpen(char *data_fname, char *grid_fname, char *endianity, int pos)
60,63c73,81
<  * \param [in] gname the grid file name
<  * \param [in] get_var an array of integers specifying which variables
<  *                     have to be read from the input data. 
<  * \return Thi function has no return value.
---
>  * \param [in] data_fname    the name of the input binary data file 
>  * \param [in] grid_fname    the name of the corresponding grid file
>  * \param [in] endianity     an input string ("little" or "big") giving
>  *                           the byte-order of how the input data file
>  *                           was originally written.
>  *                           If an empty string is supplied, no change is
>  *                           made.
>  * \param [in] pos           an integer specifying the position of
>  *                           the variable in the file.
65d82
<  * The following tasks are performed.
68,69d84
<   int    i, ip, nv, success;
<   size_t dsize, dcount;
71a87,89
>   int    i, ip, success;
>   int    indx; /* The 1st available element in the id_stack structure */
>   size_t str_length;
72a91
>   inputData *id;
76c95
<   print1 ("> Input data:\n\n");
---
>   print ("> Input data:\n\n");
79,81c98,117
< /*! - Scan grid data file and try to determine the grid geometry 
<       (::id_geom). Search for tag "GEOMETRY:" and read the word that
<       follows.                                                           */
---
> /*! 0. Find the 1st available (NULL pointer) element in the stack        */
> /* --------------------------------------------------------------------- */
> 
>   indx = 0;
>   while (id_stack[indx].Vin != NULL){
>     indx++;
>     if (indx == ID_NVAR_MAX){
>       print ("! InputDataOpen(): max number of variables exceeded\n");
>       print ("!                  indx = %d\n",indx);
>       QUIT_PLUTO(1);
>     }
>   }
> 
>   print ("  Allocating memory for struct # %d\n",indx);
>   id = id_stack + indx;
> 
> /* --------------------------------------------------------------------- */
> /*! 1. Scan grid data file and try to determine the grid geometry 
>        (\c id->geom). Search for tag "GEOMETRY:" and read the word that
>        follows.                                                          */
86c122
<     print1 ("! InputDataSet: grid file %s not found\n",grid_fname);
---
>     print ("! InputDataOpen(): grid file %s not found\n",grid_fname);
103,106c139,142
<   if      (!strcmp(sub_str,"CARTESIAN"))   id_geom = CARTESIAN;
<   else if (!strcmp(sub_str,"CYLINDRICAL")) id_geom = CYLINDRICAL;
<   else if (!strcmp(sub_str,"POLAR"))       id_geom = POLAR;
<   else if (!strcmp(sub_str,"SPHERICAL"))   id_geom = SPHERICAL;
---
>   if      (!strcmp(sub_str,"CARTESIAN"))   id->geom = CARTESIAN;
>   else if (!strcmp(sub_str,"CYLINDRICAL")) id->geom = CYLINDRICAL;
>   else if (!strcmp(sub_str,"POLAR"))       id->geom = POLAR;
>   else if (!strcmp(sub_str,"SPHERICAL"))   id->geom = SPHERICAL;
108c144
<     print1 ("! InputDataSet: unknown geometry\n");
---
>     print ("! InputDataOpen(): unknown geometry\n");
112,113c148,149
<   print1 ("  Input grid file:       %s\n", grid_fname);
<   print1 ("  Input grid geometry:   %s\n", sub_str);
---
>   print ("  Input grid file:       %s\n", grid_fname);
>   print ("  Input grid geometry:   %s\n", sub_str);
116,117c152,153
< /*! - Move file pointer until the first line that does not
<       begin with a "#".                                                  */
---
> /*! 2. Move file pointer to the first line of grid.out that does not
>        begin with a "\c #".                                              */
130,132c166,168
< /*! - Start reading number of points and grid coordinates. For the
<       input x1 direction these are stored inside the module variables
<       ::id_nx1 and ::id_x1.                                              */
---
> /*! 3. Read number of points, allocate grid arrays and store input
>        grid coordinates into structure members \c id->nx1, \c id->x1,
>        etc...                                                            */
135,137c171,173
<   fscanf (fp,"%d \n",&id_nx1);
<   id_x1 = ARRAY_1D(id_nx1, double);
<   for (i = 0; i < id_nx1; i++){
---
>   fscanf (fp,"%d \n",&(id->nx1));
>   id->x1 = ARRAY_1D(id->nx1, double);
>   for (i = 0; i < id->nx1; i++){
139c175
<     id_x1[i] = 0.5*(xl + xr);
---
>     id->x1[i] = 0.5*(xl + xr);
142,144c178,180
<   fscanf (fp,"%d \n",&id_nx2);
<   id_x2 = ARRAY_1D(id_nx2, double);
<   for (i = 0; i < id_nx2; i++){
---
>   fscanf (fp,"%d \n",&(id->nx2));
>   id->x2 = ARRAY_1D(id->nx2, double);
>   for (i = 0; i < id->nx2; i++){
146c182
<     id_x2[i] = 0.5*(xl + xr);
---
>     id->x2[i] = 0.5*(xl + xr);
149,151c185,187
<   fscanf (fp,"%d \n",&id_nx3);
<   id_x3 = ARRAY_1D(id_nx3, double);
<   for (i = 0; i < id_nx3; i++){
---
>   fscanf (fp,"%d \n",&(id->nx3));
>   id->x3 = ARRAY_1D(id->nx3, double);
>   for (i = 0; i < id->nx3; i++){
153c189
<     id_x3[i] = 0.5*(xl + xr);
---
>     id->x3[i] = 0.5*(xl + xr);
159,169c195,204
<   if (id_nx1 == 1) id_x1[0] = 0.0;
<   if (id_nx2 == 1) id_x2[0] = 0.0;
<   if (id_nx3 == 1) id_x3[0] = 0.0;
<  
<   print1 ("  Input grid extension:  x1 = [%12.3e, %12.3e] (%d points)\n",
<              id_x1[0], id_x1[id_nx1-1], id_nx1);
<   print1 ("\t\t\t x2 = [%12.3e, %12.3e] (%d points)\n",
<              id_x2[0], id_x2[id_nx2-1], id_nx2);
<   print1 ("\t\t\t x3 = [%12.3e, %12.3e] (%d points)\n",
<              id_x3[0], id_x3[id_nx3-1], id_nx3);
< 
---
>   if (id->nx1 == 1) id->x1[0] = 0.0;
>   if (id->nx2 == 1) id->x2[0] = 0.0;
>   if (id->nx3 == 1) id->x3[0] = 0.0;
> 
>   print ("  Input grid extension:  x1 = [%12.3e, %12.3e] (%d points)\n",
>              id->x1[0], id->x1[id->nx1-1], id->nx1);
>   print ("\t\t\t x2 = [%12.3e, %12.3e] (%d points)\n",
>              id->x2[0], id->x2[id->nx2-1], id->nx2);
>   print ("\t\t\t x3 = [%12.3e, %12.3e] (%d points)\n",
>              id->x3[0], id->x3[id->nx3-1], id->nx3);
171,188c206,209
< /* --------------------------------------------------------------------- */
< /*! - Find out how many and which variables we have to read (:id_nvar 
<       and ::id_var_indx). 
<       Stop counting variables as soon as the first occurrence of "-1" 
<       in get_var is encountered                                          */
< /* --------------------------------------------------------------------- */
<    
<   id_nvar = 0;
<   for (nv = 0; nv < ID_MAX_NVAR; nv++){
<     if (get_var[nv] != -1) {
<       id_nvar++;
<       id_var_indx[nv] = get_var[nv];
<     }else{
<       break;
<     }
<   }
<   print1 ("  Number of variables:   %d\n",id_nvar);
< }
---
> /* ---------------------------------------------------------- */
> /*! 4. Check if binary data file exists and allocate memory
>        buffer \c id->Vin                                      */
> /* ---------------------------------------------------------- */
190,210d210
< /* ********************************************************************* */
< void InputDataRead (char *data_fname, char *endianity)
< /*!
<  * Read input data file and store the contents into the local storage
<  * array ::Vin. Memory allocation is also done here.  
<  * The grid size and number of variables must have 
<  * previously set by calling InputDataSet().
<  * 
<  * \param [in] data_fname the data file name
<  * \param [in] endianity  an input string ("little" or "big") giving 
<  *                        the byte-order of how the input data file 
<  *                        was originally written.
<  *                        If an empty string is supplied, no change is 
<  *                        made.
<  * \return This function has no return value.
<  *********************************************************************** */
< {
<   int   i, j, k, nv, swap_endian=NO;
<   size_t dsize, dcount;
<   double udbl;
<   float  uflt;
212d211
<   FILE *fp;
214,217c213,226
< /* ----------------------------------------------------
<              Check endianity 
<    ---------------------------------------------------- */
<   
---
>   sprintf (id->fname,"%s",data_fname);
>   fp = fopen(id->fname, "rb");
>   if (fp == NULL){
>     print ("! InputDataOpen(): file %s does not exist\n", data_fname);
>     QUIT_PLUTO(1);
>   }
>   fclose(fp);
> 
>   id->Vin = ARRAY_3D(ID_NZ_MAX, id->nx2, id->nx1, double);
> 
> /* ---------------------------------------------------------- */
> /*! 5. Set endianity (\c id->swap_endian)                     */
> /* ---------------------------------------------------------- */
>  
220c229,231
<     swap_endian = YES;
---
>     id->swap_endian = YES;
>   }else{
>     id->swap_endian = NO;
223c234
<   print1 ("  Input data file:       %s (endianity: %s) \n", 
---
>   print ("  Input data file:       %s (endianity: %s) \n", 
226,228c237,240
< /* ------------------------------------------------------
<     Get data type from file extensions (dbl or flt).
<    ------------------------------------------------------ */
---
> /* ---------------------------------------------------------- */
> /*! 6. Set data size (\c id->dsize) by looking at the file
>        extension (\c dbl or \c flt).                          */
> /* ---------------------------------------------------------- */
230,231c242,243
<   dcount = strlen(data_fname);
<   for (i = 0; i < 3; i++) ext[i] = data_fname[dcount-3+i];
---
>   str_length = strlen(data_fname);
>   for (i = 0; i < 3; i++) ext[i] = data_fname[str_length-3+i];
234,235c246,247
<     print1 ("  Precision:             (double)\n");
<     dsize = sizeof(double);
---
>     print ("  Precision:             (double)\n");
>     id->dsize = sizeof(double);
237,238c249,250
<     print1 ("  Precision:\t\t  (single)\n");
<     dsize = sizeof(float);
---
>     print ("  Precision:\t\t single\n");
>     id->dsize = sizeof(float);
240c252
<     print1 ("! InputDataRead: unsupported data type '%s'\n",ext);
---
>     print ("! InputDataRead: unsupported data type '%s'\n",ext);
243,246d254
<   
< /* -------------------------------------------------------
<      Read and store data values
<    ------------------------------------------------------- */
248,254c256,259
<   fp = fopen(data_fname, "rb");
<   if (fp == NULL){
<     print1 ("! InputDataRead: file %s does not exist\n");
<     QUIT_PLUTO(1);
<   }
<   for (nv = 0; nv < id_nvar; nv++){
<     if (Vin[nv] == NULL) Vin[nv] = ARRAY_3D(id_nx3, id_nx2, id_nx1, double);
---
> /* ---------------------------------------------------------- */
> /*! 7. Compute offset (\c id->offset in bytes) and
>        initialize \c id->klast (last read plane) to -1        */
> /* ---------------------------------------------------------- */
256c261,262
<     dcount  = 1;
---
>   id->offset = (long)pos*id->dsize*id->nx1*id->nx2*id->nx3;
>   id->klast  = -1;
258,283c264,267
<     if (dsize == sizeof(double)){
<       for (k = 0; k < id_nx3; k++){ 
<       for (j = 0; j < id_nx2; j++){
<       for (i = 0; i < id_nx1; i++){
<         if (fread (&udbl, dsize, dcount, fp) != dcount){
<           print1 ("! InputDataRead: error reading data %d.\n",nv);
<           break;
<         }
<         if (swap_endian) SWAP_VAR(udbl);
<         Vin[nv][k][j][i] = udbl;
<       }}}
<     }else{
<       for (k = 0; k < id_nx3; k++){ 
<       for (j = 0; j < id_nx2; j++){
<       for (i = 0; i < id_nx1; i++){
<         if (fread (&uflt, dsize, dcount, fp) != dcount){
<           print1 ("! InputDataRead: error reading data %d.\n",nv);
<           break;
<         }
<         if (swap_endian) SWAP_VAR(uflt);
<         Vin[nv][k][j][i] = uflt;
<       }}}
<     }
<   }
<   fclose(fp);
<   print1 ("\n");
---
>   print ("  offset = %ld\n",id->offset);
>   print ("\n");
> 
>   return indx;  /* The index of the id_stack[] array */
285a270,283
> 
> /* ********************************************************************* */
> void InputDataClose(int indx)
> /*!
>  * Free memory and reset structure.
>  *********************************************************************** */
> {
>   inputData *id = id_stack + indx;
>   FreeArray1D((void *)id->x1);
>   FreeArray1D((void *)id->x2);
>   FreeArray1D((void *)id->x3);
>   FreeArray3D((void *)id->Vin);
>   id->Vin = NULL;
> }
287c285
< void InputDataInterpolate (double *vs, double x1, double x2, double x3)
---
> double InputDataInterpolate (int indx, double x1, double x2, double x3)
292,296c290,295
<  * \param [in] vs interpolated value
<  * \param [in] x1 coordinate point at which at interpolates are desired
<  * \param [in] x2 coordinate point at which at interpolates are desired
<  * \param [in] x3 coordinate point at which at interpolates are desired
<  * \return This function has no return value.
---
>  * \param [in] indx   input data array element (handle)
>  * \param [in] x1     coordinate point at which at interpolates are desired
>  * \param [in] x2     coordinate point at which at interpolates are desired
>  * \param [in] x3     coordinate point at which at interpolates are desired
>  *
>  * \return The interpolated value.
304,306c303,309
<   int i, j, k, nv, inv;
<   double xx, yy, zz;
<   double ***V;
---
>   int i, j, k, nv;
>   float  uflt;
>   double udbl;
>   double xx, yy, zz, v;
>   double **Vlo, **Vhi;
>   inputData *id = id_stack + indx;
>   static FILE *fp;
312,313c315,316
<   #if GEOMETRY == CARTESIAN
<    if (id_geom == GEOMETRY) {  
---
> #if GEOMETRY == CARTESIAN
>   if (id->geom == GEOMETRY) {  
315c318
<      /* same coordinate system: nothing to do */
---
>     /* same coordinate system: nothing to do */
317,340c320,343
<    }else if (id_geom == CYLINDRICAL) {  
<      double R, z, phi;
<      R   = sqrt(x1*x1 + x2*x2);
<      phi = atan2(x2,x1);
<      if (phi < 0.0) phi += 2.0*CONST_PI;
<      z   = x3;
< 
<      x1 = R; x2 = z; x3 = phi;
<    }else if (id_geom == POLAR) {  
<      double R, phi, z;
<      R   = sqrt(x1*x1 + x2*x2);
<      phi = atan2(x2,x1);
<      if (phi < 0.0) phi += 2.0*CONST_PI;
<      z   = x3;
< 
<      x1 = R; x2 = phi; x3 = z;
<    }else if (id_geom == SPHERICAL){
<      double r, theta, phi;
<      r     = D_EXPAND(x1*x1, + x2*x2, + x3*x3);
<      r     = sqrt(r);
<      theta = acos(x3/r);
<      phi   = atan2(x2,x1);
<      if (phi   < 0.0) phi   += 2.0*CONST_PI;
<      if (theta < 0.0) theta += 2.0*CONST_PI;
---
>   }else if (id->geom == CYLINDRICAL) {  
>     double R, z, phi;
>     R   = sqrt(x1*x1 + x2*x2);
>     phi = atan2(x2,x1);
>     if (phi < 0.0) phi += 2.0*CONST_PI;
>     z   = x3;
> 
>     x1 = R; x2 = z; x3 = phi;
>   }else if (id->geom == POLAR) {  
>     double R, phi, z;
>     R   = sqrt(x1*x1 + x2*x2);
>     phi = atan2(x2,x1);
>     if (phi < 0.0) phi += 2.0*CONST_PI;
>     z   = x3;
> 
>     x1 = R; x2 = phi; x3 = z;
>   }else if (id->geom == SPHERICAL){
>     double r, theta, phi;
>     r     = D_EXPAND(x1*x1, + x2*x2, + x3*x3);
>     r     = sqrt(r);
>     theta = acos(x3/r);
>     phi   = atan2(x2,x1);
>     if (phi   < 0.0) phi   += 2.0*CONST_PI;
>     if (theta < 0.0) theta += 2.0*CONST_PI;
342,348c345,351
<      x1 = r; x2 = theta; x3 = phi;
<    }else{
<      print1 ("! InputDataInterpolate: invalid or unsupported coordinate transformation.\n");
<      QUIT_PLUTO(1);
<    }
<   #elif GEOMETRY == CYLINDRICAL
<    if (id_geom == GEOMETRY) {  
---
>     x1 = r; x2 = theta; x3 = phi;
>   }else{
>     print ("! InputDataInterpolate(): invalid or unsupported coordinate transformation.\n");
>     QUIT_PLUTO(1);
>   }
> #elif GEOMETRY == CYLINDRICAL
>   if (id->geom == GEOMETRY) {  
350c353
<      /* same coordinate system: nothing to do */
---
>     /* same coordinate system: nothing to do */
352,358c355,361
<    }else if (id_geom == SPHERICAL) {  
<      double r, theta, phi;
<      r     = D_EXPAND(x1*x1, + x2*x2, + 0.0);
<      r     = sqrt(r);
<      theta = acos(x2/r);
<      phi   = 0.0;
<      if (theta < 0.0) theta += 2.0*CONST_PI;
---
>   }else if (id->geom == SPHERICAL) {  
>     double r, theta, phi;
>     r     = D_EXPAND(x1*x1, + x2*x2, + 0.0);
>     r     = sqrt(r);
>     theta = acos(x2/r);
>     phi   = 0.0;
>     if (theta < 0.0) theta += 2.0*CONST_PI;
360,366c363,369
<      x1 = r; x2 = theta; x3 = phi;
<    }else{
<      print1 ("! InputDataInterpolate: invalid or unsupported coordinate transformation.\n");
<      QUIT_PLUTO(1);
<    }
<   #elif GEOMETRY == POLAR
<    if (id_geom == GEOMETRY) {  
---
>     x1 = r; x2 = theta; x3 = phi;
>   }else{
>     print ("! InputDataInterpolate(): invalid or unsupported coordinate transformation.\n");
>     QUIT_PLUTO(1);
>   }
> #elif GEOMETRY == POLAR
>   if (id->geom == GEOMETRY) {  
368c371
<      /* same coordinate system: nothing to do */
---
>     /* same coordinate system: nothing to do */
370,374c373,377
<    }else if (id_geom == CARTESIAN) {  
<      double x, y, z;
<      x = x1*cos(x2);
<      y = x1*sin(x2);
<      z = x3;
---
>   }else if (id->geom == CARTESIAN) {  
>     double x, y, z;
>     x = x1*cos(x2);
>     y = x1*sin(x2);
>     z = x3;
376,382c379,385
<      x1 = x; x2 = y; x3 = z;
<    }else{
<      print1 ("! InputDataInterpolate: invalid or unsupported coordinate transformation.\n");
<      QUIT_PLUTO(1);
<    }   
<   #elif GEOMETRY == SPHERICAL
<    if (id_geom == GEOMETRY) {  
---
>     x1 = x; x2 = y; x3 = z;
>   }else{
>     print ("! InputDataInterpolate(): invalid or unsupported coordinate transformation.\n");
>     QUIT_PLUTO(1);
>   }   
> #elif GEOMETRY == SPHERICAL
>   if (id->geom == GEOMETRY) {  
384c387
<      /* same coordinate system: nothing to do */
---
>     /* same coordinate system: nothing to do */
386,391c389,393
< 
<    }else if (id_geom == CARTESIAN) {  
<      double x, y, z;
<      x = x1*sin(x2)*cos(x3);
<      y = x1*sin(x2)*sin(x3);
<      z = x1*cos(x2);
---
>   }else if (id->geom == CARTESIAN) {  
>     double x, y, z;
>     x = x1*sin(x2)*cos(x3);
>     y = x1*sin(x2)*sin(x3);
>     z = x1*cos(x2);
393,398c395,400
<      x1 = x; x2 = y; x3 = z;
<    }else{
<      print1 ("! InputDataInterpolate: invalid or unsupported coordinate transformation.\n");
<      QUIT_PLUTO(1);
<    }   
<   #endif
---
>     x1 = x; x2 = y; x3 = z;
>   }else{
>     print ("! InputDataInterpolate(): invalid or unsupported coordinate transformation.\n");
>     QUIT_PLUTO(1);
>   }   
> #endif
405,406c407,408
<   D_EXPAND(if      (x1 < id_x1[0])         x1 = id_x1[0];
<            else if (x1 > id_x1[id_nx1-1]) x1 = id_x1[id_nx1-1];  ,
---
>   D_EXPAND(if      (x1 < id->x1[0])         x1 = id->x1[0];
>            else if (x1 > id->x1[id->nx1-1]) x1 = id->x1[id->nx1-1];  ,
408,409c410,411
<            if      (x2 < id_x2[0])         x2 = id_x2[0];
<            else if (x2 > id_x2[id_nx2-1]) x2 = id_x2[id_nx2-1];  ,
---
>            if      (x2 < id->x2[0])         x2 = id->x2[0];
>            else if (x2 > id->x2[id->nx2-1]) x2 = id->x2[id->nx2-1];  ,
411,412c413,414
<            if      (x3 < id_x3[0])         x3 = id_x3[0];
<            else if (x3 > id_x3[id_nx3-1]) x3 = id_x3[id_nx3-1]; )
---
>            if      (x3 < id->x3[0])         x3 = id->x3[0];
>            else if (x3 > id->x3[id->nx3-1]) x3 = id->x3[id->nx3-1]; )
421c423
<   ih = id_nx1 - 1;
---
>   ih = id->nx1 - 1;
424c426
<     if   (x1 <= id_x1[im]) ih = im;   
---
>     if   (x1 <= id->x1[im]) ih = im;   
428c430
<   if (id_nx2 > 1){
---
>   if (id->nx2 > 1){
430c432
<     jh = id_nx2 - 1;
---
>     jh = id->nx2 - 1;
433c435
<       if (x2 <= id_x2[jm]) jh = jm;   
---
>       if (x2 <= id->x2[jm]) jh = jm;   
438c440
<   if (id_nx3 > 1){
---
>   if (id->nx3 > 1){
440c442
<     kh = id_nx3 - 1;
---
>     kh = id->nx3 - 1;
443c445
<       if (x3 <= id_x3[km]) kh = km;   
---
>       if (x3 <= id->x3[km]) kh = km;   
457,459c459,488
<   if (id_nx1 > 1) xx = (x1 - id_x1[il])/(id_x1[il+1] - id_x1[il]);  
<   if (id_nx2 > 1) yy = (x2 - id_x2[jl])/(id_x2[jl+1] - id_x2[jl]);  
<   if (id_nx3 > 1) zz = (x3 - id_x3[kl])/(id_x3[kl+1] - id_x3[kl]);
---
>   if (id->nx1 > 1) xx = (x1 - id->x1[il])/(id->x1[il+1] - id->x1[il]);  
>   if (id->nx2 > 1) yy = (x2 - id->x2[jl])/(id->x2[jl+1] - id->x2[jl]);  
>   if (id->nx3 > 1) zz = (x3 - id->x3[kl])/(id->x3[kl+1] - id->x3[kl]);
> 
> /* --------------------------------------------------------------------- */
> /*! - Read data from disk (1 or 2 planes)                                */
> /* --------------------------------------------------------------------- */
> 
> 
> /*
> print ("@@ Interpolation required at %f %f %f\n",x1,x2,x3);
> print ("@@ Closest input coord.      %f %f %f\n",
>         id->x1[il], id->x2[jl], id->x3[kl]);
> print ("@@ Coord indices:            %d %d %d\n",il,jl,kl);
> print ("@@ id->klast                 %d\n",id->klast);
> 
> static long int ncall=0;
> 
>   if ( (kl >= id->klast + ID_NZ_MAX - 1) || (id->klast == -1) ){
> print ("@@ kl = %d, klast = %d; ncall = %d\n",kl,id->klast,ncall);
>     InputDataReadSlice(indx, kl);
> ncall = 0;
>   }
> ncall++;
> */
> 
> 
>   if ( (kl >= id->klast + ID_NZ_MAX - 1) || (id->klast == -1) ){
>     InputDataReadSlice(indx, kl);
>   }
465,479c494,507
<   for (nv = 0; nv < id_nvar; nv++) { 
<     inv = id_var_indx[nv];
<     V = Vin[nv];
<     vs[inv] =   V[kl][jl][il]*(1.0 - xx)*(1.0 - yy)*(1.0 - zz)
<               + V[kl][jl][il+1]*xx*(1.0 - yy)*(1.0 - zz);
<     if (id_nx2 > 1){
<       vs[inv] +=   V[kl][jl+1][il]*(1.0 - xx)*yy*(1.0 - zz)
<                  + V[kl][jl+1][il+1]*xx*yy*(1.0 - zz);
<     }
<     if (id_nx3 > 1){
<      vs[inv] +=   V[kl+1][jl][il]*(1.0 - xx)*(1.0 - yy)*zz
<                 + V[kl+1][jl][il+1]*xx*(1.0 - yy)*zz
<                 + V[kl+1][jl+1][il]*(1.0 - xx)*yy*zz
<                 + V[kl+1][jl+1][il+1]*xx*yy*zz;
<     }
---
>   Vlo = id->Vin[kl - id->klast];
>   Vhi = id->Vin[kl - id->klast+1];
> 
>   v =   Vlo[jl][il]*(1.0 - xx)*(1.0 - yy)*(1.0 - zz)  /* [0] is kl */
>       + Vlo[jl][il+1]*xx*(1.0 - yy)*(1.0 - zz);
>   if (id->nx2 > 1){
>     v +=   Vlo[jl+1][il]*(1.0 - xx)*yy*(1.0 - zz)
>          + Vlo[jl+1][il+1]*xx*yy*(1.0 - zz);
>   }
>   if (id->nx3 > 1){
>     v +=   Vhi[jl][il]*(1.0 - xx)*(1.0 - yy)*zz
>          + Vhi[jl][il+1]*xx*(1.0 - yy)*zz
>          + Vhi[jl+1][il]*(1.0 - xx)*yy*zz
>          + Vhi[jl+1][il+1]*xx*yy*zz;
480a509,510
> 
>   return v;
484,486c514,520
< void InputDataFree (void)
< /*!
<  * Free memory stored by user-supplied data.
---
> void InputDataReadSlice(int indx, int kslice)
> /*! 
>  * Read ::ID_NZ_MAX slices from disk starting at the kslice vertical
>  * index.
>  *
>  * \param [in] indx    the structure index (file handle)
>  * \param [in] kslice  the starting slice
490,494c524,573
<   int nv;
<   for (nv = 0; nv < id_nvar; nv++){
<     free ((char *) Vin[nv][0][0]);    
<     free ((char *) Vin[nv][0]);
<     free ((char *) Vin[nv]);
---
>   int i,j,k, kmax;
>   long int offset;
>   double udbl;
>   float  uflt;
>   inputData *id = id_stack + indx;
>   FILE *fp;
> 
> /* ----------------------------------------------------
>    1. Compute offset.
>       Here id->offset (in bytes) is the location of the
>       variable in the file, while the second number is
>       the vertical slice we want to read.
>       Seek from beginning of the file.
>    ---------------------------------------------------- */
> 
>   offset = id->offset + kslice*id->dsize*id->nx1*id->nx2;
> 
>   fp = fopen(id->fname,"rb");
>   fseek(fp, offset, SEEK_SET);
> 
> /* -----------------------------------------------------
>    2. Read binary data at specified position.
>    ----------------------------------------------------- */
>    
>   kmax = MIN(id->nx3,ID_NZ_MAX);
>   if (id->dsize == sizeof(double)){
> 
>     for (k = 0; k < kmax   ; k++){   /* Read at most 2 planes */  
>     for (j = 0; j < id->nx2; j++){
>     for (i = 0; i < id->nx1; i++){
>       if (fread (&udbl, id->dsize, 1, fp) != 1){  
>         print ("! InputDataReadSlice(): error reading data (indx = %d)\n",indx);
>         break;
>       }
>       if (id->swap_endian) SWAP_VAR(udbl);
>       id->Vin[k][j][i] = udbl;
>     }}}
> 
>    }else{
> 
>     for (k = 0; k < kmax   ; k++){   /* Read at most 2 planes */  
>     for (j = 0; j < id->nx2; j++){
>     for (i = 0; i < id->nx1; i++){
>       if (fread (&uflt, id->dsize, 1, fp) != 1){
>         print ("! InputDataReadSlice(): error reading data (indx = %d)\n",indx);
>         break;
>       }
>       if (id->swap_endian) SWAP_VAR(uflt);
>       id->Vin[k][j][i] = (double)uflt;
>     }}}
496d574
< }
497a576,588
> /* -- Update last successfully read slice -- */
> 
>   id->klast = kslice;
>   fclose(fp);
> /*
> print ("@@@ Offset = %d\n",offset);
> for (k = 0; k < kmax   ; k++){
> for (j = 0; j < id->nx2; j++){
> for (i = 0; i < id->nx1; i++){
>   print ("@@@ Input value (%d %d %d) = %f\n",i,j,k,id->Vin[k][j][i]);
> }}}
> */
> }
diff Src/int_bound_reset.c ../old/int_bound_reset.c
17c17
< void InternalBoundaryReset (const State_1D *state, Time_Step *Dts, 
---
> void InternalBoundaryReset (const Sweep *sweep, timeStep *Dts, 
21c21
<  * \param [in,out]  state  pointer to State_1D structure
---
>  * \param [in,out]  sweep  pointer to Sweep structure
34,35c34,35
<     if (state->flag[i] & FLAG_INTERNAL_BOUNDARY){
<       NVAR_LOOP(nv) state->rhs[i][nv] = 0.0;
---
>     if (sweep->flag[i] & FLAG_INTERNAL_BOUNDARY){
>       NVAR_LOOP(nv) sweep->rhs[i][nv] = 0.0;
diff Src/jet_domain.c ../old/jet_domain.c
20c20
<   \date   Dec 24, 2014
---
>   \date   Feb 28, 2017
38c38
<  * \param [in,out]  grid   pointer to array of Grid structures
---
>  * \param [in,out]  grid   pointer to Grid structure
54c54
<   ngh = grid[dir].nghost;
---
>   ngh = grid->nghost[dir];
71c71
<     rbound = grid[dir].rbound;
---
>     rbound = grid->rbound[dir];
92c92
< /*    print1 ("- SetJetDomain: index %d / %d\n",n,jd_nend); */
---
> /*    print ("- SetJetDomain: index %d / %d\n",n,jd_nend); */
102c102
<     IEND = grid[IDIR].lend = n;
---
>     IEND = grid->lend[IDIR] = n;
106,107c106,107
<     grid[IDIR].rbound = rbound;
<     if (jd_nend != IEND) grid[IDIR].rbound = 0;  
---
>     grid->rbound[IDIR] = rbound;
>     if (jd_nend != IEND) grid->rbound[IDIR] = 0;
111c111
<     JEND = grid[JDIR].lend = n;
---
>     JEND = grid->lend[JDIR] = n;
114,115c114,115
<     grid[JDIR].rbound = rbound;
<     if (jd_nend != JEND) grid[JDIR].rbound = 0;  
---
>     grid->rbound[JDIR] = rbound;
>     if (jd_nend != JEND) grid->rbound[JDIR] = 0;
119c119
<     KEND = grid[KDIR].lend = n;
---
>     KEND = grid->lend[KDIR] = n;
123,124c123,124
<     grid[KDIR].rbound = rbound;
<     if (jd_nend != KEND) grid[KDIR].rbound = 0;  
---
>     grid->rbound[KDIR] = rbound;
>     if (jd_nend != KEND) grid->rbound[KDIR] = 0;  
127,150d126
< /* ------------------------------------------------------
<     Recompute RBox(es) after indices have been changed
<    ------------------------------------------------------ */
< 
<   SetRBox();
< 
< /*
<   print1 ("Box = %d/%d\n", n, jd_nend);
<   {
<     double t0, t1, i0, i1;
<     FILE *fp;
<     t0 = g_time;
<     t1 = t0 + g_dt;
<     i0 = (int)(t0/0.5);
<     i1 = (int)(t1/0.5);
< 
<     if (i0 != i1){
<       fp = fopen("box.out","w");
<       fprintf (fp,"%f  %f  %f  %f\n",0.0, grid[IDIR].x[IEND], 
<                                      0.0, grid[JDIR].x[JEND]);
<       fclose(fp);
<     } 
<   }
< */
162,163c138,139
<     IBEG = grid[IDIR].lbeg = jd_nbeg;
<     IEND = grid[IDIR].lend = jd_nend;
---
>     IBEG = grid->lbeg[IDIR] = jd_nbeg;
>     IEND = grid->lend[IDIR] = jd_nend;
166c142
<     grid[IDIR].rbound = rbound;
---
>     grid->rbound[IDIR] = rbound;
170,171c146,147
<     JBEG = grid[JDIR].lbeg = jd_nbeg;
<     JEND = grid[JDIR].lend = jd_nend;
---
>     JBEG = grid->lbeg[JDIR] = jd_nbeg;
>     JEND = grid->lend[JDIR] = jd_nend;
174c150
<     grid[JDIR].rbound = rbound;
---
>     grid->rbound[JDIR] = rbound;
178,179c154,155
<     KBEG = grid[KDIR].lbeg = jd_nbeg;
<     KEND = grid[KDIR].lend = jd_nend;
---
>     KBEG = grid->lbeg[KDIR] = jd_nbeg;
>     KEND = grid->lend[KDIR] = jd_nend;
182c158
<     grid[KDIR].rbound = rbound;
---
>     grid->rbound[KDIR] = rbound;
185,190d160
< /* ------------------------------------------------------
<     Recompute RBox(es) after indices have been changed
<    ------------------------------------------------------ */
< 
<   SetRBox();
< 
diff Src/macros.h ../old/macros.h
7c7
<   \date   July 31, 2014
---
>   \date   June 15, 2017
10a11,37
> #ifndef DEBUG
>   #define DEBUG FALSE
> #endif
> 
> #if DEBUG == TRUE
>   #define DEBUG_FUNC_BEG(a)                          \
>     char d_funcName[64];                             \
>     sprintf (d_funcName,"%s",a);                     \
>     d_indent += 2;                                   \
>     if (d_condition) { print("%*c", d_indent, ' ');  \
>                        print (">>[%s]\n",a );  }
> 
>   #define DEBUG_FUNC_END(a)  \
>     if (d_condition) {print("%*c", d_indent, ' ');  \
>                      print("<<[%s]\n",a ); }        \
>      d_indent -= 2;                           
>   
>   #define DEBUG_FUNC_NAME  d_funcName
> 
> #else
>   #define DEBUG_FUNC_BEG(a)
>   #define DEBUG_FUNC_END(a)
>   #define DEBUG_FUNC_NAME "Not Set"
> #endif
>   
>   
> 
54,59d80
< #define TRANSVERSE_LOOP(indx, ip, i,j,k) \
<  if (g_dir == IDIR) {ip = &i; indx.pt1 = &j; indx.pt2 = &k;}  \
<  if (g_dir == JDIR) {ip = &j; indx.pt1 = &i; indx.pt2 = &k;}  \
<  if (g_dir == KDIR) {ip = &k; indx.pt1 = &i; indx.pt2 = &j;}  \
<  for (*(indx.pt2) = indx.t2_beg; *(indx.pt2) <= indx.t2_end; *(indx.pt2) += 1) \
<  for (*(indx.pt1) = indx.t1_beg; *(indx.pt1) <= indx.t1_end; *(indx.pt1) += 1)
71,77c92,116
<  for ((B)->dk = ((k=(B)->kb) <= (B)->ke ? 1:-1); k != (B)->ke+(B)->dk; k += (B)->dk)\
<  for ((B)->dj = ((j=(B)->jb) <= (B)->je ? 1:-1); j != (B)->je+(B)->dj; j += (B)->dj)\
<  for ((B)->di = ((i=(B)->ib) <= (B)->ie ? 1:-1); i != (B)->ie+(B)->di; i += (B)->di)
< 
< /*! The FOR_EACH(p, beg, intList) macro implements a loop over the
<     elements of the array \c intList->indx starting at \c beg (in a
<     similar way to Python lists).
---
>  for ((B)->dk = ((k=(B)->kbeg) <= (B)->kend ? 1:-1); k != (B)->kend+(B)->dk; k += (B)->dk)\
>  for ((B)->dj = ((j=(B)->jbeg) <= (B)->jend ? 1:-1); j != (B)->jend+(B)->dj; j += (B)->dj)\
>  for ((B)->di = ((i=(B)->ibeg) <= (B)->iend ? 1:-1); i != (B)->iend+(B)->di; i += (B)->di)
> 
> 
> #define IBOX_LOOP(B,i) \
>  for ((B)->di = ((i=(B)->ibeg) <= (B)->iend ? 1:-1); i != (B)->iend+(B)->di; i += (B)->di)
> 
> #define JBOX_LOOP(B,j) \
>  for ((B)->dj = ((j=(B)->jbeg) <= (B)->jend ? 1:-1); j != (B)->jend+(B)->dj; j += (B)->dj)
> 
> #define KBOX_LOOP(B,k) \
>  for ((B)->dk = ((k=(B)->kbeg) <= (B)->kend ? 1:-1); k != (B)->kend+(B)->dk; k += (B)->dk)
> 
> 
> #define BOX_TRANSVERSE_LOOP(box,k,j,i)                                     \
>   if      (g_dir == IDIR) {(box)->n = &i; (box)->t = &j; (box)->b = &k;}   \
>   else if (g_dir == JDIR) {(box)->n = &j; (box)->t = &i; (box)->b = &k;}   \
>   else if (g_dir == KDIR) {(box)->n = &k; (box)->t = &i; (box)->b = &j;}   \
>   for (*((box)->b) = *(box)->bbeg; *((box)->b) <= *(box)->bend; *((box)->b) +=1) \
>   for (*((box)->t) = *(box)->tbeg; *((box)->t) <= *(box)->tend; *((box)->t) +=1)
> 
> 
> /*! The FOR_EACH(p, intList) macro implements a loop over the elements
>     of the array \c intList->indx (in a similar way to Python lists).
86c125
<       FOR_EACH(nv, 0, list) printf ("value is = %d\n",nv);
---
>       FOR_EACH(nv, &list) printf ("value is = %d\n",nv);
89,90c128,129
< #define FOR_EACH(nv, beg, list)  \
<   for ((list)->i = beg, nv = (list)->indx[beg]; \
---
> #define FOR_EACH(nv, list)  \
>   for ((list)->i = 0, nv = (list)->indx[0]; \
117a157,160
> /* See
> http://stackoverflow.com/questions/11303135/broadcast-message-for-all-processes-to-exitmpi
> */
> 
120c163,164
<         {MPI_Abort(MPI_COMM_WORLD, e_code);MPI_Finalize(); exit(e_code);}
---
>         {print ("! abort\n"); MPI_Abort(MPI_COMM_WORLD, e_code); \
>          MPI_Finalize(); exit(e_code);}
228a273,285
> /*! \name Forward and central finite differences macros.
>     The following set of macros provide a compact way to perform 
>     two-point, undivided finite difference operations in a specified
>     direction.
>     Differences can be either \c forward or \c central.
>     For instance, \c FDIFF_X2(Q,k,j,i) will compute a forward
>     difference of \c Q in the \c y direction, \c (Q[j+1]-Q[j]), while
>     \c CDIFF_X3(Q,k,j,i) will compute a central different approximation
>     of \c Q in the \c z direction: \c (Q[k+1] - Q[k-1])/2.
> */
> /**@{ */
> #define FDIFF_X1(Q,k,j,i)     (Q[k][j][i+1] - Q[k][j][i])
> #define CDIFF_X1(Q,k,j,i) (0.5*(Q[k][j][i+1] - Q[k][j][i-1]))
229a287
> #if DIMENSIONS == 1
231,242c289,290
< /* -- some new macros.
<    CDIFF: Central DIFFerencing
<    FDIFF: Forward DIFFerencing
<    
< */
<  #define FDIFF_X1(b,k,j,i) (b[k][j][i+1] - b[k][j][i])
<  #define FDIFF_X2(b,k,j,i) (b[k][j+1][i] - b[k][j][i])
<  #define FDIFF_X3(b,k,j,i) (b[k+1][j][i] - b[k][j][i])
< 
<  #define CDIFF_X1(b,k,j,i) 0.5*(b[k][j][i+1] - b[k][j][i-1])
<  #define CDIFF_X2(b,k,j,i) 0.5*(b[k][j+1][i] - b[k][j-1][i])
<  #define CDIFF_X3(b,k,j,i) 0.5*(b[k+1][j][i] - b[k-1][j][i])
---
>  #define FDIFF_X2(Q,k,j,i)  (0.0)
>  #define CDIFF_X2(Q,k,j,i)  (0.0)
244c292,293
< /* -- in 2D we set the derivative with respect to the third coordinate = 0 */
---
>  #define FDIFF_X3(Q,i,j,k)  (0.0)
>  #define CDIFF_X3(Q,i,j,k)  (0.0)
246,248c295
< #if DIMENSIONS == 2
<  #undef CDIFF_X3
<  #undef FDIFF_X3
---
> #elif DIMENSIONS == 2
250,252c297,298
<  #define CDIFF_X3(b,i,j,k)  0.0
<  #define FDIFF_X3(b,i,j,k)  0.0
< #endif
---
>  #define FDIFF_X2(Q,k,j,i)      (Q[k][j+1][i] - Q[k][j][i])
>  #define CDIFF_X2(Q,k,j,i) (0.5*(Q[k][j+1][i] - Q[k][j-1][i]))
254c300,301
< /* ---- define average macros ---- */
---
>  #define CDIFF_X3(Q,i,j,k)  0.0
>  #define FDIFF_X3(Q,i,j,k)  0.0
256,258c303
< #define AVERAGE_X(q,k,j,i)   0.5*(q[k][j][i] + q[k][j][i+1])
< #define AVERAGE_Y(q,k,j,i)   0.5*(q[k][j][i] + q[k][j+1][i])
< #define AVERAGE_Z(q,k,j,i)   0.5*(q[k][j][i] + q[k+1][j][i])
---
> #elif DIMENSIONS == 3
260,265c305,306
< #define AVERAGE_XY(q,k,j,i)   0.25*(  q[k][j][i]   + q[k][j][i+1] \
<                                     + q[k][j+1][i] + q[k][j+1][i+1])
< #define AVERAGE_XZ(q,k,j,i)   0.25*(  q[k][j][i]   + q[k][j][i+1] \
<                                     + q[k+1][j][i] + q[k+1][j][i+1])
< #define AVERAGE_YZ(q,k,j,i)   0.25*(  q[k][j][i]   + q[k][j+1][i] \
<                                     + q[k+1][j][i] + q[k+1][j+1][i])
---
>  #define FDIFF_X2(Q,k,j,i)      (Q[k][j+1][i] - Q[k][j][i])
>  #define CDIFF_X2(Q,k,j,i) (0.5*(Q[k][j+1][i] - Q[k][j-1][i]))
267c308,323
< /* -- re-define the macros for 1 or 2 dimensions -- */
---
>  #define FDIFF_X3(Q,k,j,i)      (Q[k+1][j][i] - Q[k][j][i])
>  #define CDIFF_X3(Q,k,j,i) (0.5*(Q[k+1][j][i] - Q[k-1][j][i]))
> 
> #endif
> /**@} */
> 
> /*! \name Spatial averages macros.
>     The following set of macros provide a compact way to perform multi-D
>     averages from cell centered values to interfaces.
>     For instance, \C AVERAGE_X(q,k,j,i) will simply take the
>     arithmetic average betwen q(i) and q(i+1) at the i+1/2 interface.
>     Likewise, AVERAGE_YZ(q,k,j,i) will produce an average at the
>     j+1/2 and k+1/2 edge.
> */
> /**@{ */
> #define AVERAGE_X(q,k,j,i)   (0.5*(q[k][j][i] + q[k][j][i+1]))
271,272c327,328
<  #undef AVERAGE_Y
<  #undef AVERAGE_Z
---
>   #define AVERAGE_Y(q,k,j,i)    (q[0][0][i])
>   #define AVERAGE_Z(q,k,j,i)    (q[0][0][i])
274,283c330,334
<  #undef AVERAGE_XY
<  #undef AVERAGE_XZ
<  #undef AVERAGE_YZ
< 
<  #define AVERAGE_Y(q,k,j,i)    (q[0][0][i])
<  #define AVERAGE_Z(q,k,j,i)    (q[0][0][i])
< 
<  #define AVERAGE_XY(q,k,j,i)   AVERAGE_X(q,0,0,i)
<  #define AVERAGE_XZ(q,k,j,i)   AVERAGE_X(q,0,0,i)
<  #define AVERAGE_YZ(q,k,j,i)   (q[0][0][i])
---
>   #define AVERAGE_XY(q,k,j,i)   AVERAGE_X(q,0,0,i)
>   #define AVERAGE_XZ(q,k,j,i)   AVERAGE_X(q,0,0,i)
>   #define AVERAGE_YZ(q,k,j,i)   (q[0][0][i])
>  
>   #define AVERAGE_XYZ(q,k,j,i)  0.5*(q[0][0][i] + q[0][0][i+1])
287,293d337
<  #undef AVERAGE_Z
<  #undef AVERAGE_XZ
<  #undef AVERAGE_YZ
< 
<  #define AVERAGE_Z(q,k,j,i)    (q[0][j][i])
<  #define AVERAGE_XZ(q,k,j,i)   0.5*(q[0][j][i] + q[0][j][i+1])
<  #define AVERAGE_YZ(q,k,j,i)   0.5*(q[0][j][i] + q[0][j+1][i])
294a339,364
>   #define AVERAGE_Y(q,k,j,i)   (0.5*(q[k][j][i] + q[k][j+1][i]))
>   #define AVERAGE_Z(q,k,j,i)    (q[0][j][i])
> 
>   #define AVERAGE_XY(q,k,j,i)   ( 0.25*(  q[k][j][i]   + q[k][j][i+1] \
>                                         + q[k][j+1][i] + q[k][j+1][i+1]) )
>   #define AVERAGE_XZ(q,k,j,i)   (0.5*(q[0][j][i] + q[0][j][i+1]))
>   #define AVERAGE_YZ(q,k,j,i)   (0.5*(q[0][j][i] + q[0][j+1][i]))
> 
>   #define AVERAGE_XYZ(q,k,j,i)  (0.25*(  q[0][j][i]   + q[0][j][i+1]        \
>                                        + q[0][j+1][i] + q[0][j+1][i+1]))
> 
> #elif DIMENSIONS == 3
> 
>   #define AVERAGE_Y(q,k,j,i)   (0.5*(q[k][j][i] + q[k][j+1][i]))
>   #define AVERAGE_Z(q,k,j,i)   (0.5*(q[k][j][i] + q[k+1][j][i]))
> 
>   #define AVERAGE_XY(q,k,j,i)  (0.25*(  q[k][j][i]   + q[k][j][i+1] \
>                                        + q[k][j+1][i] + q[k][j+1][i+1]) )
>   #define AVERAGE_XZ(q,k,j,i)  (0.25*(  q[k][j][i]   + q[k][j][i+1] \
>                                        + q[k+1][j][i] + q[k+1][j][i+1]) )
>   #define AVERAGE_YZ(q,k,j,i)  (0.25*(  q[k][j][i]   + q[k][j+1][i] \
>                                        + q[k+1][j][i] + q[k+1][j+1][i]) )
>   #define AVERAGE_XYZ(q,k,j,i) (0.125*(  q[k][j][i]   + q[k][j][i+1]        \
>                                        + q[k][j+1][i] + q[k][j+1][i+1]      \
>                                        + q[k+1][j][i]   + q[k+1][j][i+1]    \
>                                        + q[k+1][j+1][i] + q[k+1][j+1][i+1]))
295a366
> /**@} */
diff Src/main.c ../old/main.c
11c11
<   the actual integration, GetNextTimeStep() responsible for computing the
---
>   the actual integration, NextTimeStep() responsible for computing the
15,18c15
<   We use two slightly different integration loops depending on whether
<   asnchrounous I/O has to be performed (macro USE_ASYNC_IO).
<   If the macro USE_ASYNC_IO is not defined, the standard 
<   integration loop consists of the following steps:
---
>   The standard integration loop consists of the following steps:
27c24
<    - [MPI] Get next time step dt(n+1)
---
>    - Get next time step dt(n+1)
31,44d27
<   Otherwise, using Asynchrounous I/O:
<  
<    - Check for last step & adjust dt
<    - check for output/analysis:   t(n) < tout < t(n+1)
<      - Write data/call analysis using {U(n), t(n), dt(n)}
<    - [MPI] Show dominant time step (n-1)
<    - [MPI] reduction operations (n-1)
<    - [AIO]: finish writing
<    - Dump log information, n, t(n), dt(n), MAX_MACH(n-1), etc..
<    - Advance solution using dt(n), U(n) --> U(n+1)
<    - Increment t(n+1) = t(n) + dt(n)
<    - [MPI] Get next time step dt(n)
<    - Increment n --> n+1
< 
46c29
<   \date   Aug 16, 2012
---
>   \date   April 9, 2018
53,54c36,39
<   #define SHOW_TIME_STEPS  NO   /* -- show time steps due to advection,
<                                        diffusion and cooling */
---
>   #define SHOW_TIME_STEPS  NO  /* Show time steps due to different processes */
> #endif
> #ifndef SHOW_TIMING
>   #define SHOW_TIMING      NO  /* Compute CPU timing between steps */
57c42
< static double NextTimeStep (Time_Step *, Runtime *, Grid *);
---
> static double NextTimeStep (timeStep *, Runtime *, Grid *);
59,60c44,45
< static int Integrate (Data *, Riemann_Solver *, Time_Step *, Grid *);
< static void CheckForOutput (Data *, Runtime *, Grid *);
---
> static int Integrate (Data *, Riemann_Solver *, timeStep *, Grid *);
> static void CheckForOutput (Data *, Runtime *, time_t, Grid *);
79c64,65
<   time_t  tbeg, tend;
---
>   clock_t clock_beg, clock_end; /* measures CPU time */
>   time_t  tbeg, tend;           /* measures the real time */
82c68
<   Time_Step Dts;
---
>   timeStep Dts;
86,87d71
<   double *dbl_pnt;
<   int    *int_pnt;
89,92c73,80
<   #ifdef PARALLEL
<    AL_Init (&argc, &argv);
<    MPI_Comm_rank (MPI_COMM_WORLD, &prank);
<   #endif
---
> /* --------------------------------------------------------
>    0. Initialize environment
>    -------------------------------------------------------- */
> 
> #ifdef PARALLEL
>   AL_Init (&argc, &argv);
>   MPI_Comm_rank (MPI_COMM_WORLD, &prank);
> #endif
93a82
>   time (&tbeg);
96,122c85,87
<   print1 ("> Basic data type:\n");
<   print1 ("  sizeof (char)     = %d\n", sizeof(char));
<   print1 ("  sizeof (uchar)    = %d\n", sizeof(unsigned char));
<   print1 ("  sizeof (short)    = %d\n", sizeof(short));
<   print1 ("  sizeof (ushort)   = %d\n", sizeof(unsigned short));
<   print1 ("  sizeof (int)      = %d\n", sizeof(int));
<   print1 ("  sizeof (*int)     = %d\n", sizeof(int_pnt));
<   print1 ("  sizeof (float)    = %d\n", sizeof(float));
<   print1 ("  sizeof (double)   = %d\n", sizeof(double));
<   print1 ("  sizeof (*double)  = %d\n", sizeof(dbl_pnt));
<   
< /*
<   print1 ("\n> Structure data type:\n");
<   print1 ("  sizeof (CMD_LINE)   = %d\n", sizeof(Cmd_Line));
<   print1 ("  sizeof (DATA)       = %d\n", sizeof(Data));
<   print1 ("  sizeof (STATE_1D)   = %d\n", sizeof(State_1D));
<   print1 ("  sizeof (GRID)       = %d\n", sizeof(Grid));
<   print1 ("  sizeof (TIME_STEP)  = %d\n", sizeof(Time_Step));
<   print1 ("  sizeof (OUTPUT)     = %d\n", sizeof(Output));
<   print1 ("  sizeof (RUNTIME)    = %d\n", sizeof(Runtime));
<   print1 ("  sizeof (RESTART)    = %d\n", sizeof(Restart));
<   print1 ("  sizeof (RGB)        = %d\n", sizeof(RGB));
<   print1 ("  sizeof (IMAGE)      = %d\n", sizeof(Image));
<   print1 ("  sizeof (FLOAT_VECT) = %d\n", sizeof(Float_Vect));
<   print1 ("  sizeof (INDEX)      = %d\n", sizeof(Index));
<   print1 ("  sizeof (RBOX)       = %d\n", sizeof(RBox));
< */
---
>   data.Dts = &Dts;
> 
> /* -- 0a. Initialize members of timeStep structure -- */
124c89,101
< /* -- initialize members of Time_Step structure -- */
---
>   Dts.cmax      = ARRAY_1D(NMAX_POINT, double);
>   Dts.invDt_hyp = 0.0;
>   Dts.invDt_par = 0.5e-38; 
>   Dts.dt_cool   = 1.e38;
>   Dts.cfl       = ini.cfl;
>   Dts.cfl_par   = ini.cfl_par;
>   Dts.rmax_par  = ini.rmax_par;
>   Dts.Nsts      = Dts.Nrkc = Dts.Nrkl = 0;
> #if (defined PARTICLES) && (PARTICLES_TYPE == COSMIC_RAYS)
>   Dts.Nsub_particles  = MAX(1, -PARTICLES_CR_NSUB);
> #else
>   Dts.Nsub_particles = 1;
> #endif
126,133c103
<   Dts.cmax     = ARRAY_1D(NMAX_POINT, double);
<   Dts.inv_dta  = 0.0;
<   Dts.inv_dtp  = 0.5e-38; 
<   Dts.dt_cool  = 1.e38;
<   Dts.cfl      = ini.cfl;
<   Dts.cfl_par  = ini.cfl_par;
<   Dts.rmax_par = ini.rmax_par;
<   Dts.Nsts     = Dts.Nrkc = 0;
---
>   Dts.invDt_particles = 1.0/ini.first_dt;
137d106
<   time (&tbeg);
141,142c110,111
<     Check if restart is necessary. 
<     If not, write initial condition to disk.
---
>    1. Check if restart is necessary. 
>       If not, write initial condition to disk.
144c113
<    
---
>   
146a116,118
>     #ifdef PARTICLES
>     Particles_Restart(&data, cmd_line.nrestart, grd);
>     #endif
150c122
<     CheckForOutput (&data, &ini, grd);
---
>     CheckForOutput (&data, &ini, tbeg, grd);
152,154d123
<     #ifdef USE_ASYNC_IO
<      Async_EndWriteData (&ini);
<     #endif
157c126,127
<   print1 ("> Starting computation... \n\n");
---
>   if (cmd_line.maxsteps == 0) last_step = 1;
>   print ("> Starting computation... \n\n");  
160c130
<           M A I N      L O O P      S T A R T S      H E R E
---
>    2.  M A I N      L O O P      S T A R T S      H E R E
163,164d132
< #ifndef USE_ASYNC_IO  /* -- Standard loop, don't use Asynchrouns I/O -- */
< 
166a135,138
>     #if SHOW_TIMING
>     clock_beg = clock();
>     #endif
> 
168,170c140,142
<       Check if this is the last integration step:
<       - final tstop has been reached: adjust time step 
<       - or max number of steps has been reached
---
>      2a. Check if this is the last integration step:
>          - final tstop has been reached: adjust time step 
>          - or max number of steps has been reached
174c146
<       g_dt   = (ini.tstop - g_time);
---
>       g_dt      = (ini.tstop - g_time);
177c149
<     if (g_stepNumber == cmd_line.maxsteps && cmd_line.maxsteps > 0) {
---
>     if (g_stepNumber == cmd_line.maxsteps && cmd_line.maxsteps >= 0) {
182c154
<                 Dump log information
---
>      2b. Update log file
185,201c157
<     if (g_stepNumber%ini.log_freq == 0) {
<       print1 ("step:%d ; t = %10.4e ; dt = %10.4e ; %d %% ; [%f, %d",
<                g_stepNumber, g_time, g_dt, (int)(100.0*g_time/ini.tstop), 
<                g_maxMach, g_maxRiemannIter);
< /*      if (g_maxRootIter > 0) print1 (", root it. # = %d",g_maxRootIter);  */
<       #if (PARABOLIC_FLUX & SUPER_TIME_STEPPING)
<        print1 (", Nsts = %d",Dts.Nsts);
<       #endif
<       #if (PARABOLIC_FLUX & RK_CHEBYSHEV)
<        print1 (", Nrkc = %d",Dts.Nrkc);
<       #endif
<       print1 ("]\n");      
<     }
< 
<   /* ------------------------------------------------------
<        check if it's time to write or perform analysis
<      ------------------------------------------------------ */
---
>     if (g_stepNumber%ini.log_freq == 0) OutputLogPre(&data, &Dts, &ini, grd);
202a159,162
>   /* ----------------------------------------------------
>      2c. Check if it's time to write or perform analysis
>      ---------------------------------------------------- */
>      
204c164
<       CheckForOutput  (&data, &ini, grd);
---
>       CheckForOutput  (&data, &ini, tbeg, grd);
208,211c168,171
<   /* ------------------------------------------------------
<       Advance solution array by a single time step
<       g_dt = dt(n)
<      ------------------------------------------------------ */
---
>   /* ----------------------------------------------------
>      2d. Advance solution array by a single time step
>          g_dt = dt(n). After this step U^n -> U^{n+1}
>      ---------------------------------------------------- */
217,220c177,180
<   /* ------------------------------------------------------
<        Integration didn't go through. Step must
<        be redone from previously saved solution.
<      ------------------------------------------------------ */
---
>   /* ----------------------------------------------------
>      2e. Integration didn't go through. Step must
>          be redone from previously saved solution.
>      ---------------------------------------------------- */
223c183
<       print1 ("! Step failed. Re-trying\n");
---
>       print ("! Step failed. Re-trying\n");
231,280c191
<       Increment time, t(n+1) = t(n) + dt(n)
<      ------------------------------------------------------ */
< 
<     g_time += g_dt;
< 
<   /* ------------------------------------------------------
<       Show the time step ratios between the actual g_dt
<       and the advection, diffusion and cooling time scales.
<      ------------------------------------------------------ */
< 
<     #if SHOW_TIME_STEPS == YES
<      if (g_stepNumber%ini.log_freq == 0) {
<        double cg, dta, dtp, dtc;
<        dta = 1.0/Dts.inv_dta;
<        dtp = 0.5/Dts.inv_dtp;
<        dtc = Dts.dt_cool;
<        #ifdef PARALLEL
<         MPI_Allreduce (&dta, &cg, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<         dta = cg;
< 
<         MPI_Allreduce (&dtp, &cg, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<         dtp = cg;
< 
<         MPI_Allreduce (&dtc, &cg, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<         dtc = cg;
<        #endif
<        /*
<    print1 ("[dt/dt(adv) = %10.4e, dt/dt(par) = %10.4e, dt/dt(cool) = %10.4e]\n",
<                 g_dt/dta, g_dt/dtp, g_dt/dtc);
<                 */
<        print1 ("  dt(adv)  = cfl x %10.4e;\n",dta);
<        print1 ("  dt(par)  = cfl x %10.4e;\n",dtp);
<        print1 ("  dt(cool) =       %10.4e;\n",dtc);
<      }
<     #endif
< 
<   /* ------------------------------------------------------
<       Get next time step dt(n+1).
<       Do it every two steps if cooling or dimensional
<       splitting are used.
<      ------------------------------------------------------ */
< 
<     #if (COOLING == NO) && ((DIMENSIONS == 1) || (DIMENSIONAL_SPLITTING == NO))
<       g_dt = NextTimeStep(&Dts, &ini, grd);
<     #else
<      if (g_stepNumber%2 == 1) g_dt = NextTimeStep(&Dts, &ini, grd);
<     #endif
< 
<   /* ------------------------------------------------------
<           Global MPI reduction operations
---
>      2h. Global MPI reduction operations
284,286c195,196
<      MPI_Allreduce (&g_maxMach, &scrh, 1, 
<                     MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<      g_maxMach = scrh;
---
>     MPI_Allreduce (&g_maxMach, &scrh, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
>     g_maxMach = scrh;
288,292c198,199
<      MPI_Allreduce (&g_maxRiemannIter, &nv, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
<      g_maxRiemannIter = nv;
<     #endif
< 
<     g_stepNumber++;
---
>     MPI_Allreduce (&g_maxRiemannIter, &nv, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
>     g_maxRiemannIter = nv;
294,347c201,203
<     first_step = 0;
<   }
< 
< #else /* Use Asynchrounous I/O */
< 
<   while (!last_step){
< 
<   /* ------------------------------------------------------
<       Check if this is the last integration step:
<       - final tstop has been reached: adjust time step 
<       - or max number of steps has been reached
<      ------------------------------------------------------ */
< 
<     if ((g_time + g_dt) >= ini.tstop*(1.0 - 1.e-8)) {
<       g_dt   = (ini.tstop - g_time);
<       last_step = 1;
<     }
<     if (g_stepNumber == cmd_line.maxsteps && cmd_line.maxsteps > 0) {
<       last_step = 1;
<     }
< 
<   /* ------------------------------------------------------
<        check if it's time to write or perform analysis
<      ------------------------------------------------------ */
< 
<     if (!first_step && !last_step && cmd_line.write) {
<       CheckForOutput  (&data, &ini, grd);
<       CheckForAnalysis(&data, &ini, grd);
<     }
< 
<   /* ------------------------------------------------------
<       Show the time step ratios between the actual g_dt
<       and the advection, diffusion and cooling time scales.
<      ------------------------------------------------------ */
< 
<     #if SHOW_TIME_STEPS == YES
<      if (!first_step && g_stepNumber%ini.log_freq == 0) {
<        double cg, dta, dtp, dtc;
<        dta = 1.0/Dts.inv_dta;
<        dtp = 0.5/Dts.inv_dtp;
<        dtc = Dts.dt_cool;
<        #ifdef PARALLEL
<         MPI_Allreduce (&dta, &cg, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<         dta = cg;
< 
<         MPI_Allreduce (&dtp, &cg, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<         dtp = cg;
< 
<         MPI_Allreduce (&dtc, &cg, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<         dtc = cg;
<        #endif
<        print1 ("\t[dt/dta = %10.4e, dt/dtp = %10.4e, dt/dtc = %10.4e \n",
<                 g_dt/dta, g_dt/dtp, g_dt/dtc);
<      }
---
>     #if (PHYSICS == RMHD) && (RESISTIVITY != NO)
>     MPI_Allreduce (&g_maxIMEXIter, &nv, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
>     g_maxIMEXIter = nv;
349,360d204
< 
<   /* ------------------------------------------------------
<           Global MPI reduction operations
<      ------------------------------------------------------ */
<   
<     #ifdef PARALLEL
<      MPI_Allreduce (&g_maxMach, &scrh, 1, 
<                     MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<      g_maxMach = scrh;
< 
<      MPI_Allreduce (&g_maxRiemannIter, &nv, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
<      g_maxRiemannIter = nv;
363,365c207,209
<   /* ------------------------------------------------------
<              Finish writing using Async I/O
<      ------------------------------------------------------ */
---
>     if (g_stepNumber%ini.log_freq == 0) {
>       OutputLogPost(&data, &Dts, &ini, grd);
>     }
367,369c211,213
<     #ifdef USE_ASYNC_IO
<      Async_EndWriteData (&ini);
<     #endif
---
>   /* ----------------------------------------------------
>      2f. Increment time, t(n+1) = t(n) + dt(n)
>      ---------------------------------------------------- */ 
371,373c215
<   /* ------------------------------------------------------
<                 Dump log information
<      ------------------------------------------------------ */
---
>     g_time += g_dt;
374a217,218
>     #if SHOW_TIMING
>     clock_end = clock();
376,383c220,224
<       print1 ("step:%d ; t = %10.4e ; dt = %10.4e ; %d %% ; [%f, %d",
<                g_stepNumber, g_time, g_dt, (int)(100.0*g_time/ini.tstop), 
<                g_maxMach, g_maxRiemannIter);
<       #if (PARABOLIC_FLUX & SUPER_TIME_STEPPING)
<        print1 (", Nsts = %d",Dts.Nsts);
<       #endif
<       #if (PARABOLIC_FLUX & RK_CHEBYSHEV)
<        print1 (", Nrkc = %d",Dts.Nrkc);
---
>       scrh = (double)(clock_end - clock_beg)/CLOCKS_PER_SEC;
>       print("%s [clock (total)         = %f (s)]\n",IndentString(), scrh);
>       print("%s [clock (AdvanceStep()) = %f (s)]\n",IndentString(),Dts.clock_hyp);
>       #ifdef PARTICLES 
>       print("%s [clock (particles)     = %f (s)]\n",IndentString(),Dts.clock_particles);
385,406d225
<       print1 ("]\n");      
<     }
<     
<   /* ------------------------------------------------------
<       Advance solution array by a single time step
<       g_dt = dt(n)
<      ------------------------------------------------------ */
< 
<     if (cmd_line.jet != -1) SetJetDomain (&data, cmd_line.jet, ini.log_freq, grd); 
<     err = Integrate (&data, Solver, &Dts, grd);
<     if (cmd_line.jet != -1) UnsetJetDomain (&data, cmd_line.jet, grd); 
< 
<   /* ------------------------------------------------------
<        Integration didn't go through. Step must
<        be redone from previously saved solution.
<      ------------------------------------------------------ */
< /*
<     if (err != 0){
<       print1 ("! Step failed. Re-trying\n");
<       zones with problems must be tagged with MINMOD_FLAG and HLL_FLAG
<       time step should be halved
<       GET_SOL(&data);
408,413c227
< */
<   /* ------------------------------------------------------
<       Increment time, t(n+1) = t(n) + dt(n)
<      ------------------------------------------------------ */
< 
<     g_time += g_dt;
---
>     #endif
416c230,232
<                 Get next time step dt(n+1)
---
>      2g. Get next time step dt(n+1).
>          Do it every two steps if cooling or dimensional
>          splitting are used.
418a235
>     #if (COOLING == NO) && ((DIMENSIONS == 1) || (DIMENSIONAL_SPLITTING == NO))
419a237,240
>     #else
>     if (g_stepNumber%2 == 1) g_dt = NextTimeStep(&Dts, &ini, grd);
>     #endif
> 
423d243
< #endif /* USE_ASYNC_IO */
429,430c249,251
<   if (cmd_line.write){
<     CheckForOutput (&data, &ini, grd);
---
>   /*  Prevent double output when maxsteps == 0 */
>   if ((cmd_line.write) && !(cmd_line.maxsteps == 0)){
>     CheckForOutput (&data, &ini, tbeg, grd);
432,434d252
<     #ifdef USE_ASYNC_IO
<      Async_EndWriteData (&ini);
<     #endif
439c257
<    print1  ("\n> Total allocated memory  %6.2f Mb (proc #%d)\n",
---
>    print  ("\n> Total allocated memory  %6.2f Mb (proc #%d)\n",
443c261
<    print1  ("\n> Total allocated memory  %6.2f Mb\n",(float)g_usedMemory/1.e6);
---
>    print  ("\n> Total allocated memory  %6.2f Mb\n",(float)g_usedMemory/1.e6);
448,452c266,276
<   print1("> Elapsed time             %s\n", TotalExecutionTime(g_dt));
<   print1("> Average time/step       %10.2e  (sec)  \n", 
<           difftime(tend,tbeg)/(double)g_stepNumber);
<   print1("> Local time                %s",asctime(localtime(&tend)));
<   print1("> Done\n");
---
>   print("> Elapsed time             %s\n", TotalExecutionTime(g_dt));
> 
>   /*  Check if stepNumber = 0. 
>    *  Prevent NaN print at maxsteps = 0 */
>   if (g_stepNumber > 0)
>       print("> Average time/step       %10.2e  (sec)  \n", 
>            difftime(tend,tbeg)/(double)g_stepNumber);
>   else print("> Average time/step       %10.2e  (sec)  \n",difftime(tend,tbeg));
> 
>   print("> Local time                %s",asctime(localtime(&tend)));
>   print("> Done\n");
462,464c286,288
< #undef SHOW_TIME_STEPS
< /* ******************************************************************** */
< int Integrate (Data *d, Riemann_Solver *Solver, Time_Step *Dts, Grid *grid)
---
> 
> /* ********************************************************************* */
> int Integrate (Data *d, Riemann_Solver *Solver, timeStep *Dts, Grid *grid)
467c291
< 
---
>  *
475c299
<  ********************************************************************** */
---
>  *********************************************************************** */
477,480c301,304
<   int idim, err = 0;
<   int i,j,k;
<   
<   g_maxMach = 0.0;
---
>   int    idim, err = 0;
>   int    i,j,k;
> 
>   g_maxMach        = 0.0;
482a307,313
> 	
> #ifdef PARTICLES 
>   #if (PARTICLES_TEST == YES)
>   Particles_CR_Update (d, Dts, g_dt, grid);
>   return 0;
>   #endif
> #endif
484,486c315,317
< /* -------------------------------------------------------
<     Initialize max propagation speed in Dedner's approach
<    ------------------------------------------------------- */
---
> /* --------------------------------------------------------
>    1. Initialize max propagation speed in Dedner's approach
>    -------------------------------------------------------- */
488,491c319,322
<   #ifdef GLM_MHD  /* -- initialize glm_ch -- */
<    GLM_Init (d, Dts, grid);   
<    GLM_Source (d->Vc, 0.5*g_dt, grid);
<   #endif
---
> #ifdef GLM_MHD  /* -- initialize glm_ch -- */
>   GLM_Init (d, Dts, grid);   
>   GLM_Source (d->Vc, 0.5*g_dt, grid);
> #endif
493,496c324,327
<   /* ---------------------------------------------
<         perform Strang Splitting on directions 
<         (if necessary) and sources 
<      --------------------------------------------- */
---
> /* --------------------------------------------------------
>    2. Perform Strang Splitting on directions (if necessary)
>       and sources 
>    -------------------------------------------------------- */
500,502c331,334
<   #ifdef FARGO
<    FARGO_ComputeVelocity(d, grid);
<   #endif
---
> #ifdef FARGO
>   FARGO_ComputeVelocity(d, grid);
> #endif
>   
504c336
<     g_operatorStep = HYPERBOLIC_STEP;
---
>     g_hydroStep = TRUE;
506,508c338,340
<      for (g_dir = 0; g_dir < DIMENSIONS; g_dir++){
<        if (AdvanceStep (d, Solver, Dts, grid) != 0) return (1);
<      }
---
>     for (g_dir = 0; g_dir < DIMENSIONS; g_dir++){
>       if (AdvanceStep (d, Solver, Dts, grid) != 0) return (1);
>     }
510c342
<      if (AdvanceStep (d, Solver, Dts, grid) != 0) return(1);
---
>     if (AdvanceStep (d, Solver, Dts, grid) != 0) return(1);
512c344
<     g_operatorStep = PARABOLIC_STEP;
---
>     g_hydroStep = FALSE;
515c347
<     g_operatorStep = PARABOLIC_STEP;
---
>     g_hydroStep = FALSE;
517c349
<     g_operatorStep = HYPERBOLIC_STEP;
---
>     g_hydroStep = TRUE;
519,521c351,353
<      for (g_dir = DIMENSIONS - 1; g_dir >= 0; g_dir--){
<        if (AdvanceStep(d, Solver, Dts, grid) != 0) return (1);
<      }
---
>     for (g_dir = DIMENSIONS - 1; g_dir >= 0; g_dir--){
>       if (AdvanceStep(d, Solver, Dts, grid) != 0) return (1);
>     }
523c355
<      if (AdvanceStep (d, Solver, Dts, grid) != 0) return(1);
---
>     if (AdvanceStep (d, Solver, Dts, grid) != 0) return(1);
527,529c359,362
<   #ifdef GLM_MHD  /* -- GLM source for dt/2 -- */
<    GLM_Source (d->Vc, 0.5*g_dt, grid);
<   #endif
---
> #ifdef GLM_MHD  /* -- GLM source for dt/2 -- */
>   GLM_Source (d->Vc, 0.5*g_dt, grid);
> #endif
>   g_hydroStep = 0;
556c389
< double NextTimeStep (Time_Step *Dts, Runtime *ini, Grid *grid)
---
> double NextTimeStep (timeStep *Dts, Runtime *ini, Grid *grid)
560c393
<  * (Dts->inv_dta and Dts->inv_dp).
---
>  * (Dts->invDt_hyp and Dts->invDt_par).
562c395
<  * \param [in] Dts    pointer to the Time_Step structure
---
>  * \param [in] Dts    pointer to the timeStep structure
569,570c402,404
<   int idim;
<   double dt_adv, dt_par, dtnext;
---
>   int    idim;
>   double dt_hyp, dt_par, dt_particles, dtnext;
>   double scrh;
574,591c408,430
< /* ---------------------------------------------------
<    1. Take the maximum of inv_dt across all processors
<    --------------------------------------------------- */
< 
<   #ifdef PARALLEL
<    xloc = Dts->inv_dta;
<    MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<    Dts->inv_dta = xglob;
<    #if (PARABOLIC_FLUX != NO)
<     xloc = Dts->inv_dtp;
<     MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<     Dts->inv_dtp = xglob;
<    #endif
<    #if COOLING != NO
<     xloc = Dts->dt_cool;
<     MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
<     Dts->dt_cool = xglob;
<    #endif
---
> /* --------------------------------------------------------
>    1. Take the maximum of invDt_hyp, invDt_par, etc...
>       across all processors
>    -------------------------------------------------------- */
> 
> #ifdef PARALLEL
>   xloc = Dts->invDt_hyp;
>   MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
>   Dts->invDt_hyp = xglob;
>   #if (PARABOLIC_FLUX != NO)
>   xloc = Dts->invDt_par;
>   MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
>   Dts->invDt_par = xglob;
>   #endif
>   #if COOLING != NO
>   xloc = Dts->dt_cool;
>   MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
>   Dts->dt_cool = xglob;
>   #endif
>   #ifdef PARTICLES
>   xloc = Dts->invDt_particles;
>   MPI_Allreduce (&xloc, &xglob, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
>   Dts->invDt_particles = xglob;
592a432,437
> #endif
> 
> /* --------------------------------------------------------
>    2. Show the time step ratios between the actual g_dt
>       and the advection, diffusion and cooling time scales.
>    -------------------------------------------------------- */
594,596c439,453
< /* ----------------------------------
<    2. Compute time step
<    ---------------------------------- */
---
> #if SHOW_TIME_STEPS == YES
>   if (g_stepNumber%ini->log_freq == 0) {
>     char *str = IndentString();
>     print("%s [dt(adv)       = cfl x %10.4e]\n",str, 1.0/Dts->invDt_hyp);
>     #if PARABOLIC_FLUX != NO
>     print("%s [dt(par)       = cfl x %10.4e]\n",str, 1.0/(2.0*Dts->invDt_par));
>     #endif
>     #if COOLING != NO
>     print("%s [dt(cool)      =       %10.4e]\n",str, Dts->dt_cool);
>     #endif
>     #ifdef PARTICLES 
>     print("%s [dt(particles) =       %10.4e]\n",str, 1.0/Dts->invDt_particles);
>     #endif
>   }
> #endif
598,604c455,457
<   #if (PARABOLIC_FLUX & EXPLICIT)
<    dt_adv  = 1.0/(Dts->inv_dta + 2.0*Dts->inv_dtp);
<   #else
<    dt_adv  = 1.0/Dts->inv_dta;
<   #endif
<   dt_adv *= ini->cfl;
<   dtnext  = dt_adv;
---
> /* --------------------------------------------------------
>    3. Compute hyperbolic (htydro) time step
>    -------------------------------------------------------- */
606,609c459,465
< /* -------------------------------------------------------
<    3. Maximum propagation speed for the local processor.
<       Global glm_ch will be computed later in GLM_Init.
<    ------------------------------------------------------- */
---
> #if (PARABOLIC_FLUX & EXPLICIT)
>   dt_hyp  = 1.0/(Dts->invDt_hyp + 2.0*Dts->invDt_par);
> #else
>   dt_hyp  = 1.0/Dts->invDt_hyp;
> #endif
>   dt_hyp *= ini->cfl;
>   dtnext  = dt_hyp;
611,617c467,491
<   #ifdef GLM_MHD
<    dxmin = grid[IDIR].dl_min;
<    for (idim = 1; idim < DIMENSIONS; idim++){ /*  Min cell length   */
<      dxmin = MIN(dxmin, grid[idim].dl_min);
<    }
<    glm_ch = ini->cfl*dxmin/dtnext;
<   #endif
---
> /* --------------------------------------------------------
>    4. For GLM-MHD recompute maximum propagation speed from
>       dtnext and update glm_ch.
>       However, for the first time, glm_ch is recomputed
>       using GLM_Init().
>       Note: in the case of relativistic flows, glm_ch
>       can become less than 1 (when cfast << 1) allowing
>       larger time steps to be taken.
>    -------------------------------------------------------- */
> 
> #ifdef GLM_MHD
>   dxmin = grid->dl_min[IDIR];
>   for (idim = 1; idim < DIMENSIONS; idim++){ /*  Min cell length   */
>     dxmin = MIN(dxmin, grid->dl_min[idim]);
>   }
>   glm_ch = ini->cfl*dxmin/dtnext;
> /*
> scrh = glm_ch;
> glm_ch = dxmin*Dts->invDt_hyp;
> if (fabs(scrh-glm_ch) > 1.e-12){
>   print ("! Different values of glm_ch  = %12.6e,  %12.6e\n",glm_ch,scrh);
>   QUIT_PLUTO(1);
> }
> */
> #endif
619,622c493,497
< /* ---------------------------------------------------------
<    4. With STS, the ratio between advection (full) and 
<       parabolic time steps should not exceed ini->rmax_par.
<    --------------------------------------------------------- */
---
> /* --------------------------------------------------------
>    5. With STS-like methods, the ratio between advection
>       (full) and parabolic time steps should not exceed
>       ini->rmax_par.
>    -------------------------------------------------------- */
624,627c499,504
<   #if (PARABOLIC_FLUX & SUPER_TIME_STEPPING) || (PARABOLIC_FLUX & RK_CHEBYSHEV)
<    dt_par  = ini->cfl_par/(2.0*Dts->inv_dtp);
<    dtnext *= MIN(1.0, ini->rmax_par/(dt_adv/dt_par));
<   #endif
---
> #if (PARABOLIC_FLUX & SUPER_TIME_STEPPING) || \
>     (PARABOLIC_FLUX & RK_CHEBYSHEV)        || \
>     (PARABOLIC_FLUX & RK_LEGENDRE)
>    dt_par  = ini->cfl_par/(2.0*Dts->invDt_par);
>    dtnext *= MIN(1.0, ini->rmax_par/(dt_hyp/dt_par));
> #endif
629,631c506,508
< /* ----------------------------------
<    5. Compute Cooling time step
<    ---------------------------------- */
---
> /* --------------------------------------------------------
>    6. Compute Cooling time step
>    -------------------------------------------------------- */
633,642c510,530
<   #if COOLING != NO
<    dtnext = MIN(dtnext, Dts->dt_cool);
<   #endif
<    
< /* --------------------------------------------------------------
<     6. Allow time step to vary at most by a factor 
<        ini->cfl_max_var.
<        Quit if dt gets too small, issue a warning if first_dt has
<        been overestimated.
<    -------------------------------------------------------------- */
---
> #if COOLING != NO
>   dtnext = MIN(dtnext, Dts->dt_cool);
> #endif
> 
> /* --------------------------------------------------------
>    7. Limit time step due to particles
>       (only if PARTICLES_CR_NSUB > 0)
>    -------------------------------------------------------- */
> 
> #if    (defined PARTICLES) && (PARTICLES_TYPE == COSMIC_RAYS) \
>                            && (PARTICLES_CR_NSUB > 0)
>   dt_particles = PARTICLES_CR_NSUB/Dts->invDt_particles;
>   dtnext       = MIN(dtnext, dt_particles);
> #endif
> 
> /* --------------------------------------------------------
>    8. Allow time step to increase at most by a factor
>       ini->cfl_max_var.
>       Quit if dt gets too small, issue a warning if
>       first_dt has been overestimated.
>    -------------------------------------------------------- */
647c535,541
<     print1 ("! NextTimeStep(): dt is too small (%12.6e). Cannot continue.\n", dtnext);
---
>     char *str = IndentString();
>     print("! NextTimeStep(): dt is too small (%12.6e).\n", dtnext);
>     print("! %s [dt(adv)       = cfl x %10.4e]\n",str, 1.0/Dts->invDt_hyp);
>     print("! %s [dt(par)       = cfl x %10.4e]\n",str, 1.0/(2.0*Dts->invDt_par));
>     print("! %s [dt(cool)      =       %10.4e]\n",str, Dts->dt_cool);
>     print("! %s [dt(particles) =       %10.4e]\n",str, 1.0/Dts->invDt_particles);
>     print("! Cannot continue.\n");
652c546
<     print1 ("! NextTimeStep(): initial dt exceeds stability limit\n");
---
>     print ("! NextTimeStep(): initial dt exceeds stability limit\n");
655,657c549,566
< /* --------------------------------------------
<    7. Reset time step coefficients
<    -------------------------------------------- */
---
> /* --------------------------------------------------------
>    9. Reset time step coefficients
>    -------------------------------------------------------- */
> 
> #if (defined PARTICLES) && (PARTICLES_TYPE == COSMIC_RAYS)
>   #if PARTICLES_CR_NSUB > 0
>   Dts->Nsub_particles = MIN(ceil(dtnext*Dts->invDt_particles), PARTICLES_CR_NSUB);
>   #if PARTICLES_CR_PREDICTOR == 2
>   if (Dts->Nsub_particles > 2){
>     Dts->Nsub_particles += (Dts->Nsub_particles%2 == 1);
>   }
>   #endif
>   #elif PARTICLES_CR_NSUB < 0                  
>   Dts->Nsub_particles = abs(PARTICLES_CR_NSUB);  /* Fix Nsub no matter what */
>   #else
>   #error ! NextTimeStep(): PARTICLES_CR_NSUB cannot be = 0
>   #endif
> #endif
660,662c569,572
<   Dts->inv_dta = 0.0;
<   Dts->inv_dtp = 0.5e-38;
<   Dts->dt_cool = 1.e38;
---
>   Dts->invDt_hyp       = 0.0;
>   Dts->invDt_par       = 0.5e-38;
>   Dts->invDt_particles = 1.e-38;
>   Dts->dt_cool         = 1.e38;
668c578
< void CheckForOutput (Data *d, Runtime *ini, Grid *grid)
---
> void CheckForOutput (Data *d, Runtime *ini, time_t t0, Grid *grid)
675,677c585,590
<   int  n, check_dt, check_dn, check_dclock;
<   int  restart_update, last_step;
<   double t, tnext;
---
>   int    n, check_dt, check_dn, check_dclock;
>   int    first_step     = (g_stepNumber == 0 ? 1:0);
>   int    last_step      = (fabs(g_time-ini->tstop) < 1.e-12 ? 1:0);
>   int    restart_update = 0;
>   double dtime[MAX_OUTPUT_TYPES];
>   static time_t tbeg[MAX_OUTPUT_TYPES], tend;
679,687d591
<   static time_t clock_beg[MAX_OUTPUT_TYPES], clock_end;
<   static double tbeg[MAX_OUTPUT_TYPES], tend;
<   double dclock;
< 
<   restart_update = 0;
<   t     = g_time;
<   tnext = t + g_dt;
<   
<   last_step = (fabs(t-ini->tstop) < 1.e-12 ? 1:0);
689,690c593,595
< /* -- on first execution initialize
<       current beginning time for all output types -- */
---
> /* ----------------------------------------------
>    0. Initialize
>    ---------------------------------------------- */
692,703c597
<   if (first_call){
<     #ifdef PARALLEL
<      if (prank == 0){
<        double tstart;
<        tstart = MPI_Wtime();
<        for (n = 0; n < MAX_OUTPUT_TYPES; n++) tbeg[n] = tstart;
<      }
<      MPI_Bcast(tbeg, MAX_OUTPUT_TYPES, MPI_DOUBLE, 0, MPI_COMM_WORLD);
<     #else
<      for (n = 0; n < MAX_OUTPUT_TYPES; n++) time(clock_beg + n);
<     #endif
<   } 
---
>   if (first_call) for (n = 0; n < MAX_OUTPUT_TYPES; n++) tbeg[n] = t0;
705c599
< /* -- get current time -- */
---
>   time (&tend);
707,712c601,604
<   #ifdef PARALLEL  
<    if (prank == 0) tend = MPI_Wtime();
<    MPI_Bcast(&tend, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
<   #else
<    time(&clock_end);
<   #endif
---
>   for (n = 0; n < MAX_OUTPUT_TYPES; n++) dtime[n] = difftime(tend, tbeg[n]);
> #ifdef PARALLEL
>   MPI_Bcast(dtime, MAX_OUTPUT_TYPES, MPI_DOUBLE, 0, MPI_COMM_WORLD);
> #endif
715c607
<           start main loop on outputs
---
>    1. Start main loop on outputs
717c609
<    
---
> 
722c614,616
<   /* -- check time interval in code units (dt) -- */
---
>   /* ----------------------------------------------------
>      1a. Enable writing if  t(n) < t(write) < t(n+1)
>      ---------------------------------------------------- */
725,726c619,620
<       check_dt = (int) (tnext/output->dt) - (int)(t/output->dt);
<       check_dt = check_dt || g_stepNumber == 0 || last_step;
---
>       check_dt = (int) ((g_time+g_dt)/output->dt) - (int)(g_time/output->dt);
>       check_dt = check_dt || first_step || last_step;
729c623,626
<   /* -- check time interval in number of steps (dn) -- */
---
>   /* ----------------------------------------------------
>      1b. Enable writing if current step is an integer
>          multiple of output interval
>      ---------------------------------------------------- */
733c630
<       check_dn = check_dn || g_stepNumber == 0 || last_step;
---
>       check_dn = check_dn || first_step || last_step;
736c633,635
<   /* -- check time interval in clock time (dclock) -- */
---
>   /* ----------------------------------------------------
>      1c. Enable writing if clock time has been reached
>      ---------------------------------------------------- */
739,744c638
<       #ifdef PARALLEL
<        dclock = tend - tbeg[n];
<       #else
<        dclock = difftime(clock_end, clock_beg[n]);
<       #endif
<       if (dclock >= output->dclock) {
---
>       if (dtime[n] >= output->dclock) {
746,750c640
<         #ifdef PARALLEL
<          tbeg[n] = tend;
<         #else
<          time(clock_beg + n);
<         #endif
---
>         tbeg[n] = tend;
754c644
<       check_dclock = check_dclock || g_stepNumber == 0 || last_step;
---
>       check_dclock = check_dclock || first_step || last_step;
761,769c651,660
<       #ifdef USE_ASYNC_IO
<        if (!strcmp(output->mode,"single_file_async")){
<          Async_BegWriteData (d, output, grid);
<        }else{
<          WriteData(d, output, grid);
<        }
<       #else     
<        WriteData(d, output, grid);
<       #endif   
---
> #ifdef PARTICLES
>       if (  output->type == PARTICLES_DBL_OUTPUT
>          || output->type == PARTICLES_FLT_OUTPUT
>          || output->type == PARTICLES_VTK_OUTPUT
>          || output->type == PARTICLES_TAB_OUTPUT
>          || output->type == PARTICLES_HDF5_OUTPUT){
>         Particles_WriteData(d, output, grid);
>       } else
> #endif
>       WriteData(d, output, grid);  
782c673
<     Dump restart information if required 
---
>    2. Dump restart information if required 
784,785c675,676
<     Note that if both dbl and dbl.h5 formats are used,
<     bookkeeping is done using dbl format.
---
>       Note that if both dbl and dbl.h5 formats are used,
>       bookeeping is done using dbl format.
816a708
> 
diff Src/mappers3D.c ../old/mappers3D.c
56,58c56,58
<   ibeg = (box->ib <= box->ie) ? (iend=box->ie, box->ib):(iend=box->ib, box->ie);
<   jbeg = (box->jb <= box->je) ? (jend=box->je, box->jb):(jend=box->jb, box->je);
<   kbeg = (box->kb <= box->ke) ? (kend=box->ke, box->kb):(kend=box->kb, box->ke);
---
>   ibeg = (box->ibeg <= box->iend) ? (iend=box->iend, box->ibeg):(iend=box->ibeg, box->iend);
>   jbeg = (box->jbeg <= box->jend) ? (jend=box->jend, box->jbeg):(jend=box->jbeg, box->jend);
>   kbeg = (box->kbeg <= box->kend) ? (kend=box->kend, box->kbeg):(kend=box->kbeg, box->kend);
62,77c62,66
< 
< #ifdef CHOMBO
<     for (i = ibeg; i <= iend; i++) NVAR_LOOP(nv) u[i][nv] = U[nv][k][j][i];
<     #if COOLING == MINEq || COOLING == H2_COOL
<     if (g_intStage == 1) for (i = ibeg; i <= iend; i++) NormalizeIons(u[i]);
<     #endif
<     err = ConsToPrim (u, v, ibeg, iend, flag[k][j]);
< 
<   /* -------------------------------------------------------------
<       Ensure any change to 1D conservative arrays is not lost.
<       Note: Conversion must be done even when err = 0 in case
<             ENTROPY_SWITCH is employed.
<      ------------------------------------------------------------- */
< 
<     for (i = ibeg; i <= iend; i++) NVAR_LOOP(nv) U[nv][k][j][i] = u[i][nv];
< #else
---
> #if (defined CHOMBO) && (COOLING == MINEq || COOLING == H2_COOL)
>     if (g_intStage == 1) {
>       for (i = ibeg; i <= iend; i++)  NormalizeIons(U[k][j][i]);
>     }  
> #endif  
79d67
< #endif
120,122c108,110
<   ibeg = (box->ib <= box->ie) ? (iend=box->ie, box->ib):(iend=box->ib, box->ie);
<   jbeg = (box->jb <= box->je) ? (jend=box->je, box->jb):(jend=box->jb, box->je);
<   kbeg = (box->kb <= box->ke) ? (kend=box->ke, box->kb):(kend=box->kb, box->ke);
---
>   ibeg = (box->ibeg <= box->iend) ? (iend=box->iend, box->ibeg):(iend=box->ibeg, box->iend);
>   jbeg = (box->jbeg <= box->jend) ? (jend=box->jend, box->jbeg):(jend=box->jbeg, box->jend);
>   kbeg = (box->kbeg <= box->kend) ? (kend=box->kend, box->kbeg):(kend=box->kbeg, box->kend);
126,130c114
<     for (i = ibeg; i <= iend; i++) VAR_LOOP(nv) v[i][nv] = V[nv][k][j][i];
< #ifdef CHOMBO
<     PrimToCons(v, u, ibeg, iend);
<     for (i = ibeg; i <= iend; i++) VAR_LOOP(nv) U[nv][k][j][i] = u[i][nv];
< #else      
---
>     for (i = ibeg; i <= iend; i++) NVAR_LOOP(nv) v[i][nv] = V[nv][k][j][i];
132d115
< #endif
diff Src/mean_mol_weight.c ../old/mean_mol_weight.c
229a230,252
> #elif COOLING == KROME 
>   int i;
>   double numden[NIONS], mfsum, n_sum;
>   mu = 0.0;
>   n_sum = 0.0;
>   mfsum = 0.0;
> 
>   //The mu is computed using number fractions. 
>   NIONS_LOOP(nv) mfsum += v[nv];
>   NIONS_LOOP(nv) v[nv] /= mfsum;
>   NIONS_LOOP(nv) numden[nv-NFLX] = v[RHO]*UNIT_DENSITY*(v[nv]/molmass[nv-NFLX]);
>   
>   for(i = 0; i < NIONS; i++){
>     mu += numden[i]*molmass[i];
>   }
> 
>   for(i=0;i<NIONS; i++){
>     n_sum += numden[i];
>   }
> 
>   mu  /= (CONST_mp*n_sum); // KROME divides with proton mass. 
> 
> 
231c254
<     
---
>  
233c256,259
< }
\ No newline at end of file
---
> }
> 
> 
> 
Only in ../old: mpi_sub_decomp.c
Only in ../old: output_log.c
Only in Src: parabolic_flux.c
Only in Src: parabolic_rhs.c
Only in ../old: parabolic_update.c
diff Src/pluto.h ../old/pluto.h
10c10
<   \date   July 05, 2015
---
>   \date   Feb 21, 2018
16c16
< #define PLUTO_VERSION  "4.2"
---
> #define PLUTO_VERSION  "4.3"
19a20
> #include <stdint.h>
28,29c29,30
< #define TRUE      YES
< #define FALSE     NO
---
> #define TRUE       YES
> #define FALSE      NO
42d42
< #define RATIO_GRID               5
44,45c44
< 
< /* ---- Equation of state (EoS) labels  ----  */
---
> /* ---- Equation of sweep (EoS) labels  ----  */
66d64
< #define RK_MIDPOINT                7
67a66,67
> #define EXP_MIDPOINT               9  /* -- Used for dust time stepping -- */
> #define SEMI_IMPLICIT             10  /* -- Used for dust time stepping -- */
71a72
> #define RK_LEGENDRE          8
73,77c74,76
< /* ---- Operator step labels ---- */
< 
< #define HYPERBOLIC_STEP  1  
< #define PARABOLIC_STEP   2
< #define SOURCE_STEP      3
---
> #define IMEX        2   /* Any number different from EXPLICIT (=1) */
> #define OP_SPLIT    4   /* Any number different from EXPLICIT (=1) */
> #define NEW_SPLIT   5   /* Any number different from EXPLICIT (=1) */
79c78
< /* ----   Output labels  ---- */
---
> /* ----   Output labels ---- */
88a88,95
> #ifdef PARTICLES
>   #define PARTICLES_DBL_OUTPUT  9
>   #define PARTICLES_FLT_OUTPUT  10
>   #define PARTICLES_VTK_OUTPUT  11
>   #define PARTICLES_TAB_OUTPUT  12
>   #define PARTICLES_HDF5_OUTPUT  13
> #endif
> 
92,98c99,102
< /*! The maximum number of output file formats is fixed to 11 so that the 
<     size of runtime structure (defined below) is 64 bytes. 
<     This should prevent, for some compilers, attempts to change the 
<     alignment of the structure and therefore troubleshooting when restarting 
<     from files written on different architectures.                    */
< #define MAX_OUTPUT_TYPES 11 
< #define MAX_OUTPUT_VARS  128
---
> #define MAX_OUTPUT_TYPES 16    /* The max number of allowed data formats
>                                   including fluid and particles */     
> #define MAX_OUTPUT_VARS  64    /* The maximum nuber of variables that can be
>                                   dumped to disk for a single format. */
107c111,115
< #define BLONDIN      8
---
> #define KROME	     8
> #define BLONDIN	     9
> 
> 
> /*----- Particle Labels ----- */
108a117,119
> #define LAGRANGIAN 	    1
> #define COSMIC_RAYS     3
> #define DUST            4
112,121c123,133
< #define ADVECTION  1
< #define HD         2
< #define RHD        3
< #define MHD        4
< #define RMHD       5
< 
<     /*  ----  SET LABELS FOR DIV.B REMOVAL  ----  
<         If you move them to the MHD header, 
<         definitions.h (which is included before)
<         cannot correctly use them                */
---
> #define ADVECTION     1
> #define HD            2
> #define RHD           3
> #define MHD           4
> #define RMHD          5
> #define CR_TRANSPORT  6
> 
> /*  ----  SET LABELS FOR DIV.B Control  ----  
>           If you move them to the MHD header, 
>           definitions.h (which is included before)
>           cannot correctly use them                */
123d134
< #define NONE                   0
128,130c139,141
<    /*  ----  SET LABELS FOR BODY_FORCE  ----
<       Please do not change them since they are
<       used in bitwise operations                */
---
> /*  ----  SET LABELS FOR BODY_FORCE  ----
>     Please do not change them since they are
>     used in bitwise operations                */
202,205c213,219
< #define CENTER  0
< #define X1FACE  1
< #define X2FACE  2
< #define X3FACE  3
---
> #define CENTER  0  /* -- Means (i, j, k)         -- */
> #define X1FACE  1  /* -- Means (i+1/2, j, k)     -- */
> #define X2FACE  2  /* -- Means (i, j+1/2, k)     -- */
> #define X3FACE  3  /* -- Means (i, j, k+1/2)     -- */
> #define X1EDGE  4  /* -- Means (i, j+1/2, k+1/2) -- */
> #define X2EDGE  5  /* -- Means (i+1/2, j, k+1/2) -- */
> #define X3EDGE  6  /* -- Means (i+1/2, j+1/2, k) -- */ 
257a272
> #define CONST_e       4.80320425e-10     /**<  Elementary (proton) charge */
272a288,289
> #define CONST_Rgas    8.3144598e7        /**<  Perfect gas constant       */
> 
289a307,314
> #ifndef AMBIPOLAR_DIFFUSION
>  #define AMBIPOLAR_DIFFUSION NO
> #endif
> 
> #ifndef ASSIGN_VECTOR_POTENTIAL 
>  #define ASSIGN_VECTOR_POTENTIAL   NO
> #endif
> 
334,335c359,360
< #ifndef DUST
<  #define DUST   NO
---
> #ifndef DUST_FLUID
>  #define DUST_FLUID   NO
346,347c371,386
< #ifndef INCLUDE_PARTICLES
<  #define INCLUDE_PARTICLES NO
---
> #ifndef HALL_MHD
>  #define HALL_MHD          NO
> #endif
> 
> #ifndef INITIAL_SMOOTHING        
>  #define INITIAL_SMOOTHING  NO  /**< Assign initial conditions by averaging
>                                      multiple values inside the cell */
>                      
> #endif
> 
> #ifndef INTERNAL_BOUNDARY
>  #define INTERNAL_BOUNDARY   NO
> #endif
> 
> #ifndef LIMITER
>  #define LIMITER         DEFAULT
351,353c390,392
<   #define RECONSTRUCT_4VEL   NO  /**< When set to YES, reconstruct 4-velocity
<                                       rather than 3-velocity (only for RHD and
<                                       RMHD physics modules)  */
---
>  #define RECONSTRUCT_4VEL   NO  /**< When set to YES, reconstruct 4-velocity
>                                      rather than 3-velocity (only for RHD and
>                                      RMHD physics modules)  */
363a403,406
> #ifndef SHOCK_FLATTENING
>   #define SHOCK_FLATTENING     NO
> #endif
> 
365c408
<  #define THERMAL_CONDUCTION NO
---
>  #define THERMAL_CONDUCTION    NO
377c420,424
<  #define UNIT_VELOCITY (1.e5)  /**< Unit velocity in cm/sec. */
---
>  #if PHYSICS == RHD || PHYSICS == RMHD
>   #define UNIT_VELOCITY (CONST_c)
>  #else
>   #define UNIT_VELOCITY (1.e5)  /**< Unit velocity in cm/sec. */
>  #endif
387a435,438
> #ifndef WARNING_MESSAGES
>  #define WARNING_MESSAGES    YES
> #endif
> 
393c444
<   #define HAVE_ENERGY       YES
---
>  #define HAVE_ENERGY       YES
395c446
<   #define HAVE_ENERGY      NO
---
>  #define HAVE_ENERGY       NO
411c462,464
< #define CHECK_EIGENVECTORS     NO
---
> #ifndef CHECK_EIGENVECTORS
>  #define CHECK_EIGENVECTORS     NO
> #endif
433,448c486,497
< /* ------------------------------------------------------------
<     the GET_MAX_DT switch determines how the time step is
<     computed. For pure advection, setting it to YES will force
<     PLUTO to compute dt in the old way, i.e., by taking the
<     maximum.
<     When set to NO, the time step is computed only during the
<     predictor step and, for UNSPLIT RK schemes, it will be
<     calculated as the average over dimensions resulting in 
<     slightly larger time increments.
<    ------------------------------------------------------------ */
< 
< #if ((TIME_STEPPING == RK2) || (TIME_STEPPING == RK3)) \
<       && DIMENSIONAL_SPLITTING == NO
<  #define GET_MAX_DT    NO
< #else
<  #define GET_MAX_DT    YES
---
> /* -- Select Primitive / Conservative form of Hancock scheme -- */
> 
> #if TIME_STEPPING == HANCOCK 
>  #ifndef PRIMITIVE_HANCOCK
>   #if (PHYSICS == MHD) && (defined PARTICLES) && (PARTICLES_TYPE == COSMIC_RAYS)
>    #define PRIMITIVE_HANCOCK   NO
>   #elif PHYSICS == RMHD
>    #define PRIMITIVE_HANCOCK   NO
>   #else
>    #define PRIMITIVE_HANCOCK   YES
>   #endif   
>  #endif   
452,454c501,504
<     Diffusion operators: PARABOLIC_FLUX is the bitwise OR
<     combination of all operators, each being either one of 
<     NO, EXPLICIT (1st bit), STS (2nd bit). 
---
>     Diffusion operators (HD and MHD only):
>     PARABOLIC_FLUX is the bitwise OR combination of all operators, each
>     being either one of NO, EXPLICIT (1st bit), STS (2nd bit),
>     RKL (3rd bit). 
466c516,520
< #define PARABOLIC_FLUX (RESISTIVITY|THERMAL_CONDUCTION|VISCOSITY)
---
> #if PHYSICS == HD || PHYSICS == MHD
>  #define PARABOLIC_FLUX (RESISTIVITY|THERMAL_CONDUCTION|VISCOSITY)
> #else 
>  #define PARABOLIC_FLUX NO
> #endif
489c543
< typedef void Riemann_Solver (const State_1D *, int, int, double *, Grid *);
---
> typedef void Riemann_Solver (const Sweep *, int, int, double *, Grid *);
500,502d553
< #ifdef SHEARINGBOX
<  #include "MHD/ShearingBox/shearingbox.h"
< #endif
504,505c555,556
< #if COOLING != NO
<   #include "cooling.h"
---
> #if COOLING != NO      /* Cooling should be included as soon as possible */
>   #include "cooling.h" /* since it may change the number of variables    */
509,562d559
< #if DUST == YES
<   #include "Dust/dust.h"            /* Dust header file */
< #endif
< 
< #ifdef FARGO
<  #include "Fargo/fargo.h"           /* FARGO header file */
< #endif
< 
< #if THERMAL_CONDUCTION != NO 
<  #include "Thermal_Conduction/tc.h" /* Thermal conduction header file */
< #endif
< 
< #if VISCOSITY != NO
<  #include "Viscosity/viscosity.h"   /* Viscosity header file */
< #endif
< 
< #include "States/plm_coeffs.h"      /* PLM header file */
< #if RECONSTRUCTION == PARABOLIC 
<  #include "States/ppm_coeffs.h"     /* PPM header file */
< #endif
< #include "Math_Tools/math_tools.h"  /* Math tools header file */
< 
< /* *********************************************************************
<     Define mass fractions (H_MASS_FRAC and He_MASS_FRAC).
<     
<     For H2_COOL,  Proto-Solar Mass Fractions for Hydrogen
<     and Helium  (Lodders, ApJ 591, 2003 )  are used.
< 
<     Define also the number fractions (relative to hydrogen)
<     as FRAC_He and FRAC_Z (FRAC_H = 1.0).
<    ********************************************************************* */
< 
< #ifndef H_MASS_FRAC  /* Sets default values  */
<   #define H_MASS_FRAC       0.7110
< #endif
< 
< #if (EOS == PVTE_LAW) && (COOLING == NO)
<   #define  He_MASS_FRAC  (1 - H_MASS_FRAC) /* Effective Y and not 0.2741
<                                               Baraffe (2008) */
< #endif
< 
< #ifndef He_MASS_FRAC
<   #define He_MASS_FRAC      0.2741
< #endif
< 
< #define Z_MASS_FRAC (1.0 - H_MASS_FRAC - He_MASS_FRAC)  
< #define FRAC_He     (He_MASS_FRAC/CONST_AHe*CONST_AH/H_MASS_FRAC)
< #define FRAC_Z      (Z_MASS_FRAC /CONST_AZ *CONST_AH/H_MASS_FRAC)
< 
< 
< #ifndef NIONS
<   #define NIONS 0
< #endif
< 
564,565c561,562
< /*! The number of scalars (passive tracers).
<     This includes
---
> /*! Set the number of scalars including:
> 
568a566
> 
571a570,574
> 
> #ifndef NIONS
>   #define NIONS 0
> #endif
> 
574,575c577,578
< #ifndef NDUST
<   #define NDUST  0
---
> #ifndef NDUST_FLUID
>   #define NDUST_FLUID  0
577,578c580,581
< #define NDUST_BEG   (NFLX + NSCL)
< #define NDUST_END   (NDUST_BEG + NDUST - 1)
---
> #define NDUST_FLUID_BEG   (NFLX + NSCL)
> #define NDUST_FLUID_END   (NDUST_FLUID_BEG + NDUST_FLUID - 1)
580a584
> 
592a597
> 
601c606
<            NFLX    NIONS    NTRACER    ENTR    NDUST
---
>            NFLX    NIONS    NTRACER    ENTR    NDUST_FLUID
609c614
< #define NVAR (NFLX + NSCL + NDUST)
---
> #define NVAR (NFLX + NSCL + NDUST_FLUID)
617c622
< #define NDUST_LOOP(n)    for ((n) = NDUST_BEG;  (n) <= NDUST_END; (n)++)
---
> #define NDUST_FLUID_LOOP(n)    for ((n) = NDUST_FLUID_BEG;  (n) <= NDUST_FLUID_END; (n)++)
619a625,694
> /* ********************************************************
>     Keep on adding module header files 
>    ******************************************************** */
> 
> 
> #if DUST_FLUID == YES
>   #include "Dust/dust.h"            /* Dust header file */
> #endif
> 
> #ifdef FARGO
>  #include "Fargo/fargo.h"           /* FARGO header file */
> #endif
> 
> #if FORCED_TURB == YES
>   #include "Forced_Turb/forced_turb.h" /* Forced Turb Header file */
> #endif
> 
> #ifdef HALL_MHD
>  #include "MHD/Hall_MHD/hall_mhd.h"  /* Hall-MHD module header */
> #endif
> 
> #ifdef PARTICLES                   /* Particle Header File */
>  #include "Particles/particles.h"
> #endif
> 
> #ifdef SHEARINGBOX
>  #include "MHD/ShearingBox/shearingbox.h"   /* Shearing box header file */
> #endif
> 
> #if THERMAL_CONDUCTION != NO 
>  #include "Thermal_Conduction/tc.h" /* Thermal conduction header file */
> #endif
> 
> #if VISCOSITY != NO
>  #include "Viscosity/viscosity.h"   /* Viscosity header file */
> #endif
> 
> #include "States/plm_coeffs.h"      /* PLM header file */
> #if RECONSTRUCTION == PARABOLIC 
>  #include "States/ppm_coeffs.h"     /* PPM header file */
> #endif
> #include "Math_Tools/math_tools.h"  /* Math tools header file */
> 
> /* *********************************************************************
>     Define mass fractions (H_MASS_FRAC and He_MASS_FRAC).
>     
>     For H2_COOL,  Proto-Solar Mass Fractions for Hydrogen
>     and Helium  (Lodders, ApJ 591, 2003 )  are used.
> 
>     Define also the number fractions (relative to hydrogen)
>     as FRAC_He and FRAC_Z (FRAC_H = 1.0).
>    ********************************************************************* */
> 
> #ifndef H_MASS_FRAC  /* Sets default values  */
>   #define H_MASS_FRAC       0.7110
> #endif
> 
> #if (EOS == PVTE_LAW) && (COOLING == NO)
>   #define  He_MASS_FRAC  (1 - H_MASS_FRAC) /* Effective Y and not 0.2741
>                                               Baraffe (2008) */
> #endif
> 
> #ifndef He_MASS_FRAC
>   #define He_MASS_FRAC      0.2741
> #endif
> 
> #define Z_MASS_FRAC (1.0 - H_MASS_FRAC - He_MASS_FRAC)  
> #define FRAC_He     (He_MASS_FRAC/CONST_AHe*CONST_AH/H_MASS_FRAC)
> #define FRAC_Z      (Z_MASS_FRAC /CONST_AZ *CONST_AH/H_MASS_FRAC)
> 
622,623c697,698
< #if DUST == YES
<  #define IF_DUST(a)  a
---
> #if DUST_FLUID == YES
>  #define IF_DUST_FLUID(a)  a
625c700
<  #define IF_DUST(a)  
---
>  #define IF_DUST_FLUID(a)  
678c753,754
< #if DUST == YES
---
> extern int EXn, EXt, EXb;
> #if DUST_FLUID == YES
683d758
< 
686,690c761
< extern int g_dir;
< extern int g_maxRiemannIter;
< extern int g_maxRootIter;
< extern long int g_usedMemory;
< extern long int g_stepNumber;
---
> extern int      g_dir;
692c763,768
< extern int      g_operatorStep;
---
> extern int      g_maxIMEXIter;
> extern int      g_maxRiemannIter;
> extern int      g_maxRootIter;
> extern int      g_nprocs;
> extern long int g_stepNumber;
> extern long int g_usedMemory;
698a775
> extern int    g_hydroStep;
722a800,804
> #if DEBUG == TRUE
>   extern int d_indent;
>   extern int d_condition;
> #endif
> 
diff Src/prototypes.h ../old/prototypes.h
5,6c5,9
< int    AdvanceStep(const Data *, Riemann_Solver *, Time_Step *, Grid *);
< void   AdvectFlux (const State_1D *, int, int, Grid *);
---
> int    AdvanceStep(Data *, Riemann_Solver *, timeStep *, Grid *);
> void   AdvectFlux (const Sweep *, int, int, Grid *);
> void   AMR_StoreFlux (double **, double **ViF, int,
>                       int, int, int, int, Grid *);
> 
31,52c34,62
< void  ChangeDumpVar ();
< void  CharTracingStep(const State_1D *, int, int, Grid *);
< void  CheckPrimStates (double **, double **, double **, int, int);
< int   CheckNaN (double **, int, int, int);
< int   CloseBinaryFile (FILE *, int);
< void  ComputeUserVar (const Data *, Grid *);
< float ***Convert_dbl2flt (double ***, double, int);
< 
< void ConsToPrim3D(Data_Arr, Data_Arr, unsigned char ***, RBox *);
< void CreateImage (char *);
< 
< void ComputeEntropy      (const Data *, Grid *);
< void EntropySwitch       (const Data *, Grid *);
< void EntropyOhmicHeating (const Data *, Data_Arr, double, Grid *);
< 
< void FreeArray1D (void *);
< void FreeArray2D (void **);
< void FreeArray3D (void ***);
< void FreeArray4D (void ****);
< void FreeArrayBox(double ***, long, long, long);
< void FreeArrayBoxMap (double ***, int, int, int, int, int, int);
< void FreeArrayMap (double ***);
---
> void   ChangeOutputVar (void);
> void   CharTracingStep(const Sweep *, int, int, Grid *);
> void   CheckPrimStates (double **, double **, double **, int, int);
> int    CheckNaN (double **, int, int, int);
> void   ComputeUserVar (const Data *, Grid *);
> float  ***Convert_dbl2flt (double ***, double, int);
> 
> void  ConsToPrim3D(Data_Arr, Data_Arr, unsigned char ***, RBox *);
> void  CreateImage (char *);
> 
> void  ComputeEntropy      (const Data *, Grid *);
> void  EntropySwitch       (const Data *, Grid *);
> void  EntropyOhmicHeating (const Data *, Data_Arr, double, Grid *);
> 
> int    FileClose  (FILE *, int);
> int    FileDelete (char *);
> FILE  *FileOpen  (char *, int, char *);
> void   FileReadData  (void *, size_t, int, FILE *, int, int);
> void   FileWriteData (void *, size_t, int, FILE *, int);
> void   FileWriteHeader(char *buffer, char fname[], int mode);
> void   FileWriteArray(void *, long int, int, size_t, char *);
> 
> void  FreeArray1D (void *);
> void  FreeArray2D (void **);
> void  FreeArray3D (void ***);
> void  FreeArray4D (void ****);
> void  FreeArrayBox(double ***, long, long, long);
> void  FreeArrayBoxMap (double ***, int, int, int, int, int, int);
> void  FreeArrayMap (double ***);
54c64
< void FreeArrayCharMap(unsigned char ***);
---
> void  FreeArrayCharMap(unsigned char ***);
60c70
<  void FD_GetMaxEigenvalues (const Data *d, State_1D *state, Grid *grid);
---
>  void FD_GetMaxEigenvalues (const Data *d, Sweep *sweep, Grid *grid);
65c75
< void Flatten (const State_1D *, int, int, Grid *);
---
> void Flatten (const Sweep *, int, int, Grid *);
68,69c78,81
< void     GetAreaFlux (const State_1D *, double **, double **, int, int, Grid *);
< void     GetCGSUnits (double *u);
---
> void     StateStructAllocate (State *);
> 
> void     GetAreaFlux (const Sweep *, double **, double **, int, int, Grid *);
> void     GetCGSUnits (double *);
72a85
> void     GetNeighbourRanks (Grid *, int **);
74c87,88
< RBox    *GetRBox(int, int);
---
> int      GetOutputVarNames(int, char *var_names[NVAR]);
> 
77c91,93
< void HancockStep    (const State_1D *, int, int, Grid *);
---
> void    GnuplotSetting(Grid *);
> 
> void HancockStep    (const Sweep *, int, int, Grid *);
80a97,98
> char  *IndentString();
> 
81a100,101
> void InitDomain (Data *, Grid *);
> 
84c104
< void InternalBoundaryReset (const State_1D *, Time_Step *, int, int, Grid *);
---
> void   InternalBoundaryReset (const Sweep *, timeStep *, int, int, Grid *);
86,89c106,109
< void InputDataFree (void);
< void InputDataInterpolate (double *, double, double, double);
< void InputDataRead (char *, char *);
< void InputDataSet (char *, int *);
---
> void   InputDataClose(int);
> double InputDataInterpolate (int, double, double, double);
> int    InputDataOpen(char *, char *, char *, int);
> void   InputDataReadSlice(int, int);
91c111
< int  IsLittleEndian (void);
---
> int    IsLittleEndian (void);
93c113
< void   MakeState (State_1D *);
---
> void   MakeState (Sweep *);
98c118,119
< FILE  *OpenBinaryFile  (char *, int, char *);
---
> void   OutputLogPre  (Data *, timeStep *, Runtime *, Grid *);
> void   OutputLogPost (Data *, timeStep *, Runtime *, Grid *);
100c121,122
< void   ParabolicFlux(Data_Arr, Data_Arr J, double ***, const State_1D *,
---
> void   ParabolicArrays(const Data *, int *, int, Grid *);
> void   ParabolicFlux(Data_Arr, Data_Arr, double ***, const Sweep *,
102c124,126
< double ParabolicRHS (const Data *, Data_Arr, double, Grid *);
---
> double ParabolicRHS   (const Data *, Data_Arr, RBox *, double **, int, double, Grid *);
> void   ParabolicUpdate(const Data *, Data_Arr, RBox *, double **, double, timeStep *, Grid *);
> 
113,118c137,140
< void ReadBinaryArray (void *, size_t, int, FILE *, int, int);
< void ReadHDF5 (Output *output, Grid *grid);
< void ResetState (const Data *, State_1D *, Grid *);
< void RestartFromFile (Runtime *, int, int, Grid *);
< void RestartDump     (Runtime *);
< void RestartGet      (Runtime *, int, int, int);
---
> void   RBoxDefine(int, int, int, int, int, int, int, RBox *);
> void   RBoxSetDirections(RBox *, int);
> void   RBoxShow(RBox *);
> 
120,121c142,149
< void RightHandSide (const State_1D *, Time_Step *, int, int, double, Grid *);
< void RightHandSideSource (const State_1D *, Time_Step *, int, int, double,
---
> void   ReadHDF5 (Output *output, Grid *grid);
> void   ResetState (const Data *, Sweep *, Grid *);
> void   RestartFromFile (Runtime *, int, int, Grid *);
> void   RestartDump     (Runtime *);
> void   RestartGet      (Runtime *, int, int, int);
> 
> void   RightHandSide (const Sweep *, timeStep *, int, int, double, Grid *);
> void   RightHandSideSource (const Sweep *, timeStep *, int, int, double,
123c151,153
< void     RKC (const Data *d, Time_Step *, Grid *);
---
> void     RKC (const Data *d, double, timeStep *, Grid *);
> void     RKL (const Data *d, double, timeStep *, Grid *);
> 
127a158,161
> void StoreAMRFlux (double **flux, double **aflux, int sign,
>                     int nvar_beg, int nvar_end, int beg, int end, Grid *grid);
> 
> 
130,131c164,165
< int  SetDumpVar (char *, int, int);
< void SetIndexes (Index *indx, Grid *grid);
---
> int  SetOutputVar (char *, int, int);
> 
133,134d166
< void SetOutput (Data *d, Runtime *input);
< void SetRBox(void);
137a170,172
> void SetOutput (Data *d, Runtime *input);
> void SetVectorIndices (int);
> 
139,140c174,178
< void ShowMatrix(double **, int n, double);
< void ShowVector (double *, int n);
---
> void ShowMatrix(double **, int, double);
> void ShowVector (double *, int);
> int  StringArrayIndex (char *str_arr[], int, char *);
> 
> void SymmetryCheck (Data_Arr, int, RBox *);
142d179
< void ShowDomainDecomposition (int, Grid *);
144,145c181,182
< void SplitSource (const Data *, double, Time_Step *, Grid *);
< void STS (const Data *d, Time_Step *, Grid *);
---
> void SplitSource (const Data *, double, timeStep *, Grid *);
> void STS (const Data *d, double, timeStep *, Grid *);
148,149c185,186
< void Startup (Data *, Grid *);
< void States (const State_1D *, int, int, Grid *);
---
> void Startup    (Data *, Grid *);
> void States     (const Sweep *, int, int, Grid *);
153,154c190,191
< void UpdateStage(const Data *, Data_Arr, double **, Riemann_Solver *,
<                  double, Time_Step *, Grid *);
---
> void UpdateStage(Data *, Data_Arr, double **, Riemann_Solver *,
>                  double, timeStep *, Grid *);
157c194,195
< void VectorPotentialDiff (double *, int, int, int, Grid *);
---
> //void VectorPotentialDiff (double *, int, int, int, Grid *);
> void VectorPotentialDiff (double *, Data *, int, int, int, Grid *);
161d198
< void WriteBinaryArray (void *, size_t, int, FILE *, int);
165a203,204
> void WriteVTKProcFile (double ***, int, int, int, char *);
> 
180d218
< void print1 (const char *fmt, ...);
183,201d220
< /* ---------------------------------------------------------------------
<             Prototyping for Boundary condition functions
<    --------------------------------------------------------------------- */
< 
< void FlipSign       (int, int, int *);
< void OutflowBound   (double ***, int, int, Grid *);
< void PeriodicBound  (double ***, int, int);
< void ReflectiveBound(double ***, int, int, int);
< 
< /* ---------------------------------------------------------------------
<               Prototyping for I/O functions
<    --------------------------------------------------------------------- */
< 
< #ifdef USE_ASYNC_IO
< void Async_EndWriteData (Runtime *);
< void Async_BegWriteData (const Data *d, Output *output, Grid *grid);
< #endif
< 
< 
209,212c228,231
<  void CoolingSource (const Data *, double, Time_Step *, Grid *);
<  #if COOLING == POWER_LAW 
<  void  PowerLawCooling (Data_Arr, double, Time_Step *, Grid *);
< #endif
---
>  void CoolingSource (const Data *, double, timeStep *, Grid *);
>  #if COOLING == POWER_LAW
>   void  PowerLawCooling (Data_Arr, double, timeStep *, Grid *);
>  #endif
214,215c233,234
<  void  BlondinCooling (Data_Arr, double, Time_Step *, Grid *);
< #endif
---
>  void  BlondinCooling (Data_Arr, double, timeStep *, Grid *);
>  #endif
244c263
<                              const State_1D *state, const Grid *grid);
---
>                              const Sweep *sweep, const Grid *grid);
251c270
< void SoundSpeed2 (double **, double *, double *, int, int,  int, Grid *);
---
> void SoundSpeed2 (const State *, int, int, int, Grid *);
diff Src/rbox.c ../old/rbox.c
4c4
<   \brief Basic RBox database.
---
>   \brief Collects various functions to operate on the RBox structure.
6,22c6,15
<   The function SetRBox() defines an array of predefined RBox structures 
<   needed to loop through different portions (or regions) of the 
<   computational domain.
<   
<   - rbox_center: an array of RBoxes for looping over the cell-centered data.
<   - rbox_x1face: an array of RBoxes for looping over the X1-staggered data.
<   - rbox_x2face: an array of RBoxes for looping over the X2-staggered data.
<   - rbox_x3face: an array of RBoxes for looping over the X3-staggered data.
<  
<   Each array of structures has 8 elements corresponding to the six sides
<   of the computational domain (X1_BEG, ... , X3_END) and, in addition, 
<   we also define the DOM and TOT array indices to loop over the active 
<   computational zones or over the total
<   computational domain (interior + ghost zones), respectively.
< 
<   The function GetRBox() can be used to retrieve a pointer to a RBox
<   structure given the computational side and the variable position.
---
>   - RBoxDefine() is used to set the box extent in terms of six
>     indices (beg..end for each direction) and the variable location
>     inside the cell.
> 
>   - RBoxSetDirections() is used to set normal, tangent and binormal indices
>     with respect to the specified (sweeping) direction.
>     The convention adopted here is the same one used for vector indices
>     permutation in PLUTO: <tt> (i,j,k) -> (j,i,k) -> (k,i,j) </tt>.
>     Useful for sweeping along different directions during the time stepping
>     routines.
25c18
<   \date   May 13, 2015
---
>   \date   Nov 13, 2015
30,31d22
< static RBox rbox_center[8], rbox_x1face[8], rbox_x2face[8], rbox_x3face[8];
< 
33c24
< void SetRBox(void)
---
> void RBoxDefine(int ib, int ie, int jb, int je, int kb, int ke, int vpos, RBox *box)
35c26,35
<  *
---
>  * 
>  * \param [in]  ib    leftmost  index in the X1 direction
>  * \param [in]  ie    rightmost index in the X1 direction
>  * \param [in]  jb    leftmost  index in the X2 direction
>  * \param [in]  je    rightmost index in the X2 direction
>  * \param [in]  kb    leftmost  index in the X3 direction
>  * \param [in]  ke    rightmost index in the X3 direction
>  * \param [in] vpos   the variable location inside the cell
>  *                    (CENTER/X1FACE/.../X3FACE)
>  * \param [out] box   pointer to a RBox structure
39,135c39,40
<   int s;
< 
< /* ---------------------------------------------------
<     0. Set X1_BEG grid index ranges
<    --------------------------------------------------- */
< 
<   s = X1_BEG; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
< 
<   rbox_center[s].ib = IBEG-1; rbox_center[s].ie =         0;
<   rbox_center[s].jb =      0; rbox_center[s].je = NX2_TOT-1;
<   rbox_center[s].kb =      0; rbox_center[s].ke = NX3_TOT-1;
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(rbox_x1face[s].ib--; rbox_x1face[s].ie--;  ,
<             rbox_x2face[s].jb--;                       ,
<             rbox_x3face[s].kb--;)
<   #endif
< 
< /* ---------------------------------------------------
<     1. set X1_END grid index ranges
<    --------------------------------------------------- */
<   
<   s = X1_END; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
< 
<   rbox_center[s].ib = IEND+1; rbox_center[s].ie = NX1_TOT-1;
<   rbox_center[s].jb =      0; rbox_center[s].je = NX2_TOT-1;
<   rbox_center[s].kb =      0; rbox_center[s].ke = NX3_TOT-1;
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(                   ;   ,
<             rbox_x2face[s].jb--;   ,
<             rbox_x3face[s].kb--;)
<   #endif
< 
< /* ---------------------------------------------------
<     2. set X2_BEG grid index ranges
<    --------------------------------------------------- */
< 
<   s = X2_BEG; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
< 
<   rbox_center[s].ib =      0; rbox_center[s].ie = NX1_TOT-1;
<   rbox_center[s].jb = JBEG-1; rbox_center[s].je =         0;
<   rbox_center[s].kb =      0; rbox_center[s].ke = NX3_TOT-1;
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(rbox_x1face[s].ib--;                       ,
<             rbox_x2face[s].jb--; rbox_x2face[s].je--;  ,
<             rbox_x3face[s].kb--;)
<   #endif
< 
< /* ---------------------------------------------------
<     3. set X2_END grid index ranges
<    --------------------------------------------------- */
<   
<   s = X2_END; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
< 
<   rbox_center[s].ib =      0; rbox_center[s].ie = NX1_TOT-1;
<   rbox_center[s].jb = JEND+1; rbox_center[s].je = NX2_TOT-1;
<   rbox_center[s].kb =      0; rbox_center[s].ke = NX3_TOT-1;
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(rbox_x1face[s].ib--;    ,
<                                ;    ,
<             rbox_x3face[s].kb--;)
<   #endif
---
>   box->ibeg = ib;
>   box->iend = ie;
137,139c42,43
< /* ---------------------------------------------------
<     4. set X3_BEG grid index ranges
<    --------------------------------------------------- */
---
>   box->jbeg = jb;
>   box->jend = je;
141,219c45,49
<   s = X3_BEG; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
< 
<   rbox_center[s].ib =      0; rbox_center[s].ie = NX1_TOT-1;
<   rbox_center[s].jb =      0; rbox_center[s].je = NX2_TOT-1;
<   rbox_center[s].kb = KBEG-1; rbox_center[s].ke =         0;
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(rbox_x1face[s].ib--;   ,
<             rbox_x2face[s].jb--;   ,
<             rbox_x3face[s].kb--; rbox_x3face[s].ke--;)
<   #endif
< 
< /* ---------------------------------------------------
<     5.  set X3_END grid index ranges
<    --------------------------------------------------- */
<   
<   s = X3_END; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
< 
<   rbox_center[s].ib =      0; rbox_center[s].ie = NX1_TOT-1; 
<   rbox_center[s].jb =      0; rbox_center[s].je = NX2_TOT-1; 
<   rbox_center[s].kb = KEND+1; rbox_center[s].ke = NX3_TOT-1; 
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(rbox_x1face[s].ib--;      ,
<             rbox_x2face[s].jb--;      ,
<                                ;)
<   #endif
< 
< /* ---------------------------------------------------
<     6. set DOM index ranges
<    --------------------------------------------------- */
<   
<   s = DOM; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
<   rbox_center[s].ib = IBEG; rbox_center[s].ie = IEND; 
<   rbox_center[s].jb = JBEG; rbox_center[s].je = JEND; 
<   rbox_center[s].kb = KBEG; rbox_center[s].ke = KEND; 
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
< 
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
< 
<    D_EXPAND(rbox_x1face[s].ib--;   ,
<             rbox_x2face[s].jb--;   ,
<             rbox_x3face[s].kb--;)
<   #endif
< 
< /* ---------------------------------------------------
<     7. set TOT index ranges
<    --------------------------------------------------- */
<   
<   s = TOT; s -= X1_BEG;
< 
<   rbox_center[s].vpos = CENTER;
<   rbox_center[s].ib = 0; rbox_center[s].ie = NX1_TOT-1; 
<   rbox_center[s].jb = 0; rbox_center[s].je = NX2_TOT-1; 
<   rbox_center[s].kb = 0; rbox_center[s].ke = NX3_TOT-1; 
< 
<   rbox_x1face[s] = rbox_x2face[s] = rbox_x3face[s] = rbox_center[s];
---
>   box->kbeg = kb;
>   box->kend = ke;
>  
>   box->vpos = vpos;   
> }
221,224c51,78
<   #ifndef CHOMBO /* -- useless for AMR -- */
<    rbox_x1face[s].vpos = X1FACE;
<    rbox_x2face[s].vpos = X2FACE;
<    rbox_x3face[s].vpos = X3FACE;
---
> /* ********************************************************************* */
> void RBoxSetDirections(RBox *box, int dir)
> /*!
>  * Set normal, tangent and binormal directions while sweeping
>  * across a box using the BOX_TRANSVERSE_LOOP macro;
>  *
>  * \param [in,out]  box  pointer to a RBox structure
>  * \param [in]      dir  the sweeping direction giving the normal direction
>  *                       and respect to which assign the tangent and binormal
>  *                       indices.
>  *********************************************************************** */
> {
>   if (dir == IDIR){
>     box->nbeg = &(box->ibeg); box->nend = &(box->iend);
>     box->tbeg = &(box->jbeg); box->tend = &(box->jend);
>     box->bbeg = &(box->kbeg); box->bend = &(box->kend);
>   }else if (dir == JDIR){
>     box->nbeg = &(box->jbeg); box->nend = &(box->jend);
>     box->tbeg = &(box->ibeg); box->tend = &(box->iend);
>     box->bbeg = &(box->kbeg); box->bend = &(box->kend);
>   }else if (dir == KDIR){
>     box->nbeg = &(box->kbeg); box->nend = &(box->kend);
>     box->tbeg = &(box->ibeg); box->tend = &(box->iend);
>     box->bbeg = &(box->jbeg); box->bend = &(box->jend);
>   }else{
>     print ("! RBoxSetDirections(): invalid dir = %d\n",dir);
>     QUIT_PLUTO(1);
>   }
226,229d79
<    D_EXPAND(rbox_x1face[s].ib--;   ,
<             rbox_x2face[s].jb--;   ,
<             rbox_x3face[s].kb--;)
<   #endif
230a81
> 
232,234c83,84
< RBox *GetRBox(int side, int vpos)
< /*!
<  *  Returns a pointer to a local static RBox 
---
> void RBoxShow(RBox *box)
> /*
236,240d85
<  *  \param[in]  side  the region of the computational domain where 
<  *                    the box is required. There 8 possible values:
<  *                    X1_BEG, ... , X3_END, DOM, TOT.
<  *  \param[in]  vpos  the variable position inside the cell:
<  *                    CENTER, X1FACE, X2FACE or X3FACE.
244,247c89,94
<   if      (vpos == CENTER) return &(rbox_center[side-X1_BEG]);
<   else if (vpos == X1FACE) return &(rbox_x1face[side-X1_BEG]);
<   else if (vpos == X2FACE) return &(rbox_x2face[side-X1_BEG]);
<   else if (vpos == X3FACE) return &(rbox_x3face[side-X1_BEG]);
---
>   print ("===============================================================\n");
>   print (" (ibeg, iend) = (%d, %d)\n",box->ibeg, box->iend);
>   print (" (jbeg, jend) = (%d, %d)\n",box->jbeg, box->jend);
>   print (" (kbeg, kend) = (%d, %d)\n",box->kbeg, box->kend);
>   print ("===============================================================\n");
>  
249d95
< 
diff Src/restart.c ../old/restart.c
11c11
<   \date   Aug 24, 2015
---
>   \date   DEc 21, 2016
23,25c23,25
<  * \param [in] type specifies the output data type (type should be 
<  *             either DBL_OUTPUT or DBL_H5_OUTPUT).
<  * \param [in]      grid  pointer to an array of Grid structures
---
>  * \param [in] type       specifies the output data type (type should be 
>  *                        either DBL_OUTPUT or DBL_H5_OUTPUT).
>  * \param [in] grid       pointer to an array of Grid structures
62c62
<       print1 ("! Restart: cannot find dbl.out or dbl.h5.out\n");
---
>       print ("! RestartFromFile(): cannot find dbl.out or dbl.h5.out\n");
69c69,70
<       printf ("! Restart: position too large\n");
---
>       print ("! RestartFromFile(): output #%d does not exist in file %s\n",
>              nrestart, fout);
78c79
<       print1 ("> Restart: endianity is reversed\n");
---
>       print ("> RestartFromFile(): endianity is reversed\n");
98c99
<   print1 ("> restarting from file #%d (dbl)\n",output->nfile);
---
>   print ("> Restarting from file #%d (dbl)\n",output->nfile);
112c113
<      fbin = OpenBinaryFile (fname, 0, "r");
---
>      fbin = FileOpen (fname, 0, "r");
131c132
<        fbin = OpenBinaryFile (fname, sz, "r");
---
>        fbin = FileOpen (fname, sz, "r");
134,135c135,136
<       ReadBinaryArray (Vpt, sizeof(double), sz, fbin,
<                        output->stag_var[nv], swap_endian);
---
>       FileReadData (Vpt, sizeof(double), sz, fbin,
>                     output->stag_var[nv], swap_endian);
138c139
<        CloseBinaryFile(fbin, sz);
---
>        FileClose(fbin, sz);
142c143
<      CloseBinaryFile(fbin, sz);
---
>      FileClose(fbin, sz);
166,169c167,170
<       fbin = OpenBinaryFile (fname, sz, "r");
<       ReadBinaryArray (Vpt, sizeof(double), sz, fbin,
<                        output->stag_var[nv], swap_endian);
<       CloseBinaryFile (fbin, sz);
---
>       fbin = FileOpen (fname, sz, "r");
>       FileReadData (Vpt, sizeof(double), sz, fbin,
>                     output->stag_var[nv], swap_endian);
>       FileClose (fbin, sz);
191c192
<     printf ("! negative restart file temporarily disabled\n");
---
>     print ("! RestartGet(): negative restart file temporarily disabled\n");
207c208
<       print1 ("! RestartGet: cannot find restart.out\n");
---
>       print ("! RestartGet(): cannot find restart.out\n");
215c216
<         print("! RestartGet: end of file encountered.\n");
---
>         print("! RestartGet(): end of file encountered.\n");
238,240c239,241
<   #ifdef PARALLEL
<    MPI_Bcast (&restart, sizeof (Restart), MPI_BYTE, 0, MPI_COMM_WORLD);
<   #endif
---
> #ifdef PARALLEL
>   MPI_Bcast (&restart, sizeof (Restart), MPI_BYTE, 0, MPI_COMM_WORLD);
> #endif
248a250,257
> 
> /* -- Check that tstop > g_time -- */
> 
>   if (RuntimeGet()->tstop < g_time){
>     print ("! RestartGet(): tstop = %f < g_time = %f\n",
>             RuntimeGet()->tstop, g_time);
>     QUIT_PLUTO(1);
>   }
278,279c287,288
<   if (prank == 0) {
<     sprintf (fout,"%s/restart.out",ini->output_dir);
---
>   if (prank == 0) {   /* Only processor 0 does the writing */
>     sprintf (fout,"%s/restart.out",ini->output_dir); /* File name */
diff Src/rkc.c ../old/rkc.c
58c58
< void RKC (const Data *d, Time_Step *Dts, Grid *grid)
---
> void RKC (const Data *d, timeStep *Dts, Grid *grid)
63c63
<  * \param [in,out]  Dts  pointer to Time_Step structure  
---
>  * \param [in,out]  Dts  pointer to timeStep structure  
171c171
<     print1 ("! RKC: outside parameter range\n");
---
>     print ("! RKC: outside parameter range\n");
Only in ../old: rkl.c
diff Src/runtime_setup.c ../old/runtime_setup.c
10c10
<   \date    Aug 24, 2015
---
>   \date    March 16, 2018
40,41d39
<   char  *brat_label[] = {"X1-rat", "X2-rat","X3-rat"};
<   
77,78d74
< 	
< 	//Loop over dimensions
81,82c77,78
<       runtime->patch_left_node[idim][ip] = atof(ParamFileGet(glabel[idim], ++ipos)); //Inner edge	  
<       runtime->patch_npoint[idim][ip]    = atoi(ParamFileGet(glabel[idim], ++ipos));  //Number of points
---
>       runtime->patch_left_node[idim][ip] = atof(ParamFileGet(glabel[idim], ++ipos));
>       runtime->patch_npoint[idim][ip]    = atoi(ParamFileGet(glabel[idim], ++ipos));
99,100d94
<       }else if (strcmp(str_var,"r") == 0){
<         runtime->patch_type[idim][ip] = RATIO_GRID;
102c96
<         printf ("\nSetup: You must specify either 'u', 's', 'l+', 'l-' or 'r' as grid-type in %s\n",
---
>         printf ("\nSetup(): You must specify either 'u', 's', 'l+' or 'l-' as grid-type in %s\n",
108,117c102
<     runtime->patch_left_node[idim][ip] = atof(ParamFileGet(glabel[idim], ++ipos)); //Outer edge
< 	
< 	if (runtime->patch_type[idim][ip-1] == RATIO_GRID)
< 	{
< 	    runtime->ratio[idim] = atof(ParamFileGet(glabel[idim], ++ipos)); //Ratio
< 		ipos--;
< 		
< 	}
< 	
< 	
---
>     runtime->patch_left_node[idim][ip] = atof(ParamFileGet(glabel[idim], ++ipos));
120c105
<       printf ("! Setup: domain #%d setup is not properly defined \n", idim);
---
>       printf ("! Setup(): domain #%d setup is not properly defined \n", idim);
124c109
<       printf ("! Setup: %d point(s) on dim. %d is NOT valid, resetting to 1\n",
---
>       printf ("! Setup(): %d point(s) on dim. %d is NOT valid, resetting to 1\n",
140c125
<         printf ("! Setup: -xres option works on uniform, single patch grid\n");
---
>         printf ("! Setup(): -xres option works on uniform, single patch grid\n");
182c167
<       printf ("! Setup: don't know how to put left boundary '%s'  \n", str);
---
>       printf ("! Setup(): don't know how to put left boundary '%s'  \n", str);
193c178
<       printf ("! Setup: don't know how to put left boundary '%s'  \n", str);
---
>       printf ("! Setup(): don't know how to put left boundary '%s'  \n", str);
209c194
<       printf ("! Setup: missing name after user var name '%s'\n", 
---
>       printf ("! Setup(): missing name after user var name '%s'\n", 
228,230c213,215
<     printf ("! Setup: cannot access directory '%s'.\n", runtime->output_dir);
<     printf ("!        Please check that the directory exists\n");
<     printf ("!        and you have write permission.\n");
---
>     printf ("! Setup(): cannot access directory '%s'.\n", runtime->output_dir);
>     printf ("!          Please check that the directory exists\n");
>     printf ("!          and you have write permission.\n");
238c223
< 
---
>   
239a225
> 
246,261c232,237
<   #ifdef USE_ASYNC_IO
<    if (    strcmp(output->mode,"single_file") 
<         && strcmp(output->mode,"single_file_async")
<         && strcmp(output->mode,"multiple_files")){
<       printf ("! Setup: expecting 'single_file', 'single_file_async' ");
<       printf ("or 'multiple_files' in dbl output\n");
<       QUIT_PLUTO(1);
<    }
<   #else
<    if (   strcmp(output->mode,"single_file")
<        && strcmp(output->mode,"multiple_files")){
<       printf (
<       "! Setup: expecting 'single_file' or 'multiple_files' in dbl output\n");
<       QUIT_PLUTO(1);
<    }     
<   #endif
---
>   if (   strcmp(output->mode,"single_file")
>       && strcmp(output->mode,"multiple_files")){
>      printf (
>      "! Setup(): expecting 'single_file' or 'multiple_files' in dbl output\n");
>      QUIT_PLUTO(1);
>   }     
271,286c247,252
<     #ifdef USE_ASYNC_IO
<      if (    strcmp(output->mode,"single_file") 
<           && strcmp(output->mode,"single_file_async")
<           && strcmp(output->mode,"multiple_files")){
<         printf ("! Setup: expecting 'single_file', 'single_file_async' ");
<         printf ("or 'multiple_files' in flt output\n");
<         QUIT_PLUTO(1);
<      }
<     #else
<      if (    strcmp(output->mode,"single_file") 
<           && strcmp(output->mode,"multiple_files")){
<         printf (
<         "! Setup: expecting 'single_file' or 'multiple_files' in flt output\n");
<         QUIT_PLUTO(1);
<      }  
<     #endif
---
>     if (    strcmp(output->mode,"single_file") 
>          && strcmp(output->mode,"multiple_files")){
>        printf (
>        "! Setup(): expecting 'single_file' or 'multiple_files' in flt output\n");
>        QUIT_PLUTO(1);
>     }  
314c280
<       printf ("! Setup: extra field missing in vtk output\n");
---
>       printf ("! Setup(): extra field missing in vtk output\n");
320,321c286,287
<        printf ("! Setup: expecting 'single_file' or 'multiple_files' in\n");
<        printf ("         vtk output\n");
---
>        printf ("! Setup(): expecting 'single_file' or 'multiple_files' in\n");
>        printf ("           vtk output\n");
356d321
< 
358a324,329
>   strcpy (runtime->log_dir, runtime->output_dir);
>   if (ParamExist ("log_dir")){
>     str = ParamFileGet("log_dir",1);
>     sprintf (runtime->log_dir, "%s",str);
>   }
>   
361a333,426
>  /* -- analysis -- */
> 
>   if (ParamExist ("analysis")){
>     runtime->anl_dt = atof(ParamFileGet("analysis", 1));
>     runtime->anl_dn = atoi(ParamFileGet("analysis", 2));
>   }else{
>     runtime->anl_dt = -1.0;   /* -- defaults -- */
>     runtime->anl_dn = -1;
>   }
> #endif /* #ifndef CHOMBO */
> 
> /* ------------------------------------------------------------
>    [Particles] Section 
>    ------------------------------------------------------------ */
> 
> #ifdef PARTICLES
> 
>   runtime->Nparticles_glob = atoi(ParamFileGet("Nparticles", 1));
>   runtime->Nparticles_cell = atoi(ParamFileGet("Nparticles", 2));
>   
>   if (runtime->Nparticles_glob > 0 && runtime->Nparticles_cell > 0){
>     printf ("! Incorrect number of particles\n");
>     QUIT_PLUTO(1);
>   }
> 
>  /* ---- particles dbl output ---- */
> 
>   if (ParamExist("particles_dbl")){
>     output = runtime->output + (ipos++);
>     output->type  = PARTICLES_DBL_OUTPUT;
>     GetOutputFrequency(output, "particles_dbl");
>   }
> 
> /* ---- particles flt output ---- */
> 
>   if (ParamExist("particles_flt")){
>     output = runtime->output + (ipos++);
>     output->type  = PARTICLES_FLT_OUTPUT;
>     GetOutputFrequency(output, "particles_flt");
>   }
> 
> /* ---- particles vtk output ---- */
> 
>   if (ParamExist("particles_vtk")){
>     output = runtime->output + (ipos++);
>     output->type  = PARTICLES_VTK_OUTPUT;
>     GetOutputFrequency(output, "particles_vtk");
>   }
> 
> /* ---- particles tab output ---- */
> 
>   if (ParamExist("particles_tab")){
>     output = runtime->output + (ipos++);
>     output->type  = PARTICLES_TAB_OUTPUT;
>     GetOutputFrequency(output, "particles_tab");
>   }
> 
> /* ---- particles h5part output ---- */
> 
>   if (ParamExist("particles_hdf5")){
>     output = runtime->output + (ipos++);
>     output->type  = PARTICLES_HDF5_OUTPUT;
>     GetOutputFrequency(output, "particles_hdf5");
>   }
> 
> /* ---- particles analysis ---- */
> 
>   if (ParamExist("particles_analysis")){
>    runtime->particles_anl_dt = atof(ParamFileGet("particles_analysis", 1));
>    runtime->particles_anl_dn = atoi(ParamFileGet("particles_analysis", 2));
>    }else{
>     runtime->particles_anl_dt = -1.0;   /* -- defaults -- */
>     runtime->particles_anl_dn = -1;
>   }
>   
> 
> /*
>   runtime->particles_dbl_dt = atof(ParamFileGet("particles_dbl", 1));
>   runtime->particles_dbl_dn = atoi(ParamFileGet("particles_dbl", 2));
> 
>   runtime->particles_tab_dt = atof(ParamFileGet("particles_tab", 1));
>   runtime->particles_tab_dn = atoi(ParamFileGet("particles_tab", 2));
> 
>   runtime->particles_vtu_dt = atof(ParamFileGet("particles_vtu", 1));
>   runtime->particles_vtu_dn = atoi(ParamFileGet("particles_vtu", 2));
> 
>   runtime->particles_vtk_dt = atof(ParamFileGet("particles_vtk", 1));
>   runtime->particles_vtk_dn = atoi(ParamFileGet("particles_vtk", 2));
> 
>   runtime->particles_anl_dt = atof(ParamFileGet("particles_analysis", 1));
>   runtime->particles_anl_dn = atoi(ParamFileGet("particles_analysis", 2));
> */
> #endif
> 
374,384d438
<  /* -- analysis -- */
< 
<   if (ParamExist ("analysis")){
<     runtime->anl_dt = atof(ParamFileGet("analysis", 1));
<     runtime->anl_dn = atoi(ParamFileGet("analysis", 2));
<   }else{
<     runtime->anl_dt = -1.0;   /* -- defaults -- */
<     runtime->anl_dn = -1;
<   }
< #endif
< 
404c458
<     printf ("! Setup: cannot access directory '%s'.\n", runtime->output_dir);
---
>     printf ("! Setup(): cannot access directory '%s'.\n", runtime->output_dir);
diff Src/set_geometry.c ../old/set_geometry.c
10c10
<   \date   Dec 12, 2013
---
>   \date   March 13, 2017
16c16
< void MakeGeometry (Grid *GXYZ)
---
> void MakeGeometry (Grid *grid)
19c19
<  * \param [in,out] GXYZ  Pointer to an array of Grid structures;
---
>  * \param [in,out] grid  Pointer to an array of Grid structures;
23,40c23,61
<   int     i, j, k, idim, ngh, ileft;
<   int     iright;
<   int     iend, jend, kend;
<   double  xiL, xiR, dxi, dvol;
<   double  x, dx, xr, xl;
<   double  y, dy, yr, yl;
<   struct  GRID *GG;
< 
<   iend = GXYZ[0].lend + GXYZ[0].nghost;
<   jend = GXYZ[1].lend + GXYZ[1].nghost;
<   kend = GXYZ[2].lend + GXYZ[2].nghost;
< 
< /*  --------------------------------------------------------------
<      Memory allocation. All values are defined at the cell center 
<      with the exception of the area element which is defined on a
<      staggered mesh and therefore starts at [-1].
<     ----------------------------------------------------------- */
< 
---
>   int     i, j, k, idim;
>   int     iend = grid->lend[IDIR] + grid->nghost[IDIR];
>   int     jend = grid->lend[JDIR] + grid->nghost[JDIR];
>   int     kend = grid->lend[KDIR] + grid->nghost[KDIR];
>   int     nx1_tot = grid->np_tot[IDIR];
>   int     nx2_tot = grid->np_tot[JDIR];
>   int     nx3_tot = grid->np_tot[KDIR];
>   double  dVr, dmu, xL, xR;
> 
>   double *x1 = grid->x[IDIR], *dx1 = grid->dx[IDIR];
>   double *x2 = grid->x[JDIR], *dx2 = grid->dx[JDIR];
>   double *x3 = grid->x[KDIR], *dx3 = grid->dx[KDIR];
> 
>   double *x1p = grid->xr[IDIR], *x1m = grid->xl[IDIR];
>   double *x2p = grid->xr[JDIR], *x2m = grid->xl[JDIR];
>   double *x3p = grid->xr[KDIR], *x3m = grid->xl[KDIR];
> 
>   double ***Ax1, ***Ax2, ***Ax3;
> 
> /* --------------------------------------------------------------
>    0. Allocate memory for the Grid structue.
>       All values are defined at the cell center 
>       with the exception of the area element which is defined on a
>       staggered mesh and therefore starts at [-1].
>    ----------------------------------------------------------- */
> 
>   grid->dV      = ARRAY_3D(nx3_tot, nx2_tot, nx1_tot, double);
>   grid->A[IDIR] = ArrayBox( 0, nx3_tot-1,  0, nx2_tot-1, -1, nx1_tot-1);
>   grid->A[JDIR] = ArrayBox( 0, nx3_tot-1, -1, nx2_tot-1,  0, nx1_tot-1);
>   grid->A[KDIR] = ArrayBox(-1, nx3_tot-1,  0, nx2_tot-1,  0, nx1_tot-1);
> 
>   grid->dx_dl[IDIR] = ARRAY_2D(nx2_tot, nx1_tot, double);
>   grid->dx_dl[JDIR] = ARRAY_2D(nx2_tot, nx1_tot, double);
>   grid->dx_dl[KDIR] = ARRAY_2D(nx2_tot, nx1_tot, double);
>   
>   grid->rt  = ARRAY_1D(grid->np_tot[IDIR], double);
>   grid->sp  = ARRAY_1D(grid->np_tot[JDIR], double);
>   grid->s   = ARRAY_1D(grid->np_tot[JDIR], double);
>   grid->dmu = ARRAY_1D(grid->np_tot[JDIR], double);
42,48c63,104
<     (GXYZ + idim)->A       = ARRAY_1D (GXYZ[idim].np_tot+1, double)+1;
<     (GXYZ + idim)->xgc     = ARRAY_1D (GXYZ[idim].np_tot, double);
<     (GXYZ + idim)->dV      = ARRAY_1D (GXYZ[idim].np_tot, double);
<     (GXYZ + idim)->r_1     = ARRAY_1D (GXYZ[idim].np_tot, double);
<     (GXYZ + idim)->ct      = ARRAY_1D (GXYZ[idim].np_tot, double);
<     (GXYZ + idim)->inv_dx  = ARRAY_1D (GXYZ[idim].np_tot, double);
<     (GXYZ + idim)->inv_dxi = ARRAY_1D (GXYZ[idim].np_tot, double);
---
>     grid->xgc[idim]     = ARRAY_1D(grid->np_tot[idim], double);
>     grid->inv_dx[idim]  = ARRAY_1D(grid->np_tot[idim], double);
>     grid->inv_dxi[idim] = ARRAY_1D(grid->np_tot[idim], double);
>   }
> 
> /* ----------------------------------------------------------
>    1a. Compute positions arrays in the X1 (IDIR) direction
>    ---------------------------------------------------------- */
> 
>   for (i = 0; i <= iend; i++){
>     xL = x1m[i];
>     xR = x1p[i];
>     #if GEOMETRY == CARTESIAN
>     grid->xgc[IDIR][i] = x1[i];
>     grid->rt[i]        = x1[i];
>     #elif GEOMETRY == CYLINDRICAL || GEOMETRY == POLAR
>     grid->xgc[IDIR][i] = x1[i] + dx1[i]*dx1[i]/(12.0*x1[i]); 
>     grid->rt[i]        = x1[i];
>     #elif GEOMETRY == SPHERICAL
>     grid->xgc[IDIR][i] = x1[i] + 2.0*x1[i]*dx1[i]*dx1[i]/
>                                 (12.0*x1[i]*x1[i] + dx1[i]*dx1[i]);
>     grid->rt[i]  = (xR*xR*xR - xL*xL*xL)/(xR*xR - xL*xL)/1.5;
>     #endif
>   }
> 
> /* ----------------------------------------------------------
>    1b. Compute positions arrays in the X2 (JDIR) direction
>    ---------------------------------------------------------- */
> 
>   for (j = 0; j <= jend; j++){
>     xL = x2m[j];
>     xR = x2p[j];
> 
>     #if GEOMETRY != SPHERICAL
>     grid->xgc[JDIR][j] = x2[j];
>     #else
>     grid->xgc[JDIR][j]  = sin(xR) - sin(xL)+ xL*cos(xL) - xR*cos(xR);
>     grid->xgc[JDIR][j] /= cos(xL) - cos(xR);
>     grid->sp[j]         = fabs(sin(xR));
>     grid->s[j]          = fabs(sin(x2[j]));
>     grid->dmu[j]        = fabs(cos(xL) - cos(xR));
>     #endif
52,59c108,113
<     Define area (A), volume element (dV) and cell geometrical
<     centers for each direction.
<     
<     Conventions:
<     - G->dx: spacing (always > 0)
<     - G->x:  cell-center. Can be > 0 or < 0
<     - G->xgc: geometrical cell center.
<     ----------------------------------------------------------- */  
---
>    1c. Compute positions arrays in the X3 (KDIR) direction
>    ------------------------------------------------------------ */
> 
>   for (k = 0; k <= kend; k++){
>     grid->xgc[KDIR][k] = x3[k];
>   }
62c116
<                      X1 (IDIR) Direction
---
>    2. Compute volumes 
64,71d117
<  
<   GG = GXYZ;
<   for (i = 0; i <= iend; i++) {
< 
<     dx  = GG->dx[i];
<     x   = GG->x[i];
<     xr  = x + 0.5*dx;
<     xl  = x - 0.5*dx;
72a119,121
>   for (k = 0; k <= kend; k++){
>   for (j = 0; j <= jend; j++){
>   for (i = 0; i <= iend; i++){
74,83c123,129
<      GG->A[i]    = 1.0;
<      if (i == 0) GG->A[-1] = 1.0;
<      GG->dV[i]  = dx;
<      GG->xgc[i] = x;
<     #elif GEOMETRY == CYLINDRICAL || GEOMETRY == POLAR
<      GG->A[i]   = fabs(xr); 
<      if (i == 0) GG->A[-1] = fabs(xl);
<      GG->dV[i]  = fabs(x)*dx;
<      GG->xgc[i] = x + dx*dx/(12.0*x); 
<      GG->r_1[i] = 1.0/x;
---
>     grid->dV[k][j][i]  = D_EXPAND(dx1[i], *dx2[j], *dx3[k]);  /* = dx*dy*dz */
>     #elif GEOMETRY == CYLINDRICAL
>     dVr = fabs(x1[i])*dx1[i];
>     grid->dV[k][j][i]  = D_EXPAND(dVr, *dx2[j], *1.0);        /* = |r|*dr*dz */
>     #elif GEOMETRY == POLAR
>     dVr = fabs(x1[i])*dx1[i];
>     grid->dV[k][j][i]  = D_EXPAND(dVr, *dx2[j], *dx3[k]);     /* = |r|*dr*dphi*dz */
85,86c131,135
<      GG->A[i]   = xr*xr;
<      if (i == 0) GG->A[-1] = xl*xl;
---
>     dVr = fabs(x1p[i]*x1p[i]*x1p[i] - x1m[i]*x1m[i]*x1m[i])/3.0;
>     dmu = fabs(cos(x2m[j]) - cos(x2p[j]));
>     grid->dV[k][j][i]  = D_EXPAND(dVr, *dmu, *dx3[k]);        /* = dVr*dmu*dphi*/
>     #endif
>   }}}
88,90c137,168
<      GG->dV[i]  = fabs(xr*xr*xr - xl*xl*xl)/3.0;
<      GG->xgc[i] = x + 2.0*x*dx*dx/(12.0*x*x + dx*dx);
<      GG->r_1[i] = 1.0/x;
---
> /* ------------------------------------------------------------
>    3a. Compute area in the x1-direction
>    ------------------------------------------------------------ */
> 
>   Ax1 = grid->A[IDIR];
>   Ax2 = grid->A[JDIR];
>   Ax3 = grid->A[KDIR];
> 
>   for (k =  0; k <= kend; k++){
>   for (j =  0; j <= jend; j++){
>   for (i = -1; i <= iend; i++){
>     #if GEOMETRY == CARTESIAN
>     Ax1[k][j][i] = D_EXPAND(1.0, *dx2[j], *dx3[k]);         /* = dy*dz */ 
>     #elif GEOMETRY == CYLINDRICAL
>     if (i == -1) {
>       Ax1[k][j][i] = D_EXPAND(fabs(x1m[0]), *dx2[j], *1.0); /* = rp*dz */
>     }else{
>       Ax1[k][j][i] = D_EXPAND(fabs(x1p[i]), *dx2[j], *1.0); /* = rp*dz */
>     }
>     #elif GEOMETRY == POLAR
>     if (i == -1) {
>       Ax1[k][j][i] = D_EXPAND(fabs(x1m[0]), *dx2[j], *dx3[k]); /* = rp*dphi*dz */
>     }else{
>       Ax1[k][j][i] = D_EXPAND(fabs(x1p[i]), *dx2[j], *dx3[k]); /* = rp*dphi*dz */
>     }
>     #elif GEOMETRY == SPHERICAL
>     dmu = fabs(cos(x2m[j]) - cos(x2p[j]));
>     if (i == -1) {
>       Ax1[k][j][i] = D_EXPAND(x1m[0]*x1m[0], *dmu, *dx3[k]); /* = rp^2*dmu*dphi */
>     }else{
>       Ax1[k][j][i] = D_EXPAND(x1p[i]*x1p[i], *dmu, *dx3[k]); /* = rp^2*dmu*dphi */
>     }
92c170
<   }
---
>   }}}
95c173
<                     X2 (JDIR) Direction
---
>    3b. Compute area in the x2-direction
98,99c176,192
<   GG = GXYZ + 1;
<   for (j = 0; j <= jend; j++) {
---
>   for (k =  0; k <= kend; k++){
>   for (j = -1; j <= jend; j++){
>   for (i =  0; i <= iend; i++){
>     #if GEOMETRY == CARTESIAN
>     Ax2[k][j][i] = D_EXPAND(dx1[i], *1.0, *dx3[k]);        /* = dx*dz */
>     #elif GEOMETRY == CYLINDRICAL
>     Ax2[k][j][i] = D_EXPAND(fabs(x1[i]), *dx1[i], *1.0);   /* = r*dr */
>     #elif GEOMETRY == POLAR
>     Ax2[k][j][i] = D_EXPAND(dx1[i], *1.0, *dx3[k]);        /* = dr*dz */    
>     #elif GEOMETRY == SPHERICAL
>     if (j == -1){
>       Ax2[k][j][i] = D_EXPAND(x1[i]*dx1[i], *fabs(sin(x2m[0])), *dx3[k]); /* = r*dr*sin(thp)*dphi */
>     }else{
>       Ax2[k][j][i] = D_EXPAND(x1[i]*dx1[i], *fabs(sin(x2p[j])), *dx3[k]); /* = r*dr*sin(thp)*dphi */
>     }
>     #endif
>   }}}
101,119c194,208
<     dx  = GG->dx[j];
<     x   = GG->x[j];
< 	
<     xr  = x + 0.5*dx;
<     xl  = x - 0.5*dx;
<     #if GEOMETRY != SPHERICAL
<      GG->A[j]   = 1.0;
<      if (j == 0) GG->A[-1] = 1.0;
<      GG->dV[j]  = dx;    
<      GG->xgc[j] = x;
<     
<     #else
<      GG->A[j]   = fabs(sin(xr));
<      if (j == 0) GG->A[-1] = fabs(sin(xl));
<      GG->dV[j]  = fabs(cos(xl) - cos(xr));
< 
<      GG->xgc[j]  = (sin(xr) - sin(xl) + xl*cos(xl) - xr*cos(xr));
<      GG->xgc[j] /= cos(xl) - cos(xr);
<      GG->ct[j]   = 1.0/tan(x);  /* (sin(xr) - sin(xl))/(cos(xl) - cos(xr)); */
---
> /* ------------------------------------------------------------
>    3c. Compute area in the x3-direction
>    ------------------------------------------------------------ */
> 
>   for (k = -1; k <= kend; k++){
>   for (j =  0; j <= jend; j++){
>   for (i =  0; i <= iend; i++){
>     #if GEOMETRY == CARTESIAN
>     Ax3[k][j][i] = D_EXPAND(dx1[i], *dx2[j], *1.0);          /* = dx*dy */ 
>     #elif GEOMETRY == CYLINDRICAL
>     Ax3[k][j][i] = 1.0;   /* No 3rd direction in cylindrical coords */
>     #elif GEOMETRY == POLAR
>     Ax3[k][j][i] = D_EXPAND(x1[i]*dx1[i], *dx2[j], *1.0);   /* = r*dr*dphi */        
>     #elif GEOMETRY == SPHERICAL
>     Ax3[k][j][i] = D_EXPAND(x1[i]*dx1[i], *dx2[j], *1.0);   /* = r*dr*dth */        
121c210
<   }
---
>   }}}
124c213
<                     X3 (KDIR) Direction
---
>    4a. Compute dx/dl in the x1-direction
126,138d214
<   
<   GG = GXYZ + 2;
<   for (k = 0; k <= kend; k++) {
<     dx  = GG->dx[k];
<     x   = GG->x[k];
<     xr  = x + 0.5*dx;
<     xl  = x - 0.5*dx;
< 
<     GG->A[k]   = 1.0;
<     if (k == 0) GG->A[-1] = 1.0;
<     GG->dV[k]  = dx;
<     GG->xgc[k] = x;
<   }
139a216,236
>   for (k =  0; k <= kend; k++){
>   for (j =  0; j <= jend; j++){
>   for (i =  0; i <= iend; i++){
>     #if GEOMETRY == CARTESIAN
>     grid->dx_dl[IDIR][j][i] = 1.0;
>     grid->dx_dl[JDIR][j][i] = 1.0;
>     grid->dx_dl[KDIR][j][i] = 1.0;
>     #elif GEOMETRY == CYLINDRICAL
>     grid->dx_dl[IDIR][j][i] = 1.0;
>     grid->dx_dl[JDIR][j][i] = 1.0;
>     #elif GEOMETRY == POLAR
>     grid->dx_dl[IDIR][j][i] = 1.0;
>     grid->dx_dl[JDIR][j][i] = 1.0/x1[i];
>     grid->dx_dl[KDIR][j][i] = 1.0;
>     #elif GEOMETRY == SPHERICAL
>     grid->dx_dl[IDIR][j][i] = 1.0;
>     grid->dx_dl[JDIR][j][i] = 1.0/grid->rt[i];
>     grid->dx_dl[KDIR][j][i] = dx2[j]/(grid->rt[i]*grid->dmu[j]);
>     #endif
>   }}}
>   
141,142c238,239
<     compute and store the reciprocal of cell spacing
<     between interfaces (inv_dx) and cell centers (inv_dxi)
---
>    5. Compute and store the reciprocal of cell spacing
>       between interfaces (inv_dx) and cell centers (inv_dxi)
146,147c243,244
<     for (i = 0; i < GXYZ[idim].np_tot; i++) {
<       GXYZ[idim].inv_dx[i] = 1.0/(GXYZ[idim].dx[i]);
---
>     for (i = 0; i < grid->np_tot[idim]; i++) {
>       grid->inv_dx[idim][i] = 1.0/(grid->dx[idim][i]);
150,152c247,248
<     for (i = 0; i < GXYZ[idim].np_tot-1; i++) {
<       GXYZ[idim].inv_dxi[i] = 2.0/(GXYZ[idim].dx[i] + GXYZ[idim].dx[i+1]);
< 	  
---
>     for (i = 0; i < grid->np_tot[idim]-1; i++) {
>       grid->inv_dxi[idim][i] = 2.0/(grid->dx[idim][i] + grid->dx[idim][i+1]);
154c250
<   }
---
>   }  
167c263
<   return (grid[0].dx[i]);
---
>   return (grid->dx[IDIR][i]);
180,184c276,280
<   #if GEOMETRY == CARTESIAN || GEOMETRY == CYLINDRICAL
<    return (grid[1].dx[j]);
<   #elif GEOMETRY == POLAR ||  GEOMETRY == SPHERICAL
<    return (fabs(grid[0].xgc[i])*grid[1].dx[j]);
<   #endif
---
> #if GEOMETRY == CARTESIAN || GEOMETRY == CYLINDRICAL
>   return (grid->dx[JDIR][j]);
> #elif GEOMETRY == POLAR ||  GEOMETRY == SPHERICAL
>   return (fabs(grid->xgc[IDIR][i])*grid->dx[JDIR][j]);
> #endif
197,203c293,299
<   #if GEOMETRY == CARTESIAN || GEOMETRY == POLAR
<    return (grid[2].dx[k]);
<   #elif GEOMETRY == CYLINDRICAL
<    return (fabs(grid[0].xgc[i])*grid[2].dx[k]);
<   #elif GEOMETRY == SPHERICAL
<    return (fabs(grid[0].xgc[i]*sin(grid[1].xgc[j]))*grid[2].dx[k]);
<   #endif
---
> #if GEOMETRY == CARTESIAN || GEOMETRY == POLAR
>   return grid->dx[KDIR][k];
> #elif GEOMETRY == CYLINDRICAL
>   return fabs(grid->xgc[IDIR][i])*grid->dx[KDIR][k];
> #elif GEOMETRY == SPHERICAL
>   return fabs(grid->xgc[IDIR][i]*sin(grid->xgc[JDIR][j]))*grid->dx[KDIR][k];
> #endif
223c319
<   return grid[g_dir].inv_dx;
---
>   return grid->inv_dx[g_dir];
228c324
<     return grid[g_dir].inv_dx;
---
>     return grid->inv_dx[g_dir];
241,242c337,338
<     r_1 = grid[IDIR].r_1[g_i];
<     JTOT_LOOP(j) inv_dl[j] = grid[JDIR].inv_dx[j]*r_1;
---
>     r_1 = 1.0/grid->x[IDIR][g_i];
>     JTOT_LOOP(j) inv_dl[j] = grid->inv_dx[JDIR][j]*r_1;
263c359
<     return grid[IDIR].inv_dx;
---
>     return grid->inv_dx[IDIR];
265,266c361,362
<     r_1 = grid[IDIR].r_1[g_i];
<     JTOT_LOOP(j) inv_dl2[j] = grid[JDIR].inv_dx[j]*r_1;
---
>     r_1 = 1.0/grid->x[IDIR][g_i];
>     JTOT_LOOP(j) inv_dl2[j] = grid->inv_dx[JDIR][j]*r_1;
269,270c365,366
<     r_1 = grid[IDIR].r_1[g_i];
<     s   = grid[JDIR].x[g_j];
---
>     r_1 = 1.0/grid->x[IDIR][g_i];
>     s   = grid->x[JDIR][g_j];
272c368
<     KTOT_LOOP(k) inv_dl3[k] = grid[KDIR].inv_dx[k]*r_1/s;
---
>     KTOT_LOOP(k) inv_dl3[k] = grid->inv_dx[KDIR][k]*r_1/s;
diff Src/set_grid.c ../old/set_grid.c
11c11
<   \date   Aug 24, 2015
---
>   \date   March 13, 2017
21c21
< void SetGrid (Runtime *rtime, Grid *GXYZ)
---
> void SetGrid (Runtime *rtime, Grid *grid)
24,25c24,25
<  * \param [in]  rtime   pointer to a Runtime  structure
<  * \param [out] GXYZ    pointer to array of Grid structures
---
>  * \param [in]     rtime   pointer to a Runtime  structure
>  * \param [in/out] grid    pointer to Grid structure
33d32
<   Grid *G;
37c36
<   InitializeGrid(rtime, GXYZ);
---
>   InitializeGrid(rtime, grid);
46,47c45
<     G   = GXYZ + idim;
<     ngh = G->nghost;
---
>     ngh = grid->nghost[idim];
51c49
< /*MakeGrid (idim, rtime, G->xl_glob + iL, G->xr_glob + iL, G->dx_glob + iL); */
---
> /*MakeGrid (idim, rtime, grid->xl_glob + iL, grid->xr_glob + iL, grid->dx_glob + iL); */
56,58c54,56
<       G->dx_glob[i + ngh - 1] = dx[i];
<       G->xl_glob[i + ngh - 1] = xlft[i];
<       G->xr_glob[i + ngh - 1] = xrgt[i];
---
>       grid->dx_glob[idim][i + ngh - 1] = dx[i];
>       grid->xl_glob[idim][i + ngh - 1] = xlft[i];
>       grid->xr_glob[idim][i + ngh - 1] = xrgt[i];
64,65c62,63
<       G->xr_glob[iL - 1] = G->xl_glob[iL];
<       G->xl_glob[iR + 1] = G->xr_glob[iR];
---
>       grid->xr_glob[idim][iL - 1] = grid->xl_glob[idim][iL];
>       grid->xl_glob[idim][iR + 1] = grid->xr_glob[idim][iR];
73,75c71,74
<       G->dx_glob[i] = G->dx_glob[iL];
<       G->xl_glob[i] = G->xl_glob[iL] - (ngh - i)*G->dx_glob[iL];
<       G->xr_glob[i] = G->xl_glob[i] + G->dx_glob[iL];
---
>       grid->dx_glob[idim][i] = grid->dx_glob[idim][iL];
>       grid->xl_glob[idim][i] = grid->xl_glob[idim][iL]
>                                - (ngh - i)*grid->dx_glob[idim][iL];
>       grid->xr_glob[idim][i] = grid->xl_glob[idim][i] + grid->dx_glob[idim][iL];
79,81c78,80
<       G->dx_glob[iR + i + 1] = G->dx_glob[iR];
<       G->xl_glob[iR + i + 1] = G->xl_glob[iR] + (i + 1.0)*G->dx_glob[iR];
<       G->xr_glob[iR + i + 1] = G->xl_glob[iR] + (i + 2.0)*G->dx_glob[iR];
---
>       grid->dx_glob[idim][iR + i + 1] = grid->dx_glob[idim][iR];
>       grid->xl_glob[idim][iR + i + 1] = grid->xl_glob[idim][iR] + (i + 1.0)*grid->dx_glob[idim][iR];
>       grid->xr_glob[idim][iR + i + 1] = grid->xl_glob[idim][iR] + (i + 2.0)*grid->dx_glob[idim][iR];
87c86
<       G->x_glob[i] = 0.5*(G->xl_glob[i] + G->xr_glob[i]);
---
>       grid->x_glob[idim][i] = 0.5*(grid->xl_glob[idim][i] + grid->xr_glob[idim][i]);
90c89
< /*  ---- define leftmost and rightmost domain extrema  ---- */
---
> /*  ---- define leftmost and rightmost (global) domain extrema  ---- */
92,93c91,100
<     G->xi = G->xl_glob[iL];
<     G->xf = G->xr_glob[iR];
---
>     grid->xbeg_glob[idim] = grid->xl_glob[idim][iL];
>     grid->xend_glob[idim] = grid->xr_glob[idim][iR];
> 
>     g_domBeg[idim] = grid->xl_glob[idim][iL];
>     g_domEnd[idim] = grid->xr_glob[idim][iR];
> 
> /*  ---- Define leftmost and rightmost (local) domain coordinates  ---- */
>     
>     grid->xbeg[idim] = grid->xl[idim][ngh];
>     grid->xend[idim] = grid->xr[idim][grid->np_int[idim]+ngh-1];
95,96d101
<     g_domBeg[idim] = G->xl_glob[iL];
<     g_domEnd[idim] = G->xr_glob[iR];
113,116c118,120
<     G   = GXYZ + idim;
<     ngh = G->nghost;
<     iL  = G->gbeg;
<     iR  = G->gend;
---
>     ngh = grid->nghost[idim];
>     iL  = grid->gbeg[idim];
>     iR  = grid->gend[idim];
121c125,126
<         i-ngh+1, G->xl_glob[i], G->x_glob[i], G->xr_glob[i], G->dx_glob[i]);
---
>         i-ngh+1, grid->xl_glob[idim][i], grid->x_glob[idim][i],
>                  grid->xr_glob[idim][i], grid->dx_glob[idim][i]);
156c161
<               GXYZ[idim].np_int_glob, GXYZ[idim].nghost);
---
>               grid->np_int_glob[idim], grid->nghost[idim]);
160,163c165,167
<       G   = GXYZ + idim;
<       ngh = G->nghost;
<       iL  = G->gbeg;
<       iR  = G->gend;
---
>       ngh = grid->nghost[idim];
>       iL  = grid->gbeg[idim];
>       iR  = grid->gend[idim];
168c172
<           i-ngh+1, G->xl_glob[i], G->xr_glob[i]);
---
>           i-ngh+1, grid->xl_glob[idim][i], grid->xr_glob[idim][i]);
177c181
<   MakeGeometry(GXYZ);
---
>   MakeGeometry(grid);
182a187
>   print ("  Global grid:\n");
184,186c189,215
<    print1 ("  X%d: [% f, % f], %d point(s), %d ghosts\n", idim+1,
<             g_domBeg[idim], g_domEnd[idim], 
<             GXYZ[idim].np_int_glob, GXYZ[idim].nghost);
---
>     if (fabs(g_domEnd[idim] - g_domBeg[idim]) >= 1.e4) { /* Use scientific notation */
>       print ("  X%d: [ %12.6e, %12.6e], %6d point(s), %d ghosts\n", idim+1,
>                g_domBeg[idim], g_domEnd[idim], 
>                grid->np_int_glob[idim], grid->nghost[idim]);
>     }else{                                              /* Use float notation */
>       print ("  X%d: [ %8.4f, %8.4f], %6d point(s), %d ghosts\n", idim+1,
>                g_domBeg[idim], g_domEnd[idim], 
>                grid->np_int_glob[idim], grid->nghost[idim]);
>     }
>   }
> 
>   print ("\n");
>   print ("  Local grid:\n");
>   for (idim = 0; idim < DIMENSIONS; idim++){
>     if (fabs(g_domEnd[idim] - g_domBeg[idim]) >= 1.e4) { /* Use scientific notation */
>       print ("  X%d: [ %-13.6e, %-13.6e], %6d point(s); %d ghosts;", idim+1,
>                grid->xbeg[idim], grid->xend[idim], 
>                grid->np_int[idim], grid->nghost[idim]);
>       print (" Active zones = [%d, %d]\n",
>                grid->nghost[idim], grid->np_int[idim] + grid->nghost[idim]-1);
>     }else{
>       print ("  X%d: [ %8.4f, %8.4f], %6d point(s); %d ghosts;", idim+1,
>                grid->xbeg[idim],   grid->xend[idim], 
>                grid->np_int[idim], grid->nghost[idim]);
>       print (" Active zones = [%d, %d]\n",
>                grid->nghost[idim], grid->np_int[idim] + grid->nghost[idim]-1);
>     }
193c222
<  * Free array memory allocated previously.
---
>  * Free array memory allocated previously (used by AMR)
200,210c229,235
<     FreeArray1D(grid[dir].x);
<     FreeArray1D(grid[dir].xl);
<     FreeArray1D(grid[dir].xr);
<     FreeArray1D(grid[dir].dx);
<     FreeArray1D(grid[dir].xgc);
<     FreeArray1D(grid[dir].dV);
<     FreeArray1D(grid[dir].A-1);
<     FreeArray1D(grid[dir].r_1);
<     FreeArray1D(grid[dir].ct);
<     FreeArray1D(grid[dir].inv_dx);
<     FreeArray1D(grid[dir].inv_dxi);
---
>     FreeArray1D(grid->x[dir]);
>     FreeArray1D(grid->xl[dir]);
>     FreeArray1D(grid->xr[dir]);
>     FreeArray1D(grid->dx[dir]);
>     FreeArray1D(grid->xgc[dir]);
>     FreeArray1D(grid->inv_dx[dir]);
>     FreeArray1D(grid->inv_dxi[dir]);
211a237,245
>   FreeArray3D((void *) grid->dV);
>   FreeArrayBox(grid->A[IDIR],  0,  0, -1);
>   FreeArrayBox(grid->A[JDIR],  0, -1,  0);
>   FreeArrayBox(grid->A[KDIR], -1,  0,  0);
> 
>   FreeArray1D(grid->rt);
>   FreeArray1D(grid->sp);
>   FreeArray1D(grid->s);
>   FreeArray1D(grid->dmu);
215c249
< void InitializeGrid (Runtime *rtime, Grid *GXYZ)
---
> void InitializeGrid (Runtime *rtime, Grid *grid)
218c252
<  * for local grids.
---
>  * for local gridd.
225d258
<   struct GRID *G;
229d261
<     G = GXYZ + idim;
231c263
<       G->uniform = rtime->grid_is_uniform[idim];
---
>       grid->uniform[idim] = rtime->grid_is_uniform[idim];
233c265
<       G->uniform = 0;
---
>       grid->uniform[idim] = 0;
241,244c273,280
<       G->np_int = G->np_tot = G->np_int_glob = G->np_tot_glob = 1;
<       ngh = G->nghost = G->beg = G->end = G->gbeg = G->gend = 
<             G->lbeg   = G->lend = 0;
<       G->nproc = 1;
---
>       grid->np_int[idim]      = grid->np_tot[idim]      = 1;
>       grid->np_int_glob[idim] = grid->np_tot_glob[idim] = 1;
> 
>       ngh = grid->nghost[idim] = 0;
>       grid->beg[idim]  = grid->end[idim]  = 0;
>       grid->gbeg[idim] = grid->gend[idim] = 0;
>       grid->lbeg[idim] = grid->lend[idim] = 0;
>       grid->nproc[idim] = 1;
246c282
<       ngh = G->nghost;
---
>       ngh = grid->nghost[idim];
249,252c285,288
<     np_tot_glob = G->np_tot_glob;
<     np_int_glob = G->np_int_glob;
<     np_tot = G->np_tot;
<     np_int = G->np_int;
---
>     np_tot_glob = grid->np_tot_glob[idim];
>     np_int_glob = grid->np_int_glob[idim];
>     np_tot = grid->np_tot[idim];
>     np_int = grid->np_int[idim];
258,261c294,297
<     G->x_glob  = ARRAY_1D(np_tot_glob, double);
<     G->xr_glob = ARRAY_1D(np_tot_glob, double);
<     G->xl_glob = ARRAY_1D(np_tot_glob, double);
<     G->dx_glob = ARRAY_1D(np_tot_glob, double);
---
>     grid->x_glob[idim]  = ARRAY_1D(np_tot_glob, double);
>     grid->xr_glob[idim] = ARRAY_1D(np_tot_glob, double);
>     grid->xl_glob[idim] = ARRAY_1D(np_tot_glob, double);
>     grid->dx_glob[idim] = ARRAY_1D(np_tot_glob, double);
265,268c301,304
<     G->x  = G->x_glob  + G->beg - ngh;
<     G->xr = G->xr_glob + G->beg - ngh;
<     G->xl = G->xl_glob + G->beg - ngh;
<     G->dx = G->dx_glob + G->beg - ngh;
---
>     grid->x[idim]  = grid->x_glob[idim]  + grid->beg[idim] - ngh;
>     grid->xr[idim] = grid->xr_glob[idim] + grid->beg[idim] - ngh;
>     grid->xl[idim] = grid->xl_glob[idim] + grid->beg[idim] - ngh;
>     grid->dx[idim] = grid->dx_glob[idim] + grid->beg[idim] - ngh;
326d361
<   double ratio;
395,412c430
<     } else if ( rtime->patch_type[idim][iseg] == RATIO_GRID) {
< 		ratio=rtime->ratio[idim];
<     	printf ("We are here %e %e %i %i %e %i\n",xL,xR,iL,iR,rtime->ratio[idim],iR-iL+1);
< 		xlft[iL] = xL;
< 		dx[iL] = (xR-xL)*(ratio-1.0)/(pow(ratio,(iR-iL+1)) - 1.0); //Initial dx
< 		xrgt[iL] = xlft[iL] + dx[iL];
<         for (i = iL+1; i <= iR; i++) {
< 			dx[i] = dx[i-1] * ratio;
< 			xlft[i] =  xlft[i-1] + dx[i-1];	
< 			xrgt[i] = xlft[i] + dx[i];		
< 
< 		}
<         done_with_segment[iseg] = 1;
< 		
<     }
< 	
< 	
< 	else {
---
>     } else {
415d432
< 	
491c508
<             print1 ("Too many iterations during grid (%d) generation!\n",idim);
---
>             print ("Too many iterations during grid (%d) generation!\n",idim);
505,506c522,523
<           print1 (" ! WARNING:  alpha=%12.6e > 1.05 , dimension %d\n", alpha, idim);
<           print1 (" ! While stretching segment %d\n", iseg);
---
>           print (" ! WARNING:  alpha=%12.6e > 1.05 , dimension %d\n", alpha, idim);
>           print (" ! While stretching segment %d\n", iseg);
510c527
<         print1 ("     - Stretched grid on dim %d (ratio: %f)\n",idim, alpha);
---
>         print ("     - Stretched grid on dim %d (ratio: %f)\n",idim, alpha);
diff Src/set_image.c ../old/set_image.c
50c50
<       print1 ("! Error: var '%s' is not associated with a valid image\n"); 
---
>       print ("! Error: var '%s' is not associated with a valid image\n"); 
diff Src/set_indexes.c ../old/set_indexes.c
39c39
<   This allows to computed fully corner coupled states in the boundary to
---
>   This allows to computed fully corner coupled sweeps in the boundary to
43c43
<   \date   Sep 17, 2012
---
>   \date   Nov 27, 2017
49c49
< void SetIndexes (Index *indx, Grid *grid)
---
> void SetVectorIndices (int dir)
58,62c58
<   IBEG = grid[IDIR].lbeg; IEND = grid[IDIR].lend;
<   JBEG = grid[JDIR].lbeg; JEND = grid[JDIR].lend;
<   KBEG = grid[KDIR].lbeg; KEND = grid[KDIR].lend;
< 
<   if (g_dir == IDIR) {   /* -- Order: X-Y-Z  {in,t1,t2 = i,j,k} -- */
---
>   if (dir == IDIR) {   /* -- Order: X-Y-Z  {in,t1,t2 = i,j,k} -- */
67c63
< #if PHYSICS == MHD || PHYSICS == RMHD
---
>     #if PHYSICS == MHD || PHYSICS == RMHD
71,72c67,74
< #endif
< #if DUST == YES
---
>     #endif
>     #if (PHYSICS == RMHD) && (RESISTIVITY != NO)
>     EXPAND(EXn = EX1; , 
>            EXt = EX2; ,  
>            EXb = EX3;)
>     #endif
> 
> #if DUST_FLUID == YES
77,83c79,80
< 
<     indx->ntot   = grid[IDIR].np_tot;
<     indx->beg    = IBEG; indx->end    = IEND;
<     indx->t1_beg = JBEG; indx->t1_end = JEND;
<     indx->t2_beg = KBEG; indx->t2_end = KEND;
< 
<   }else if (g_dir == JDIR){ /* -- Order: Y-X-Z  {in,t1,t2 = j,i,k} -- */
---
>  
>   }else if (dir == JDIR){ /* -- Order: Y-X-Z  {in,t1,t2 = j,i,k} -- */
88c85
< #if PHYSICS == MHD || PHYSICS == RMHD
---
>     #if PHYSICS == MHD || PHYSICS == RMHD
92,93c89,95
< #endif
< #if DUST == YES
---
>     #endif
>     #if (PHYSICS == RMHD) && (RESISTIVITY != NO)
>     EXPAND(EXn = EX2; , 
>            EXt = EX1; ,  
>            EXb = EX3;)
>     #endif
> #if DUST_FLUID == YES
99,104c101
<     indx->ntot   = grid[JDIR].np_tot;
<     indx->beg    = JBEG; indx->end    = JEND;
<     indx->t1_beg = IBEG; indx->t1_end = IEND;
<     indx->t2_beg = KBEG; indx->t2_end = KEND;
< 
<   }else if (g_dir == KDIR){ /* -- Order: Z-X-Y  {in,t1,t2 = k,i,j} -- */
---
>   }else if (dir == KDIR){ /* -- Order: Z-X-Y  {in,t1,t2 = k,i,j} -- */
114c111,116
< #if DUST == YES
---
>     #if (PHYSICS == RMHD) && (RESISTIVITY != NO)
>     EXPAND(EXn = EX3; , 
>            EXt = EX1; ,  
>            EXb = EX2;)
>     #endif
> #if DUST_FLUID == YES
120,124d121
<     indx->ntot   = grid[KDIR].np_tot;
<     indx->beg    = KBEG; indx->end    = KEND;
<     indx->t1_beg = IBEG; indx->t1_end = IEND;
<     indx->t2_beg = JBEG; indx->t2_end = JEND;
< 
126,159d122
< 
< /* -------------------------------------------------------
<     Expand grid one further zone to account for proper 
<     flux computation. This is necessary to obtain the EMF 
<     in the boundary zones and to get transverse rhs for 
<     corner coupled states.
<    ------------------------------------------------------- */
< 
<   #ifdef STAGGERED_MHD
<    D_EXPAND(                              ;  ,
<             indx->t1_beg--; indx->t1_end++;  ,
<             indx->t2_beg--; indx->t2_end++;)
<    #ifdef CTU
<     if (g_intStage == 1){
<       indx->beg--;
<       indx->end++; 
<       D_EXPAND(                              ;  ,
<                indx->t1_beg--; indx->t1_end++;  ,
<                indx->t2_beg--; indx->t2_end++;)
<     }
<    #endif
<   #else
<    #ifdef CTU 
<     if (g_intStage == 1){
<       #if (PARABOLIC_FLUX & EXPLICIT)
<        indx->beg--;
<        indx->end++; 
<       #endif
<       D_EXPAND(                                 ,
<                indx->t1_beg--; indx->t1_end++;  ,
<                indx->t2_beg--; indx->t2_end++;) 
<     }
<    #endif
<   #endif
163c126
< void ResetState (const Data *d, State_1D *state, Grid *grid)
---
> void ResetState (const Data *d, Sweep *sweep, Grid *grid)
165c128
<  * Initialize some of the elements of the State_1D structure to zero
---
>  * Initialize some of the elements of the Sweep structure to zero
173c136
<  * \param [out] state pointer to a State_1D structure
---
>  * \param [out] sweep pointer to a Sweep structure
181a145,153
>   memset ((void *)sweep->src[0],   '\0', NMAX_POINT*NVAR*sizeof(double));
> 
>   memset ((void *)sweep->stateC.Rp[0][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
>   memset ((void *)sweep->stateC.Lp[0][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
>   memset ((void *)sweep->stateL.Rp[0][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
>   memset ((void *)sweep->stateL.Lp[0][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
>   memset ((void *)sweep->stateR.Rp[-1][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
>   memset ((void *)sweep->stateR.Lp[-1][0], '\0', NMAX_POINT*NFLX*NFLX*sizeof(double));
> /*
183c155
<     for (j = NVAR; j--;  ) state->src[i][j] = 0.0;
---
>     for (j = NVAR; j--;  ) sweep->src[i][j] = 0.0;
187c159
<       state->Lp[i][j][k] = state->Rp[i][j][k] = 0.0;
---
>       sweep->Lp[i][j][k] = sweep->Rp[i][j][k] = 0.0;
190c162
< 
---
> */
198c170
<    FD_GetMaxEigenvalues (d, state, grid);
---
>    FD_GetMaxEigenvalues (d, sweep, grid);
diff Src/set_output.c ../old/set_output.c
13c13
<   The function SetDumpVar() can be used to include or exclude a given 
---
>   The function SetOutputVar() can be used to include or exclude a given 
26c26
<   \date    Aug 24, 2015
---
>   \date    March 29, 2018
61c61,62
<   for (k = 0; k < MAX_OUTPUT_TYPES; k++){ 
---
>   for (k = 0; k < MAX_OUTPUT_TYPES; k++){
>     
63,65c64,66
<     output->var_name = ARRAY_2D(64,128,char);
<     output->stag_var = ARRAY_1D(64, int);
<     output->dump_var = ARRAY_1D(64, int);
---
>     output->var_name = ARRAY_2D(MAX_OUTPUT_VARS, 128,char);
> //    output->stag_var = ARRAY_1D(64, int);
> //    output->dump_var = ARRAY_1D(64, int);
67c68
<                                             /* for all outputs (easy to change) */
---
>                                               /* for all outputs (easy to change) */
69a71,82
>   /* -- Set particles filename extensions -- */
> 
> /* -- Exclude particle outputs -- */
> 
>     #ifdef PARTICLES
>     if (output->type == PARTICLES_DBL_OUTPUT ||
>         output->type == PARTICLES_FLT_OUTPUT ||
>         output->type == PARTICLES_VTK_OUTPUT ||
>         output->type == PARTICLES_TAB_OUTPUT ||
>         output->type == PARTICLES_HDF5_OUTPUT) continue;
>     #endif
> 
83c96
<        output->var_name[nv]   = "bx1s"; 
---
>        output->var_name[nv]   = "Bx1s"; 
87c100
<        output->var_name[nv]   = "bx2s"; 
---
>        output->var_name[nv]   = "Bx2s"; 
91c104
<        output->var_name[nv]   = "bx3s"; 
---
>        output->var_name[nv]   = "Bx3s"; 
178c191
<      if (output->type == DBL_OUTPUT || output->type == DBL_H5_OUTPUT)  
---
>      if (output->type == DBL_OUTPUT || output->type == DBL_H5_OUTPUT) {
180c193,196
<      else
---
>        #ifdef PHI_GLM
>        output->dump_var[PHI_GLM] = YES;
>        #endif       
>      } else {
181a198,201
>        #ifdef PHI_GLM
>        output->dump_var[PHI_GLM] = NO;
>        #endif       
>      }
185c205
< /* -- exclude stag components from all output except .dbl -- */
---
> /* -- Exclude staggered components from all output except .dbl and .h5.dbl -- */
188,199c208,219
<    D_EXPAND( SetDumpVar ("bx1s", VTK_OUTPUT, NO);  ,
<              SetDumpVar ("bx2s", VTK_OUTPUT, NO);  ,
<              SetDumpVar ("bx3s", VTK_OUTPUT, NO);)
<    D_EXPAND( SetDumpVar ("bx1s", FLT_OUTPUT, NO);  ,
<              SetDumpVar ("bx2s", FLT_OUTPUT, NO);  ,
<              SetDumpVar ("bx3s", FLT_OUTPUT, NO);)
<    D_EXPAND( SetDumpVar ("bx1s", FLT_H5_OUTPUT, NO);  ,
<              SetDumpVar ("bx2s", FLT_H5_OUTPUT, NO);  ,
<              SetDumpVar ("bx3s", FLT_H5_OUTPUT, NO);)
<    D_EXPAND( SetDumpVar ("bx1s", TAB_OUTPUT, NO);  ,
<              SetDumpVar ("bx2s", TAB_OUTPUT, NO);  ,
<              SetDumpVar ("bx3s", TAB_OUTPUT, NO);)
---
>   D_EXPAND( SetOutputVar ("Bx1s", VTK_OUTPUT, NO);  ,
>             SetOutputVar ("Bx2s", VTK_OUTPUT, NO);  ,
>             SetOutputVar ("Bx3s", VTK_OUTPUT, NO);)
>   D_EXPAND( SetOutputVar ("Bx1s", FLT_OUTPUT, NO);  ,
>             SetOutputVar ("Bx2s", FLT_OUTPUT, NO);  ,
>             SetOutputVar ("Bx3s", FLT_OUTPUT, NO);)
>   D_EXPAND( SetOutputVar ("Bx1s", FLT_H5_OUTPUT, NO);  ,
>             SetOutputVar ("Bx2s", FLT_H5_OUTPUT, NO);  ,
>             SetOutputVar ("Bx3s", FLT_H5_OUTPUT, NO);)
>   D_EXPAND( SetOutputVar ("Bx1s", TAB_OUTPUT, NO);  ,
>             SetOutputVar ("Bx2s", TAB_OUTPUT, NO);  ,
>             SetOutputVar ("Bx3s", TAB_OUTPUT, NO);)
204,205c224,225
<   SetDumpVar ("rho", PPM_OUTPUT, YES);
<   SetDumpVar ("rho", PNG_OUTPUT, YES);
---
>   SetOutputVar ("rho", PPM_OUTPUT, YES);
>   SetOutputVar ("rho", PNG_OUTPUT, YES);
207d226
<   ChangeDumpVar();
211c230
< int SetDumpVar (char *var_name, int out_type, int flag)
---
> int SetOutputVar (char *var_name, int output_type, int flag)
213,222c232,240
<  *  Include ('flag == YES') or exclude ('flag == NO') the 
<  *  variable associated to 'var_name' in or from the output 
<  *  type 'out_type'. 
<  *  If 'out_type' corresponds to an image (ppm or png), create
<  *  a correspdonding Image structure.
<  *
<  * \param [in] var_name  the name of the variable (e.g. "rho", "vx1",...)
<  * \param [in] out_type  select the output type (e.g., DBL_OUTPUT, 
<  *             VTK_OUTPUT, and so forth)
<  * \param [in] flag     an integer values (YES/NO).      
---
>  *  Include ('flag == YES') or exclude ('flag == NO') the variable
>  *  corresponding to 'var_name' in or from the output type 'out_type'. 
>  *  If 'out_type' corresponds to an image (ppm or png), create a
>  *  correspdonding Image structure.
>  *
>  * \param [in] var_name     the name of the variable (e.g. "rho", "vx1",...)
>  * \param [in] output_type  select the output type (e.g., DBL_OUTPUT, 
>  *                          VTK_OUTPUT, and so forth)
>  * \param [in] flag         an integer values (YES/NO).      
230c248
<     if (output->type == out_type) break;
---
>     if (output->type == output_type) break;
234c252
<     if (strcmp(output->var_name[nv], var_name) == 0) { 
---
>     if (strcmp(output->var_name[nv], var_name) == 0) {
237c255
<         if (out_type == PPM_OUTPUT || out_type == PNG_OUTPUT){
---
>         if (output_type == PPM_OUTPUT || output_type == PNG_OUTPUT){
245c263
<   print1 ("! var_name '%s' cannot be set/unset for writing\n",var_name);
---
>   print ("! var_name '%s' cannot be set/unset for writing\n",var_name);
247d264
<   
250a268,296
> int GetOutputVarNames(int output_type, char *var_name[NVAR])
> /*!
>  *  Return the number and the names of the variables being written to
>  *  disk with a particular output type.
>  *
>  * \param [in]  output_type    The output type (e.g. FLT_OUTPUT)
>  * \param [out] var_names      An array of strings containing the actual
>  *                              variable names.
>  *
>  * \return An integer giving the number of variables.
>  *
>  *********************************************************************** */
> {
>   int k, nv, count = 0;
>   Output *output;
> 
>   for (k = 0; k < MAX_OUTPUT_TYPES; k++){ 
>     output = all_outputs + k;
>     if (output->type == output_type) break;
>   }
> 
>   for (nv = 0; nv < output->nvar; nv++) {
>     if (output->dump_var[nv]) sprintf (var_name[count++], "%s", output->var_name[nv]);
>   }
>   return count;
> }
> 
> 
> /* ********************************************************************* */
262c308
<       print1 ("! Error: uservar '%s' is not allocated\n"); 
---
>       print ("! Error: uservar '%s' is not allocated\n"); 
diff Src/show_config.c ../old/show_config.c
6,9c6,7
<   
< 
<   \author A. Mignone (mignone@ph.unito.it)
<   \date   May 15, 2014
---
>   \author  A. Mignone (mignone@ph.unito.it)
>   \date    Oct 04, 2017
35a34,35
>   double *dbl_pnt;  /* For printing size of pointer to double */
>   int    *int_pnt;  /* For printing size of pointer to int */
39,44c39,44
<   print1 ("\n");
<   print1("   ___  __   __  ____________   \n");
<   print1("  / _ \\/ /  / / / /_  __/ __ \\ \n");
<   print1(" / ___/ /__/ /_/ / / / / /_/ /  \n");
<   print1("/_/  /____/\\____/ /_/  \\____/   \n");
<   print1("=============================    v. %s  \n", PLUTO_VERSION);
---
>   print ("\n");
>   print("   ___  __   __  ____________   \n");
>   print("  / _ \\/ /  / / / /_  __/ __ \\ \n");
>   print(" / ___/ /__/ /_/ / / / / /_/ /  \n");
>   print("/_/  /____/\\____/ /_/  \\____/   \n");
>   print("=============================    v. %s  \n", PLUTO_VERSION);
46c46
<   print1 ("\n> System:\n\n");
---
>   print ("\n> System:\n\n");
52c52
<         print1 ("  %s:             %s\n",str1, str3);
---
>         print ("  %s:             %s\n",str1, str3);
54c54
<         print1 ("  %s:      %s\n",str1, str3);
---
>         print ("  %s:      %s\n",str1, str3);
56c56
<         print1 ("  %s:      %s\n",str1, str3);
---
>         print ("  %s:      %s\n",str1, str3);
58c58
<         print1 ("  %s:        %s\n",str1, str3);
---
>         print ("  %s:        %s\n",str1, str3);
60c60
<         print1 ("  %s:             %s\n",str1, str3);
---
>         print ("  %s:             %s\n",str1, str3);
62c62
<         print1 ("  %s:       %s\n\n",str1, str3);
---
>         print ("  %s:       %s\n\n",str1, str3);
67c67
<     print1 ("! sysconf.out file not found \n\n");
---
>     print ("  sysconf.out file not found... \n\n");
69a70,101
> 
>   print ("  - Basic data type:\n");
>   print ("    o sizeof (char)     = %d\n", sizeof(char));
>   print ("    o sizeof (uchar)    = %d\n", sizeof(unsigned char));
>   print ("    o sizeof (short)    = %d\n", sizeof(short));
>   print ("    o sizeof (ushort)   = %d\n", sizeof(unsigned short));
>   print ("    o sizeof (int)      = %d\n", sizeof(int));
>   print ("    o sizeof (long)     = %d\n", sizeof(long));
>   print ("    o sizeof (*int)     = %d\n", sizeof(int_pnt));
>   print ("    o sizeof (float)    = %d\n", sizeof(float));
>   print ("    o sizeof (double)   = %d\n", sizeof(double));
>   print ("    o sizeof (*double)  = %d\n", sizeof(dbl_pnt));
>   
> 
>   print ("\n  - Structure data type:\n");
>   print ("    o sizeof (CMD_LINE)   = %d\n", sizeof(Cmd_Line));
>   print ("    o sizeof (Data)       = %d\n", sizeof(Data));
>   print ("    o sizeof (Grid)       = %d\n", sizeof(Grid));
>   print ("    o sizeof (FLOAT_VECT) = %d\n", sizeof(Float_Vect));
>   print ("    o sizeof (IMAGE)      = %d\n", sizeof(Image));
>   print ("    o sizeof (OUTPUT)     = %d\n", sizeof(Output));
>   print ("    o sizeof (RGB)        = %d\n", sizeof(RGB));
>   print ("    o sizeof (RUNTIME)    = %d\n", sizeof(Runtime));
>   print ("    o sizeof (RESTART)    = %d\n", sizeof(Restart));
>   print ("    o sizeof (TIME_STEP)  = %d\n", sizeof(timeStep));
>   print ("    o sizeof (RBOX)       = %d\n", sizeof(RBox));
>   print ("    o sizeof (State)      = %d\n", sizeof(State));
>   print ("    o sizeof (Sweep)      = %d\n", sizeof(Sweep));
> #ifdef PARTICLES
>   print ("    o sizeof (PARTICLE)   = %d\n", sizeof(Particle));
> #endif
> 
71c103
<   print1("> Local time:       %s\n",asctime(localtime(&time_now)));
---
>   print("\n> Local time:       %s\n",asctime(localtime(&time_now)));
74,76c106,108
<     print1 ("Sorry, but the number of vector components can\n");
<     print1 ("not be less than the dimension number.\n");
<     print1 ("Please edit definitions.h and fix this.\n");
---
>     print ("Sorry, but the number of vector components can\n");
>     print ("not be less than the dimension number.\n");
>     print ("Please edit definitions.h and fix this.\n");
82,84c114,116
<   print1 ("> Cmd line args:    ");
<   for (n = 1; n < argc; n++) print1 ("%s ",argv[n]);
<   print1 ("\n\n");
---
>   print ("> Cmd line args:    ");
>   for (n = 1; n < argc; n++) print ("%s ",argv[n]);
>   print ("\n\n");
88c120
<   print1 ("> Header configuration:\n\n");
---
>   print ("> Header configuration:\n\n");
90,94c122,126
<   if (PHYSICS == ADVECTION) print1 ("  PHYSICS:          ADVECTION\n");
<   if (PHYSICS == HD)        print1 ("  PHYSICS:          HD\n");
<   if (PHYSICS == RHD)       print1 ("  PHYSICS:          RHD\n");
<   if (PHYSICS == MHD)       print1 ("  PHYSICS:          MHD [div.B: ");
<   if (PHYSICS == RMHD)      print1 ("  PHYSICS:          RMHD [div.B: ");
---
>   if (PHYSICS == ADVECTION) print ("  PHYSICS:          ADVECTION\n");
>   if (PHYSICS == HD)        print ("  PHYSICS:          HD\n");
>   if (PHYSICS == RHD)       print ("  PHYSICS:          RHD\n");
>   if (PHYSICS == MHD)       print ("  PHYSICS:          MHD [div.B: ");
>   if (PHYSICS == RMHD)      print ("  PHYSICS:          RMHD [div.B: ");
97c129
<   print1 ("None]\n");
---
>   print ("None]\n");
99c131
<     print1 ("Powell's 8wave]\n");
---
>     print ("Powell's 8wave]\n");
102c134
<     print1 ("Divergence Cleaning (GLM)]\n");
---
>     print ("Divergence Cleaning (GLM)]\n");
104c136
<     print1 ("Divergence Cleaning (Extended GLM)]\n");
---
>     print ("Divergence Cleaning (Extended GLM)]\n");
108c140
<     print1 ("CT/");
---
>     print ("CT/");
110c142
<     print1 ("Ar. average]\n");
---
>     print ("Ar. average]\n");
112c144
<     print1 ("UCT_CONTACT]\n");
---
>     print ("UCT_CONTACT]\n");
114c146
<     print1 ("UCT0]\n");
---
>     print ("UCT0]\n");
116c148
<     print1 ("UCT_HLL]\n");
---
>     print ("UCT_HLL]\n");
121,122c153,154
<   print1 ("  DIMENSIONS:       %d\n", DIMENSIONS);
<   print1 ("  COMPONENTS:       %d\n", COMPONENTS);
---
>   print ("  DIMENSIONS:       %d\n", DIMENSIONS);
>   print ("  COMPONENTS:       %d\n", COMPONENTS);
124,131c156,177
<   print1 ("  GEOMETRY:         ");
<   if (GEOMETRY == CARTESIAN)    print1 ("Cartesian\n");
<   if (GEOMETRY == CYLINDRICAL)  print1 ("Cylindrical\n");
<   if (GEOMETRY == POLAR)        print1 ("Polar\n");
<   if (GEOMETRY == SPHERICAL)    print1 ("Spherical\n");
< 
<   print1 ("  BODY_FORCE:       ");
<   print1 (BODY_FORCE == NO ? "NO\n":"EXPLICIT\n");
---
>   print ("  GEOMETRY:         ");
>   if (GEOMETRY == CARTESIAN)    print ("Cartesian\n");
>   if (GEOMETRY == CYLINDRICAL)  print ("Cylindrical\n");
>   if (GEOMETRY == POLAR)        print ("Polar\n");
>   if (GEOMETRY == SPHERICAL)    print ("Spherical\n");
> 
>   print ("  BODY_FORCE:       ");
>   print (BODY_FORCE == NO ? "NO\n":"EXPLICIT\n");
> 
> #if COOLING == H2_COOL
>   print ("  COOLING:          H2_COOL\n");
> #elif COOLING == KROME
>   print ("  COOLING:          KROME\n");
> #elif COOLING == MINEq
>   print ("  COOLING:          MINEq\n");
> #elif COOLING == POWER_LAW
>   print ("  COOLING:          POWER_LAW\n");
> #elif COOLING == SNEq
>   print ("  COOLING:          SNEq\n");
> #elif COOLING == TABULATED
>   print ("  COOLING:          TABULATED\n");
> #endif
133c179
<   print1 ("  RECONSTRUCTION:   ");
---
>   print ("  RECONSTRUCTION:   ");
135,140c181,186
<    if (RECONSTRUCTION == FLAT)          print1 ("Flat");
<    if (RECONSTRUCTION == LINEAR)        print1 ("Linear TVD");
<    if (RECONSTRUCTION == LINEAR_MULTID) print1 ("Linear_Multid");
<    if (RECONSTRUCTION == LimO3)         print1 ("LimO3");
<    if (RECONSTRUCTION == WENO3)         print1 ("WENO 3rd order");
<    if (RECONSTRUCTION == PARABOLIC)     print1 ("Parabolic");
---
>    if (RECONSTRUCTION == FLAT)          print ("Flat");
>    if (RECONSTRUCTION == LINEAR)        print ("Linear TVD");
>    if (RECONSTRUCTION == LINEAR_MULTID) print ("Linear_Multid");
>    if (RECONSTRUCTION == LimO3)         print ("LimO3");
>    if (RECONSTRUCTION == WENO3)         print ("WENO 3rd order");
>    if (RECONSTRUCTION == PARABOLIC)     print ("Parabolic");
142,143c188,189
<    if (CHAR_LIMITING == YES) print1 (" (Characteristic lim)\n");
<    else                      print1 (" (Primitive lim)\n");
---
>    if (CHAR_LIMITING == YES) print (" (Characteristic lim)\n");
>    else                      print (" (Primitive lim)\n");
148,151c194,197
<   if (RECONSTRUCTION == LIMO3_FD)     print1 ("LimO3 (FD), 3rd order\n");
<   if (RECONSTRUCTION == WENO3_FD)     print1 ("WENO3 (FD), 3rd order\n");
<   if (RECONSTRUCTION == WENOZ_FD)     print1 ("WENOZ (FD) 5th order\n");
<   if (RECONSTRUCTION == MP5_FD)       print1 ("MP5 (FD), 5th order\n");
---
>   if (RECONSTRUCTION == LIMO3_FD)     print ("LimO3 (FD), 3rd order\n");
>   if (RECONSTRUCTION == WENO3_FD)     print ("WENO3 (FD), 3rd order\n");
>   if (RECONSTRUCTION == WENOZ_FD)     print ("WENOZ (FD) 5th order\n");
>   if (RECONSTRUCTION == MP5_FD)       print ("MP5 (FD), 5th order\n");
154,156c200,202
<   print1 ("  TRACERS:          %d\n", NTRACER);
<   print1 ("  VARIABLES:        %d\n", NVAR);
<   print1 ("  ENTROPY_SWITCH:   %s\n",(ENTROPY_SWITCH != NO ? "ENABLED":"NO"));
---
>   print ("  TRACERS:          %d\n", NTRACER);
>   print ("  VARIABLES:        %d\n", NVAR);
>   print ("  ENTROPY_SWITCH:   %s\n",(ENTROPY_SWITCH != NO ? "ENABLED":"NO"));
158c204
<   print1 ("  BACKGROUND_FIELD: %s\n",(BACKGROUND_FIELD == YES ? "YES":"NO"));
---
>   print ("  BACKGROUND_FIELD: %s\n",(BACKGROUND_FIELD == YES ? "YES":"NO"));
161c207
<   print1 ("  LOADED MODULES:\n");
---
>   print ("  LOADED MODULES:\n");
164,166c210,212
<     print1 ("\n  o [SHEARINGBOX]\n");
<     print1 ("     - Order:             %d\n", SB_ORDER);
<     print1 ("     - Sym Hydro Flux:    %s\n", 
---
>     print ("\n  o [SHEARINGBOX]\n");
>     print ("     - Order:             %d\n", SB_ORDER);
>     print ("     - Sym Hydro Flux:    %s\n", 
168c214
<     print1 ("     - Sym Ey:            %s\n", 
---
>     print ("     - Sym Ey:            %s\n", 
170c216
<     print1 ("     - Sym Ez:            %s\n", 
---
>     print ("     - Sym Ez:            %s\n", 
172c218
<     print1 ("     - Force EMF periods: %s\n", 
---
>     print ("     - Force EMF periods: %s\n", 
177,179c223,225
<    print1 ("\n  o [FARGO]\n");
<    print1 ("     - Order:         %d\n", FARGO_ORDER);
<    print1 ("     - Average Speed: %s\n", 
---
>    print ("\n  o [FARGO]\n");
>    print ("     - Order:         %d\n", FARGO_ORDER);
>    print ("     - Average Speed: %s\n", 
181c227
<    print1 ("     - Av. Frequency: %d\n", FARGO_NSTEP_AVERAGE);
---
>    print ("     - Av. Frequency: %d\n", FARGO_NSTEP_AVERAGE);
184c230
<   print1 ("\n");
---
>   print ("\n");
186,187c232,233
<   print1 ("  ROTATION:         ");
<   print1(ROTATING_FRAME == YES ? "YES\n":"NO\n");
---
>   print ("  ROTATION:         ");
>   print(ROTATING_FRAME == YES ? "YES\n":"NO\n");
189,200c235,246
<   print1 ("  EOS:              ");
<   if      (EOS == IDEAL)        print1 ("Ideal\n");
<   else if (EOS == PVTE_LAW)     print1 ("PVTE_LAW\n");
<   else if (EOS == BAROTROPIC)   print1 ("Barotropic\n");
<   else if (EOS == ISOTHERMAL)   print1 ("Isothermal\n");
<   else if (EOS == TAUB)         print1 ("Taub - TM\n");
<   else                          print1 ("None\n");
< 
<   print1 ("  TIME INTEGRATOR:  ");
<   if (TIME_STEPPING == EULER)            print1 ("Euler\n");
<   if (TIME_STEPPING == RK2)              print1 ("Runga-Kutta II\n");
<   if (TIME_STEPPING == RK3)              print1 ("Runga_Kutta III\n");
---
>   print ("  EOS:              ");
>   if      (EOS == IDEAL)        print ("Ideal\n");
>   else if (EOS == PVTE_LAW)     print ("PVTE_LAW\n");
>   else if (EOS == BAROTROPIC)   print ("Barotropic\n");
>   else if (EOS == ISOTHERMAL)   print ("Isothermal\n");
>   else if (EOS == TAUB)         print ("Taub - TM\n");
>   else                          print ("None\n");
> 
>   print ("  TIME STEPPING:    ");
>   if (TIME_STEPPING == EULER)            print ("Euler\n");
>   if (TIME_STEPPING == RK2)              print ("Runga-Kutta II\n");
>   if (TIME_STEPPING == RK3)              print ("Runga_Kutta III\n");
202,203c248,252
<                                          print1 ("Characteristic Tracing\n");
<   if (TIME_STEPPING == HANCOCK)          print1 ("Hancock\n");
---
>                                          print ("Characteristic Tracing\n");
> #if TIME_STEPPING == HANCOCK
>   if (PRIMITIVE_HANCOCK == YES) print ("Hancock [Primitive]\n");
>   else                          print ("Hancock [Conservative]\n");
> #endif
205,207c254,256
<   print1 ("  DIM. SPLITTING:   ");
<   if (DIMENSIONAL_SPLITTING == YES)  print1 ("Yes\n");
<   else                               print1 ("No\n");
---
>   print ("  DIM. SPLITTING:   ");
>   if (DIMENSIONAL_SPLITTING == YES)  print ("Yes\n");
>   else                               print ("No\n");
211c260
<    print1 ("  DIFFUSION TERMS:");
---
>    print ("  DIFFUSION TERMS:");
213c262
<     print1 ("  Resistivity  [EXPLICIT]\n");  
---
>     print ("  Resistivity  [EXPLICIT]\n");  
215c264,266
<     print1 ("  Resistivity  [STS]\n");  
---
>     print ("  Resistivity  [STS]\n");  
>    #elif (RESISTIVITY == RK_LEGENDRE)
>     print ("  Resistivity  [RKL]\n");
219c270
<     print1 ("  Thermal Conduction [EXPLICIT]\n");  
---
>     print ("  Thermal Conduction [EXPLICIT]\n");  
221c272,274
<     print1 ("  Thermal Conduction [STS]\n");  
---
>     print ("  Thermal Conduction [STS]\n");  
>    #elif (THERMAL_CONDUCTION == RK_LEGENDRE)
>     print ("  Thermal Conduction [RKL]\n");
225c278
<     print1 ("  Viscosity [EXPLICIT]\n");  
---
>     print ("  Viscosity [EXPLICIT]\n");  
227c280,282
<     print1 ("  Viscosity [STS]\n");  
---
>     print ("  Viscosity [STS]\n");  
>    #elif (VISCOSITY == RK_LEGENDRE)
>     print ("  Viscosity [RKL]\n");
231c286
<   print1 ("\n");
---
>   print ("\n");
238,239c293,294
<   print1 ("> Header file configuration (definitions.h):\n\n");
<   print1 ("  +----------------------------------------------------------\n");
---
>   print ("> Header file configuration (definitions.h):\n\n");
>   print ("  +----------------------------------------------------------\n");
242c297
<     print1 ("  | %s",sline);
---
>     print ("  | %s",sline);
245c300
<   print1 ("  +---------------------------------------------------------\n\n");
---
>   print ("  +---------------------------------------------------------\n\n");
247,248c302,303
<   print1 ("> Runtime configuration (%s):\n\n", ini_file);
<   print1 ("  +----------------------------------------------------------\n");
---
>   print ("> Runtime configuration (%s):\n\n", ini_file);
>   print ("  +----------------------------------------------------------\n");
251c306
<     print1 ("  | %s",sline);
---
>     print ("  | %s",sline);
254,255c309
<   print1 ("  +---------------------------------------------------------\n");
< 
---
>   print ("  +---------------------------------------------------------\n");
269,273c323,328
<   print1 ("> Cooling Module:    ");
<   if (COOLING == SNEq)  print1 (" SNEq\n");
<   if (COOLING == MINEq) print1 (" MINEq\n");
<   if (COOLING == TABULATED) print1 (" TABULATED\n");
<   if (COOLING == H2_COOL) print1 (" H2_COOL \n");
---
>   print ("> Cooling Module:    ");
>   if (COOLING == SNEq)  print (" SNEq\n");
>   if (COOLING == MINEq) print (" MINEq\n");
>   if (COOLING == TABULATED) print (" TABULATED\n");
>   if (COOLING == H2_COOL) print (" H2_COOL \n");
>   if (COOLING == KROME) print (" KROME \n");
276,277c331,332
<   print1 ("> Normalization Units:\n\n");
<   print1 ("  [Density]:      %8.3e (gr/cm^3), %8.3e (1/cm^3)\n",
---
>   print ("> Normalization Units:\n\n");
>   print ("  [Density]:      %8.3e (gr/cm^3), %8.3e (1/cm^3)\n",
279c334
<   print1 ("  [Pressure]:     %8.3e (dyne/cm^2)\n",
---
>   print ("  [Pressure]:     %8.3e (dyne/cm^2)\n",
281,284c336,339
<   print1 ("  [Velocity]:     %8.3e (cm/s)\n",UNIT_VELOCITY);
<   print1 ("  [Length]:       %8.3e (cm)\n",UNIT_LENGTH);
<   print1 ("  [Temperature]:  %8.3e X (p/rho*mu) (K)\n",KELVIN);
<   print1 ("  [Time]:         %8.3e (sec), %8.3e (yrs) \n",
---
>   print ("  [Velocity]:     %8.3e (cm/s)\n",UNIT_VELOCITY);
>   print ("  [Length]:       %8.3e (cm)\n",UNIT_LENGTH);
>   print ("  [Temperature]:  %8.3e X (p/rho*mu) (K)\n",KELVIN);
>   print ("  [Time]:         %8.3e (sec), %8.3e (yrs) \n",
287c342
<   print1 ("  [Mag Field]:    %8.3e (Gauss)\n",
---
>   print ("  [Mag Field]:    %8.3e (Gauss)\n",
291,412c346
<   print1 (" \n");
< }
< 
< /* ********************************************************************* */
< void ShowDomainDecomposition(int nprocs, Grid *GXYZ)
< /*!
<  * Show the parallel domain decomposition by having each processor print
<  * its own computational domain.
<  * This is activated with the -show-dec command line argument.
<  * It may be long for several thousand processors. 
<  *
<  * \param [in] nprocs   the total number of processors
<  * \param [in] GXYZ     a pointer to an array of grid structures
<  *********************************************************************** */
< {
<   int p;
<   int ib, ie, jb, je, kb, ke;
<   int nxp, nyp, nzp;
<   int nghx, nghy, nghz;
< 
<   static int *ib_proc, *ie_proc;
<   static int *jb_proc, *je_proc;
<   static int *kb_proc, *ke_proc;
< 
<   double xb, xe, yb, ye, zb, ze;
< 
<   double *xb_proc, *xe_proc;
<   double *yb_proc, *ye_proc;
<   double *zb_proc, *ze_proc;
< 
<   Grid *Gx, *Gy, *Gz;
<   
<   Gx = GXYZ;
<   Gy = GXYZ + 1;
<   Gz = GXYZ + 2;
< 
< /* ---- Allocate memory ---- */
< 
<   ib_proc = ARRAY_1D(nprocs, int); ie_proc = ARRAY_1D(nprocs, int);
<   jb_proc = ARRAY_1D(nprocs, int); je_proc = ARRAY_1D(nprocs, int);
<   kb_proc = ARRAY_1D(nprocs, int); ke_proc = ARRAY_1D(nprocs, int);
<   xb_proc = ARRAY_1D(nprocs, double); xe_proc = ARRAY_1D(nprocs, double);
<   yb_proc = ARRAY_1D(nprocs, double); ye_proc = ARRAY_1D(nprocs, double);
<   zb_proc = ARRAY_1D(nprocs, double); ze_proc = ARRAY_1D(nprocs, double);
< 
< #ifdef PARALLEL  
<   nxp = Gx->np_tot;
<   nyp = Gy->np_tot;
<   nzp = Gz->np_tot;
< 
< /* -- Local beg and end indices -- */
< 
<   ib = nghx = Gx->nghost; ie = ib + Gx->np_int - 1;  
<   jb = nghy = Gy->nghost; je = jb + Gy->np_int - 1;
<   kb = nghz = Gz->nghost; ke = kb + Gz->np_int - 1;
< 
< /* -- Leftmost and rightmost processor coordinates -- */
< 
<   xb = Gx->xl[ib]; xe = Gx->xr[ie];
<   yb = Gy->xl[jb]; ye = Gy->xr[je];
<   zb = Gz->xl[kb]; ze = Gz->xr[ke];
< 
<   D_EXPAND(
<     MPI_Gather (&xb, 1, MPI_DOUBLE, xb_proc, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
<     MPI_Gather (&xe, 1, MPI_DOUBLE, xe_proc, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);  ,
<     
<     MPI_Gather (&yb, 1, MPI_DOUBLE, yb_proc, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
<     MPI_Gather (&ye, 1, MPI_DOUBLE, ye_proc, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);  ,
<     
<     MPI_Gather (&zb, 1, MPI_DOUBLE, zb_proc, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
<     MPI_Gather (&ze, 1, MPI_DOUBLE, ze_proc, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
<   )
< 
< /* -- Global beg and end indices -- */
< 
<   ib  = Gx->beg; ie += Gx->beg - nghx;
<   jb  = Gy->beg; je += Gy->beg - nghy;
<   kb  = Gz->beg; ke += Gz->beg - nghz;
< 
<   D_EXPAND(
<     MPI_Gather (&ib, 1, MPI_INT, ib_proc, 1, MPI_INT, 0, MPI_COMM_WORLD);
<     MPI_Gather (&ie, 1, MPI_INT, ie_proc, 1, MPI_INT, 0, MPI_COMM_WORLD);  ,
<     
<     MPI_Gather (&jb, 1, MPI_INT, jb_proc, 1, MPI_INT, 0, MPI_COMM_WORLD);
<     MPI_Gather (&je, 1, MPI_INT, je_proc, 1, MPI_INT, 0, MPI_COMM_WORLD);  ,
<     
<     MPI_Gather (&kb, 1, MPI_INT, kb_proc, 1, MPI_INT, 0, MPI_COMM_WORLD);
<     MPI_Gather (&ke, 1, MPI_INT, ke_proc, 1, MPI_INT, 0, MPI_COMM_WORLD);
<   )
< 
<   print1 ("> Domain Decomposition (%d procs):\n\n", nprocs);
< 
<   for (p = 0; p < nprocs; p++){ 
<     D_EXPAND(
<       print1 ("  - Proc # %d, X1: [%f, %f], i: [%d, %d], NX1: %d\n",
<               p, xb_proc[p], xe_proc[p], 
<                  ib_proc[p], ie_proc[p], 
<                  ie_proc[p]-ib_proc[p]+1);    ,
<       print1 ("              X2: [%f, %f], j: [%d, %d]; NX2: %d\n",
<                  yb_proc[p], ye_proc[p], 
<                  jb_proc[p], je_proc[p],
<                  je_proc[p]-jb_proc[p]+1);    ,
<       print1 ("              X3: [%f, %f], k: [%d, %d], NX3: %d\n\n",  
<                  zb_proc[p], ze_proc[p], 
<                  kb_proc[p], ke_proc[p],
<                  ke_proc[p]-kb_proc[p]+1);
<     )
<   }
< 
<   MPI_Barrier (MPI_COMM_WORLD);
< #endif
< 
< /* ---- Free memory ---- */
< 
<   FreeArray1D((void *) ib_proc); FreeArray1D((void *) ie_proc);
<   FreeArray1D((void *) jb_proc); FreeArray1D((void *) je_proc);
<   FreeArray1D((void *) kb_proc); FreeArray1D((void *) ke_proc);
<   FreeArray1D((void *) xb_proc); FreeArray1D((void *) xe_proc);
<   FreeArray1D((void *) yb_proc); FreeArray1D((void *) ye_proc);
<   FreeArray1D((void *) zb_proc); FreeArray1D((void *) ze_proc);
< 
<   print1 ("\n");
---
>   print (" \n");
429,430c363,364
<     print1 ("\n! Cylindrical coordinates are only 2D.\n");
<     print1 ("! Use polar instead.\n");
---
>     print ("\n! Cylindrical coordinates are only 2D.\n");
>     print ("! Use polar instead.\n");
436c370
<      print1 ("\n ! Spherical 3D only works with RK integrators\n");
---
>      print ("\n ! Spherical 3D only works with RK integrators\n");
443,448d376
<   #if DIMENSIONAL_SPLITTING == NO && DIMENSIONS == 1
<    #ifndef CH_SPACEDIM
<     print1 ("! CheckConfig(): Cannot integrate a 1-D problem with an unsplit method \n");
<     QUIT_PLUTO(1);
<    #endif
<   #endif
451c379
<   print1 ("! CheckConfig(): CT requires dimensional unsplit scheme.\n");
---
>   print ("! CheckConfig(): CT requires dimensional unsplit scheme.\n");
459c387
<     print1 (" ! Spherical and Polar geometries work with RK integrators\");
---
>     print (" ! Spherical and Polar geometries work with RK integrators\");
diff Src/split_source.c ../old/split_source.c
19c19
<   \date    May 10, 2013
---
>   \date    Oct 26, 2016
25c25
< void SplitSource (const Data *d, double dt, Time_Step *Dts, Grid *grid)
---
> void SplitSource (const Data *d, double dt, timeStep *Dts, Grid *grid)
39,44c39
< /*  ---- GLM source term treated in main ----  */
< /*
<   #ifdef GLM_MHD
<    GLM_SOURCE (d->Vc, dt, grid);
<   #endif
< */
---
> 
49,56c44,52
<   #if COOLING != NO
<    #if COOLING == POWER_LAW  /* -- solve exactly -- */
<     PowerLawCooling (d->Vc, dt, Dts, grid);
<    #elif COOLING == BLONDIN
<     BlondinCooling (d->Vc, dt, Dts, grid);
<    #else
<     CoolingSource (d, dt, Dts, grid);
<    #endif
---
> #if COOLING != NO
>   #if COOLING == POWER_LAW  /* -- solve exactly -- */
>   PowerLawCooling (d->Vc, dt, Dts, grid);
>   #elif COOLING == KROME /* -- Interfaced krome solvers -- */
>   KromeCooling (d, dt, Dts, grid);
>   #elif COOLING == BLONDIN
>   BlondinCooling (d->Vc, dt, Dts, grid);
>   #else
>   CoolingSource (d, dt, Dts, grid);
57a54
> #endif
67,69c64,70
<   #if (PARABOLIC_FLUX & SUPER_TIME_STEPPING)
<    STS (d, Dts, grid);
<   #endif
---
> #if (PARABOLIC_FLUX & SUPER_TIME_STEPPING)
>   STS (d, dt, Dts, grid);
> #endif
> 
> #if (PARABOLIC_FLUX & RK_LEGENDRE)
>   RKL (d, dt, Dts, grid);
> #endif
71,73d71
<   #if (PARABOLIC_FLUX & RK_CHEBYSHEV)
<    RKC (d, Dts, grid);
<   #endif
diff Src/startup.c ../old/startup.c
11c11,14
<   \date   Aug 16, 2012
---
>           B. Vaidya
> 
>   \Last Change  D. Mukherjee
>   \date         May 25, 2018
14a18
> double FieldAverage(double, double, Grid *, int, int);
17c21
< void Startup (Data *d, Grid *G)
---
> void Startup (Data *d, Grid *grid)
33c37
<   double us[256], u_av[256], b[3]; 
---
>   double us[256], u_av[256], bp[3], bm[3]; 
35d38
<   struct GRID *GX, *GY, *GZ;
37,39c40,45
<   GX = G;
<   GY = G + 1;
<   GZ = G + 2;
---
> /* ------------------------------------------------------
>    0. Initialize function by allocating memory
>       and setting labels.
>    ------------------------------------------------------ */
> 
>   print ("> Assigning initial conditions (Startup) ...\n");
46,47d51
< /* ----  set labels  ---- */
< 
58,67c62,65
< /* ----------------------------------------------------------
<     If the -input-data-file command line argument is given, 
<     try to read initial conditions from external files.
<    ---------------------------------------------------------- */
<     
<   print1 ("> Assigning initial conditions (Startup) ...\n");
< 
< /* --------------------------------------------------------------
<                     Assign initial conditions   
<    -------------------------------------------------------------- */
---
> /* ------------------------------------------------------
>    1. Assign initial conditions point by point using
>       primitive variables.
>    ------------------------------------------------------ */
72a71,72
>   /* -- Define coordinates -- */
> 
74,76c74,76
<      x1 = GX->xgc[i]; x1p = GX->xr[i]; dx1 = GX->dx[i];
<      x2 = GY->xgc[j]; x2p = GY->xr[j]; dx2 = GY->dx[j];
<      x3 = GZ->xgc[k]; x3p = GZ->xr[k]; dx3 = GZ->dx[k];
---
>     x1 = grid->xgc[IDIR][i]; x1p = grid->xr[IDIR][i]; dx1 = grid->dx[IDIR][i];
>     x2 = grid->xgc[JDIR][j]; x2p = grid->xr[JDIR][j]; dx2 = grid->dx[JDIR][j];
>     x3 = grid->xgc[KDIR][k]; x3p = grid->xr[KDIR][k]; dx3 = grid->dx[KDIR][k];
78,80c78,80
<      x1 = GX->x[i]; x1p = GX->xr[i]; dx1 = GX->dx[i];
<      x2 = GY->x[j]; x2p = GY->xr[j]; dx2 = GY->dx[j];
<      x3 = GZ->x[k]; x3p = GZ->xr[k]; dx3 = GZ->dx[k];
---
>     x1 = grid->x[IDIR][i]; x1p = grid->xr[IDIR][i]; dx1 = grid->dx[IDIR][i];
>     x2 = grid->x[JDIR][j]; x2p = grid->xr[JDIR][j]; dx2 = grid->dx[JDIR][j];
>     x3 = grid->x[KDIR][k]; x3p = grid->xr[KDIR][k]; dx3 = grid->dx[KDIR][k];
83c83
<     for (nv = NVAR; nv--; ) d->Vc[nv][k][j][i] = u_av[nv] = 0.0;
---
>   /* -- Reset arrays -- */
85,87c85
< /*  ----------------------------------------------------------------
<                 Compute volume averages      
<     ---------------------------------------------------------------- */
---
>     NVAR_LOOP(nv) d->Vc[nv][k][j][i] = u_av[nv] = 0.0;
89,90c87,91
<     #ifdef PSI_GLM
<      u_av[PSI_GLM] = us[PSI_GLM] = 0.0;
---
>     #ifdef GLM_MHD
>     u_av[PSI_GLM] = us[PSI_GLM] = 0.0;
>     #ifdef PHI_GLM
>     u_av[PHI_GLM] = us[PHI_GLM] = 0.0;
>     #endif
95,97c96,98
<      for (ksub = 0; ksub < nsub; ksub++){ 
<      for (jsub = 0; jsub < nsub; jsub++){ 
<      for (isub = 0; isub < nsub; isub++){ 
---
>     for (ksub = 0; ksub < nsub; ksub++){ 
>     for (jsub = 0; jsub < nsub; jsub++){ 
>     for (isub = 0; isub < nsub; isub++){ 
99,107c100,106
<        x1s = x1 + (double)(1.0 - nsub + 2.0*isub)/(double)(2.0*nsub)*dx1;
<        x2s = x2 + (double)(1.0 - nsub + 2.0*jsub)/(double)(2.0*nsub)*dx2;
<        x3s = x3 + (double)(1.0 - nsub + 2.0*ksub)/(double)(2.0*nsub)*dx3;
< 
<        Init (us, x1s, x2s, x3s);
<        for (nv = 0; nv < NVAR; nv++) {
<          u_av[nv] += us[nv]/(double)(nsub*nsub*nsub);
<        }
<      }}}
---
>       x1s = x1 + (double)(1.0 - nsub + 2.0*isub)/(double)(2.0*nsub)*dx1;
>       x2s = x2 + (double)(1.0 - nsub + 2.0*jsub)/(double)(2.0*nsub)*dx2;
>       x3s = x3 + (double)(1.0 - nsub + 2.0*ksub)/(double)(2.0*nsub)*dx3;
> 
>       Init (us, x1s, x2s, x3s);
>       NVAR_LOOP(nv) u_av[nv] += us[nv]/(double)(nsub*nsub*nsub);
>     }}}
111c110
<      Init (u_av, x1, x2, x3);
---
>     Init (u_av, x1, x2, x3);
117,136c116,132
< /* -----------------------------------------------------
<         Initialize cell-centered vector potential 
<         (only for output purposes)
<    ----------------------------------------------------- */
< 
<     #if PHYSICS == MHD || PHYSICS == RMHD
<      #if UPDATE_VECTOR_POTENTIAL == YES
<       D_EXPAND(                     ,
<         d->Ax3[k][j][i] = u_av[AX3];  ,
<         d->Ax1[k][j][i] = u_av[AX1];  
<         d->Ax2[k][j][i] = u_av[AX2];)
<      #endif
<     #endif
< 
<  /* -------------------------------------------------------------
<      Assign staggered components;
<      If a vector potential is used (ASSIGN_VECTOR_POTENTIAL == YES),
<      use the STAGGERED_INIT routine;
<      otherwise assign staggered components directly from 
<      the init.c and ignore the vector potential.
---
>   /* -- Initialize cell-centered vector potential 
>         (only for output purposes)                -- */
> 
>     #if (PHYSICS == MHD || PHYSICS == RMHD) && (ASSIGN_VECTOR_POTENTIAL == YES)
>   /* ------------------------------------------------------
>      Store vector potential into array for later
>      differentiation. 
>      - Note that staggered MHD requires A[]
>      to be staggered (Ax1[0++], Ax2[+0+], Ax3[++0]).
>      - All 3 components must be given here. 
>      - Vector potential is always staggered.
>      ------------------------------------------------------ */
>     Init (u_av, x1, x2p, x3p);
>     d->Ax1[k][j][i] = u_av[AX1];  
> 
>     Init (u_av, x1p, x2, x3p);
>     d->Ax2[k][j][i] = u_av[AX2];
138c134,142
<      NOTE: in N dimensions only N components are assigned 
---
>     Init (u_av, x1p, x2p, x3);
>     d->Ax3[k][j][i] = u_av[AX3];
> 
>     #endif
> 
>  /* -------------------------------------------------------
>      Assign staggered components directly from 
>      the init.c  if ASSIGN_VECTOR_POTENTIAL not defined 
>     NOTE: in N dimensions only N components are assigned 
140c144
<     ------------------------------------------------------------- */    
---
>     ------------------------------------------------------- */    
142,154c146,149
<     #if PHYSICS == MHD || PHYSICS == RMHD
<      #if ASSIGN_VECTOR_POTENTIAL == YES
<       VectorPotentialDiff(b, i, j, k, G);
< 
<       #ifdef STAGGERED_MHD
<        for (nv = 0; nv < DIMENSIONS; nv++) {
<          d->Vs[nv][k][j][i] = b[nv];
<        }
<       #else
<        for (nv = 0; nv < DIMENSIONS; nv++) {
<          d->Vc[BX1+nv][k][j][i] = b[nv];
<        }
<       #endif
---
>     #if (defined STAGGERED_MHD) && (ASSIGN_VECTOR_POTENTIAL == NO)
>     D_EXPAND(
>              Init (u_av, x1p, x2, x3);
>              d->Vs[BX1s][k][j][i] = u_av[BX1];       ,
156c151,152
<      #else
---
>              Init (u_av, x1, x2p, x3);
>              d->Vs[BX2s][k][j][i] = u_av[BX2];       ,
158,171c154,156
<       #ifdef STAGGERED_MHD
<        D_EXPAND(
<          Init (u_av, x1p, x2, x3);
<          d->Vs[BX1s][k][j][i] = u_av[BX1];       ,
< 
<          Init (u_av, x1, x2p, x3);
<          d->Vs[BX2s][k][j][i] = u_av[BX2];       ,
< 
<          Init (u_av, x1, x2, x3p);
<          d->Vs[BX3s][k][j][i] = u_av[BX3];
<        )
<       #endif
<      #endif  /* ASSIGN_VECTOR_POTENTIAL */
<     #endif /* PHYSICS == MHD || PHYSICS == RMHD */
---
>              Init (u_av, x1, x2, x3p);
>              d->Vs[BX3s][k][j][i] = u_av[BX3];)
>     #endif
174a160,177
> /* --------------------------------------------------------
>    2. Call Init_Domain() to assign primitive variables
>       by looping over computational cells.
>       This is new in PLUTO 4.3 and provides an
>       alternative to the pointwise initialization.
>    -------------------------------------------------------- */
> 
>   InitDomain(d, grid);
> 
>  /*----------------------------------------------------------------- 
>    3. Assign magnetic field from vector potential.
>       Assignments run from array elements 1 to NX#_TOT-2,
>       because the magnetic field needs extra cells for derivatives.
>       The extremal points are to be assigned at the 
>       boundary conditions or domain swap.
>   ------------------------------------------------------------------*/
> 
>   #if (PHYSICS ==  MHD || PHYSICS == RMHD) && ASSIGN_VECTOR_POTENTIAL == YES
175a179,200
>   for (k = KOFFSET; k < NX3_TOT-KOFFSET; k++) { 
>   for (j = JOFFSET; j < NX2_TOT-JOFFSET; j++){
>   for (i = IOFFSET; i < NX1_TOT-IOFFSET; i++){ 
>       VectorPotentialDiff(bp, d, i, j, k, grid);
>       for (nv = 0; nv < DIMENSIONS; nv++) d->Vs[nv][k][j][i] = bp[nv];
>   }}}
>   #else
> 
> /*Note: Start from 2 as we call bm, which passes i-1 
>        to vec_pot_diff which calls i-2 */
>   for (k = 2*KOFFSET; k < NX3_TOT-KOFFSET; k++){  
>   for (j = 2*JOFFSET; j < NX2_TOT-JOFFSET; j++){
>   for (i = 2*IOFFSET; i < NX1_TOT-IOFFSET; i++){ 
> 
>       VectorPotentialDiff(bp, d, i, j, k, grid);
>       VectorPotentialDiff(bm, d, i-1, j, k, grid);
>       d->Vc[BX1][k][j][i] = FieldAverage(bp[0], bm[0], grid, IDIR, i);
> 
>       #if DIMENSIONS == 2
>       VectorPotentialDiff(bm, d, i, j-1, k, grid);
>       d->Vc[BX2][k][j][i] = FieldAverage(bp[1], bm[1], grid, JDIR, j);
>       #endif
177,191c202,208
<   /* ---------------------------------------------------
<        Compute cell-centered magnetic field  
<        by simple arithmetic averaging. This 
<        is useful only for saving the first 
<        output, since the average will be 
<        re-computed at the beginning of the computation.
<      --------------------------------------------------- */
< 
<    DOM_LOOP(k,j,i){
<      D_EXPAND( 
<        d->Vc[BX1][k][j][i] = 0.5*(d->Vs[BX1s][k][j][i] + d->Vs[BX1s][k][j][i-1]); , 
<        d->Vc[BX2][k][j][i] = 0.5*(d->Vs[BX2s][k][j][i] + d->Vs[BX2s][k][j-1][i]); ,
<        d->Vc[BX3][k][j][i] = 0.5*(d->Vs[BX3s][k][j][i] + d->Vs[BX3s][k-1][j][i]);
<      )
<    }
---
>       #if DIMENSIONS == 3    
>       VectorPotentialDiff(bm, d, i, j, k-1, grid);
>       d->Vc[BX3][k][j][i] = FieldAverage(bp[2], bm[2], grid, KDIR, k);
>       #endif
>   }}}
>   #endif /* STAGGERED_MHD */
>   #endif
192a210,219
> /* --------------------------------------------------------
>    4. Initialize Forced-Turbulence module
>    -------------------------------------------------------- */
> 
>   #if FORCED_TURB == YES
>     struct ForcedTurb *Ft;
>     Ft = d->Ft;
>     ForcedTurb_Init(Ft);
>     print("> Initialized Forced Turbulence %d Modes\n",Ft->NModes);
>     ForcedTurb_OUNoiseInit(Ft->OUPhases, 6*(Ft->NModes), Ft->OUVar);
195,197c222,252
< /* --------------------------------------------------------------------
<          Check if values have physical meaning...
<    -------------------------------------------------------------------- */
---
> /* --------------------------------------------------------
>    5. Compute cell-centered magnetic field by simple
>       arithmetic averaging.
>       Useful only for saving the first output, since the
>       average will be re-computed anyway at the beginning
>       of the computation.
>    -------------------------------------------------------- */
> 
> #ifdef STAGGERED_MHD
>   DOM_LOOP(k,j,i){
>     D_EXPAND( 
>       d->Vc[BX1][k][j][i] = 0.5*(d->Vs[BX1s][k][j][i] + d->Vs[BX1s][k][j][i-1]); , 
>       d->Vc[BX2][k][j][i] = 0.5*(d->Vs[BX2s][k][j][i] + d->Vs[BX2s][k][j-1][i]); ,
>       d->Vc[BX3][k][j][i] = 0.5*(d->Vs[BX3s][k][j][i] + d->Vs[BX3s][k-1][j][i]);
>     )
>   /*  Use the new fieldAverage routine to be consistent? */
> /*   
>     D_EXPAND(
>      d->Vc[BX1][k][j][i] = FieldAverage(d->Vs[BX1s][k][j][i], d->Vs[BX1s][k][j][i-1], 
>                                         grid, IDIR, i); ,
>      d->Vc[BX2][k][j][i] = FieldAverage(d->Vs[BX2s][k][j][i], d->Vs[BX2s][k][j-1][1], 
>                                         grid, JDIR, j); ,
>      d->Vc[BX3][k][j][i] = FieldAverage(d->Vs[BX3s][k][j][i], d->Vs[BX3s][k-1][j][1], 
>                                         grid, KDIR, k); )
> */                                        
>   }
> #endif
> 
> /* ------------------------------------------------------
>    6.  Check if values have physical meaning.
>    ------------------------------------------------------ */
200,202c255,257
<   KDOM_LOOP(k){ x3 = GZ->x[k];
<   JDOM_LOOP(j){ x2 = GY->x[j];
<   IDOM_LOOP(i){ x1 = GX->x[i];
---
>   KDOM_LOOP(k){ x3 = grid->x[KDIR][k];
>   JDOM_LOOP(j){ x2 = grid->x[JDIR][j];
>   IDOM_LOOP(i){ x1 = grid->x[IDIR][i];
227,229c282,354
< /* --------------------------------------------------------------------
<      Convert primitive variables to conservative ones
<    -------------------------------------------------------------------- */
---
> /* ------------------------------------------------------
>    7. Set boundary conditions.
>    ------------------------------------------------------ */
> 
>   Boundary (d, -1, grid);
> }
> 
> /* ********************************************************************* */
> double FieldAverage(double bp, double bm, Grid *grid, int dir, int l)
> /*!
>  *  Computes the volume average of staggered magnetic fields to return
>  *  cell-centred values. 
>  *  bp: B component at right staggered face (e.g. Bx[i, j, k])
>  *  bm: B component at left staggered face  (e.g. Bx[i-1, j, k])
>  *  dir: direction of staggered. options: IDIR, JDIR, KDIR
>  *  l:  integer for cell along direction of staggered.
>  *  Grid: PLUTO grid structure.
>  *  return: average field.
> 
>  *********************************************************************** */
> {
>   double bavg;
>  #if (GEOMETRY == CYLINDRICAL) || (GEOMETRY == POLAR) || (GEOMETRY == SPHERICAL)  
>   double rp, rm;
>  #endif
>  #if GEOMETRY == SPHERICAL 
>   double thp, thm, sp, sm, dx, dV;
>  #endif
>  
>   if ((dir != IDIR) && (dir != JDIR) && (dir != KDIR)) {
>      print("! Wrong dir in FieldAvergae. Abort! \n");
>      QUIT_PLUTO(1);
>      } 
> 
>  #if   GEOMETRY == CARTESIAN
>   bavg = 0.5*(bp + bm);
> 
>  #elif GEOMETRY == CYLINDRICAL 
>   if (dir == IDIR) {
>      rp   = grid->xr[dir][l];
>      rm   = grid->xl[dir][l];
>      bavg = (rp*bp + rm*bm)/(rp + rm);              
>      } else bavg = 0.5*(bp + bm);
> 
>  #elif GEOMETRY == POLAR /* Note: Polar is same as cylindrical.
>                                   Creating separate entries if
>                                   changes are needed in future. */
>   if (dir == IDIR) {
>      rp = grid->xr[dir][l];
>      rm = grid->xl[dir][l];
>      bavg = (rp*bp + rm*bm)/(rp + rm);              
>      } else bavg = 0.5*(bp + bm);
> 
>  #elif GEOMETRY == SPHERICAL
>   if (dir == IDIR) {
>      rp   = grid->xr[dir][l];
>      rm   = grid->xl[dir][l];
>      dx   = grid->dx[dir][l];
>      dV   = (rp*rp*rp - rm*rm*rm)/3.;
>      bavg = 0.5*(rp*rp*bp + rm*rm*bm)*dx/dV;
>      } 
>      else if (dir == JDIR){
>      thp  = grid->xr[dir][l];     
>      thm  = grid->xl[dir][l];
>      sp   = fabs(sin(thp));
>      sm   = fabs(sin(thm));
>      dx   = grid->dx[dir][l];
>      dV   = fabs(cos(thm) - cos(thp)); 
>      bavg = 0.5*(sp*bp + sm*bm)*dx/dV;
>      } else bavg = 0.5*(bp + bm);
>   #endif
> 
>  return bavg;
231,245d355
<   Boundary (d, -1, G);
<   
< /* --------------------------------------------------------------------
<                     Convert to conservative
<    -------------------------------------------------------------------- */
< /*
<   KDOM_LOOP(k) {
<   JDOM_LOOP(j){
<     IDOM_LOOP(i) {
<     for (nv = NVAR; nv--;  ) {
<       uprim[i][nv] = d->Vc[nv][k][j][i];
<     }}
<     PrimToCons(uprim, d->Uc[k][j], IBEG, IEND);
<   }}
< */
Only in ../old: startup_old.c
diff Src/structs.h ../old/structs.h
7c7
<   \date   July 31, 2014
---
>   \date   March 16, 2018
11c11
< typedef struct CMD_LINE {
---
> typedef struct Cmd_line_{
16,17c16,17
<   int write;         
<   int maxsteps;
---
>   int write;     /**< Set it 1 or 0 to enable or disable writing. */         
>   int maxsteps;  /**< The maximum number of steps (unless negative) */
21d20
<   int show_dec; /* -- show domain decomposition ? -- */
25c24
<    
---
> 
30,37c29,36
< typedef struct DATA{
<   double ****Vc;  /**< The main four-index data array used for cell-centered
<                        primitive variables. The index order is
<                        <tt>Vc[nv][k][j][i]</tt> where \c nv gives the variable
<                        index while \c k,\c j and \c i are the
<                        locations of the cell in the \f$x_3\f$,
<                        \f$x_2\f$ and \f$x_1\f$ direction. */
<   double ****Uc;  /**< The main four-index data array used for cell-centered
---
> typedef struct Data_{
>   double ****Vc;    /**< The main four-index data array used for cell-centered
>                         primitive variables. The index order is
>                         <tt>Vc[nv][k][j][i]</tt> where \c nv gives the variable
>                         index while \c k,\c j and \c i are the
>                         locations of the cell in the \f$x_3\f$,
>                         \f$x_2\f$ and \f$x_1\f$ direction. */
>   double ****Uc;    /**< The main four-index data array used for cell-centered
43,48c42,47
<   double ****Vs;  /**< The main four-index data array used for face-centered
<                        staggered magnetic fields. 
<                        The index order is <tt>Vc[nv][k][j][i]</tt>,
<                        where \c nv gives the variable index, \c k,\c j and \c i
<                        are the locations of the cell in the \f$x_3\f$,
<                        \f$x_2\f$ and \f$x_1\f$ direction. */
---
>   double ****Vs;    /**< The main four-index data array used for face-centered
>                          staggered magnetic fields. 
>                          The index order is <tt>Vc[nv][k][j][i]</tt>,
>                          where \c nv gives the variable index, \c k,\c j and \c i
>                          are the locations of the cell in the \f$x_3\f$,
>                          \f$x_2\f$ and \f$x_1\f$ direction. */
51,54c50,54
<   double ***Ax1;  /**< Vector potential component in the \f$x_1\f$ direction.*/
<   double ***Ax2;  /**< Vector potential component in the \f$x_2\f$ direction.*/
<   double ***Ax3;  /**< Vector potential component in the \f$x_3\f$ direction.*/
<   double ****J;   /**< Electric current defined as curl(B). */
---
>   double ***Ax1;    /**< Vector potential comp. in the \f$x_1\f$ dir.*/
>   double ***Ax2;    /**< Vector potential comp. in the \f$x_2\f$ dir.*/
>   double ***Ax3;    /**< Vector potential comp. in the \f$x_3\f$ dir.*/
>   double ****J;     /**< Electric current defined as curl(B). */
>   double ***Tc;     /**< Dimensionless temperature array (used for TC) */
57c57,87
<   char fill[28];  /* make the structure a power of two.  */
---
> 
>   /* -- Particles-related quantities -- */
> 
>   struct particleNode_ *PHead;   /* Must use full declaration since particleNode
>                                     typdef will come later on. */
> 
>   double ****Fcr;   /**< A four-element 3D array used to compute the three
>                          components of the force and the energy source term
>                          of the CR feedback on the fluid. */
>   double ****Jcr;   /**< The CR current density 3D array. */
>   double ***qcr;    /**< The CR charge density 3D array. */
>   double ****Ecr;   /**< The electric field in the MHD-PIC formalism. */
> 
>   double ****Vdust; /**< Deposit dust particle velocity  */
>   double ****Fdust; /**< Deposit dust drag force        */
>   struct Particle_ **pstr;  /**< Used to convert a linked list to array (useful ?) */
> 
> /* EMF  */
>   double ***Ex1; /**< cell-centered emf used in CT averaging or CR particles */
>   double ***Ex2; /**< cell-centered emf used in CT averaging or CR particles */  
>   double ***Ex3; /**< cell-centered emf used in CT averaging or CR particles */
> 
>   struct ElectroMotiveForce *emf;
> 
> /* Others */
>   struct timeStep_  *Dts;
> 
>   /* ForcedTurb */
>   struct ForcedTurb *Ft;
>   
>   char fill[78];  /* make the structure a power of two.  */
60a91,148
> /*! The EMF structure is used to pull together all the information 
>     necessary to build / use the electromotive force used to update
>     the staggered components of magnetic field.
>    ********************************************************************* */
> typedef struct ElectroMotiveForce{
> 
> /*! \name Face-centered electric field components.
>     Three-dimensional arrays storing the emf components computed
>     at cell faces during the dimensional sweeps.     
> */
> /**@{ */
>   double ***exj; /**< Ex available at y-faces (j+1/2); */
>   double ***exk; /**< Ex available at z-faces (k+1/2); */
>   double ***eyi; /**< Ey available at x-faces (i+1/2); */
>   double ***eyk; /**< Ey available at z-faces (k+1/2); */
>   double ***ezi; /**< Ez available at x-faces (i+1/2); */
>   double ***ezj; /**< Ez available at y-faces (j+1/2); */
> /**@} */
> 
>   signed char ***svx, ***svy, ***svz;
> 
> /*! \name Range of existence */
> /**@{ */
>   int  ibeg, jbeg, kbeg;
>   int  iend, jend, kend;
> /**@} */
> 
> /*! \name Signal velocities  */
> /**@{ */
>   double ***SxL;
>   double ***SxR;
>   double ***SyL;
>   double ***SyR;
>   double ***SzL;
>   double ***SzR;
> /**@} */
> 
> /*! \name Edge-centered fields   */
> /**@{ */
>   double ***ex;
>   double ***ey;
>   double ***ez;
> /**@} */
> 
> /*! \name Staggered magnetic field and velocity slopes */
> /**@{ */
>   double ***dbx_dy, ***dbx_dz;  
>   double ***dby_dx, ***dby_dz;
>   double ***dbz_dx, ***dbz_dy;
> 
>   double ***dvx_dx, ***dvy_dx, ***dvz_dx;
>   double ***dvx_dy, ***dvy_dy, ***dvz_dy;
>   double ***dvx_dz, ***dvy_dz, ***dvz_dz;
> /**@} */
> 
> } EMF;
>  
> /* ********************************************************************* */
78,84c166,173
< typedef struct GRID{
<   double xi, xf;        /**< Leftmost and rightmost point in the local domain. */
<   double *x, *x_glob;   /**< Cell geometrical central points. */
<   double *xr, *xr_glob; /**< Cell right interface. */
<   double *xl, *xl_glob; /**< Cell left interface. */
<   double *dx, *dx_glob; /**< Cell size.  */ 
<   double *xgc;          /**< Cell volumetric centroid 
---
> typedef struct Grid_{
>   double xbeg[3], xend[3];           /**< Leftmost and rightmost points in local domain. */
>   double xbeg_glob[3], xend_glob[3];  /**< Leftmost and rightmost point in the global domain. */
>   double *x[3], *x_glob[3];   /**< Cell geometrical central points. */
>   double *xr[3], *xr_glob[3]; /**< Cell right interface. */
>   double *xl[3], *xl_glob[3]; /**< Cell left interface. */
>   double *dx[3], *dx_glob[3]; /**< Cell width.  */ 
>   double *xgc[3];          /**< Cell volumetric centroid 
86,91c175,186
<   double *dV;           /**< Cell volume.  */
<   double *A;            /**< Right interface area, A[i] = \f$A_{i+\HALF}\f$. */
<   double *r_1;          /**< Geometrical factor 1/r.  */
<   double *ct;           /**< Geometrical factor cot(theta).  */
<   double *inv_dx;       /**<      */
<   double *inv_dxi;      /**< inverse of the distance between the center of 
---
>   double  ***dV;           /**< Cell volume.  */
>   double  ***A[3];         /**< Right interface area, A[i] = \f$A_{i+\HALF}\f$. */
>   double  **dx_dl[3];      /**< dx/dl (dl = length), used for gradient-like operators */
>   double *rt;              /**< In spherical coordinates, gives \tilde{r} */
>   double *sp;              /**< In spherical coordinates, gives fabs(sin(th))
>                                 at a j+1/2 interface */
>   double *s;               /**< In spherical coordinates, gives fabs(sin(th))
>                                 at the cell center */
>   double *dmu;             /** < In spherical coordinates, gives the \theta
>                                  volume = fabs(cos(th_m) - cos(th_p)) */
>   double *inv_dx[3];       /**<      */
>   double *inv_dxi[3];      /**< inverse of the distance between the center of 
94c189
<   double dl_min;      /**<  minimum cell length (e.g. min[dr, r*dth,
---
>   double dl_min[3];      /**<  minimum cell length (e.g. min[dr, r*dth,
96c191
<   int np_tot_glob; /**< Total number of points in the global domain 
---
>   int np_tot_glob[3]; /**< Total number of points in the global domain 
98c193
<   int np_int_glob; /**< Total number of points in the global domain 
---
>   int np_int_glob[3]; /**< Total number of points in the global domain 
100c195
<   int np_tot;      /**< Total number of points in the local domain 
---
>   int np_tot[3];      /**< Total number of points in the local domain 
102c197
<   int np_int;      /**< Total number of points in the local domain 
---
>   int np_int[3];      /**< Total number of points in the local domain 
104,105c199,200
<   int nghost;      /**< Number of ghost zones. */
<   int lbound;      /**< When different from zero, it specifies the boundary
---
>   int nghost[3];      /**< Number of ghost zones. */
>   int lbound[3];      /**< When different from zero, it specifies the boundary
112,123c207,218
<   int rbound;      /**< Same as lbound, but for the right edge of the grid. */
<   int gbeg;        /**< Global start index for the global array. */
<   int gend;        /**< Global end   index for the global array. */
<   int beg;         /**< Global start index for the local array. */
<   int end;         /**< Global end   index for the local array. */
<   int lbeg;        /**< Local start  index for the local array. */
<   int lend;        /**< Local end    index for the local array. */
<   int uniform;     /* = 1 when the grid is cartesian AND uniform everywhere  */
<   int nproc;       /**< number of processors for this grid. */
<   int rank_coord;  /**< Parallel coordinate in a Cartesian topology. */
<   int level;       /**< The current refinement level (chombo only). */
<   char fill[40];   /* useless, just to make the structure size a power of 2 */
---
>   int rbound[3];      /**< Same as lbound, but for the right edge of the grid. */
>   int gbeg[3];        /**< Global start index for the global array. */
>   int gend[3];        /**< Global end   index for the global array. */
>   int beg[3];         /**< Global start index for the local array. */
>   int end[3];         /**< Global end   index for the local array. */
>   int lbeg[3];        /**< Local start  index for the local array. */
>   int lend[3];        /**< Local end    index for the local array. */
>   int uniform[3];     /* = 1 when the grid is cartesian AND uniform everywhere  */
>   int nproc[3];       /**< number of processors for this grid. */
>   int rank_coord[3];  /**< Parallel coordinate in a Cartesian topology. */
>   int level;          /**< The current refinement level (chombo only). */
>   char fill[376];   /* useless, just to make the structure size a power of 2 */
125c220
<    
---
> 
127,129c222,322
< /*! This structure contains one-dimensional vectors of conserved variables,   
<     primitive variables, fluxes and so on, used during the 
<     reconstruct-Solve-Average strategy. 
---
> /*! The RBox (= Rectangular Box) defines a rectangular portion of the 
>     domain in terms of the grid indices <tt>[ibeg,jbeg,kbeg]</tt> corresponding
>     to the lower corner and <tt>[iend,jend,kend]</tt> corresponding to the
>     upper corner. 
>     The integer \c vpos specifies the variable location with respect to 
>     the grid (e.g. center/staggered). 
> 
>     With some macros it is possible to sweep along the box by changing the
>     direction order (e.g.  yxz rather than xyz), see ::BOX_TRANSVERSE_LOOP.
>     In this case the index pointers <tt> n, t, b </tt> (normal, tangent
>     and bitangent) and the corresponding lower and upper bounds must be
>     set properly using the RBoxSetDirections() function.   
>     These are normally used as hidden indices inside the macro.
> 
>     \note The lower and upper grid indices may also be reversed 
>           (e.g. <tt> box->ibeg > box->iend </tt>).
>            In this case the macro ::BOX_LOOP
>           automatically reset the directional increment (\c box->di) to -1.
>    ********************************************************************* */
> typedef struct RBox_{
>   int ibeg; /**< Lower corner index in the x1 direction. */
>   int iend; /**< Upper corner index in the x1 direction. */
>   int jbeg; /**< Lower corner index in the x2 direction. */
>   int jend; /**< Upper corner index in the x2 direction. */
>   int kbeg; /**< Lower corner index in the x3 direction. */
>   int kend; /**< Upper corner index in the x3 direction. */
>   int di;   /**< Directional increment (+1 or -1) when looping over the 1st 
>                  dimension of the box. Automatically set by the ::BOX_LOOP macro. */
>   int dj;   /**< Directional increment (+1 or -1) when looping over the 2nd 
>                  dimension of the box. Automatically set by the ::BOX_LOOP macro. */
>   int dk;   /**< Directional increment (+1 or -1) when looping over the 3rd 
>                  dimension of the box. Automatically set by the ::BOX_LOOP macro. */
>   int vpos; /**< Location of the variable inside the cell. */
>   int *n;   /**< Pointer to the normal index when looping along a specified direction.
>                  Set manually or using a macro. */
>   int *t;   /**< Pointer to tangent index when looping along a specified direction
>                  (e.g. \c j when <tt> dir = IDIR </tt>).
>                  Set manually or using a macro. */
>   int *b;   /**< Pointer to binormal index when looping along a specified direction
>                  (e.g. \c k when <tt> dir = IDIR </tt>) 
>                  Set manually or using a macro. */
>   int *nbeg; /**< Pointer to lower index in the normal direction.
>                   Set by the RBoxSetDirections() function.  */
>   int *nend; /**< Pointer to upper index in the normal direction.
>                   Set by the RBoxSetDirections() function.  */
>   int *tbeg; /**< Pointer to lower index in the tangent direction.
>                   Set by the RBoxSetDirectionsl() function.  */
>   int *tend; /**< Pointer to upper index in the tangent direction.
>                   Set by the RBoxSetDirections() function.  */
>   int *bbeg; /**< Pointer to lower index in the binormal direction.
>                   Set by the RBoxSetDirections() function.  */
>   int *bend; /**< Pointer to upper index in the binormal direction.
>                   Set by the RBoxSetDirections() function.  */
> } RBox;
> 
> /* ********************************************************************* */
> /*! The restart structure contains restart information that must be
>     read from disk to restart PLUTO. 
> 
>     Important: The restart structure should be aligned to a power of 2 to  
>     prevent (for some compilers) from changing the alignment of the
>     structure and therefore troubleshooting when restarting 
>     from files written on different architectures.              
>    ********************************************************************* */
> typedef struct Restart_{
>   int    nstep;
>   int    nfile[MAX_OUTPUT_TYPES];
>   double t;
>   double dt;
>   char   fill[40];  /* Align the structure to power of 2 */
> } Restart;
> 
> /* ********************************************************************* */
> /*! The State structure contains one-dimensional vectors of fluid
>     quantities, often used during 1D computations (Riemann solver,
>     sound speed, etc..), 
>    ********************************************************************* */
> typedef struct State_{
>   double **v;      /**< Array of primitive variables    */
>   double **u;      /**< Array of conservative variables */
>   double **flux;   /**< Array of fluxes                 */
>   double **fluxCR; /**< Array of fluxes incudling CR contribution alone  */
>   double **lambda; /**< Array of eigenvalues associated to Lp, Rp */
>   double **Bbck;   /**< Array of background field components  */
>   double *prs;     /**< Array of total pressure (see, flux)  */
>   double *a2;      /**< Array of sound speeds squared */
>   double *cw;      /**< Array of whistler wave speeds */
>   double *h;       /**< Array of enthalpies */
>   double **J;      /**< Array of currents (e.g. Hall-MHD, RRMHD) */
>   double **cCR;    /**< Cosmic ray velocity times R: cCR = R*u_\CR. */
>   double **Fcr;    /**< Cosmic Rays force (used to copy d->Fcr during
>                         directional sweeps)                      */
>   double ***Lp; /**< Left eigenvectors  (primitive formulation). */
>   double ***Rp; /**< Right eigenvectors (primitive formulation). */
>   char fill[8]; /* Fill structure to power of 2 */
> } State;
> 
> /* ********************************************************************* */
> /*! This structure contains one-dimensional vectors of conserved
>     variables, primitive variables, fluxes and so on, used during
>     the reconstruct-Solve-Average strategy. 
133,134c326,327
< typedef struct STATE_1D{
<   double **v;    /**< Cell-centered primitive varables at the base time level,
---
> typedef struct Sweep_{
>   double **vn;    /**< Cell-centered primitive varables at the base time level,
136,148d328
<   double **vL;   /**< Primitive variables to the left of the interface, 
<                        \f${\rm vL[i]} \equiv \vec{V}_{i,+} = 
<                            \vec{V}^L_{i+\HALF} \f$. */
<   double **vR;   /**< Primitive variables to the right of the interface, 
<                        \f$\mathrm{vR[i]} \equiv \vec{V}^R_{i+\HALF} \f$. */
<   double **vm;   /**< prim vars at i-1/2 edge, vm[i] = vR(i-1/2)     */
<   double **vp;   /**< prim vars at i+1/2 edge, vp[i] = vL(i+1/2)     */
< 
<   double **uL;   /**< same as vL, in conservative vars */
<   double **uR;   /**< same as vR, in conservative vars */
<   double **um;   /**< same as vm, in conservative vars */
<   double **up;   /**< same as vp, in conservative vars */
< 
150,151d329
<   double **visc_flux; /**< Viscosity flux             */
<   double **visc_src;  /**< Viscosity source term      */
153d330
<   double **res_flux;  /**< Resistive flux (current)   */
155,156d331
<   double ***Lp, ***Rp; /**< Left and right primitive eigenvectors */
<   double **lambda;     /**< Characteristic speed associated to Lp and Rp */
158,159d332
<   double *a2;     /**< Sound speed squared */ 
<   double *h;      /**< Enthalpy. */
162d334
<   double **vh;      /**< Primitive    state at n+1/2 (only for one step method) */
167a340,341
> 
> 
169,170c343,347
<   double fill1, fill2;
< } State_1D;
---
>   State stateL;
>   State stateR;
>   State stateC;
>   char fill[40];
> } Sweep;
208d384
< 
210c386
< /*! The Time_Step structure contains essential information for 
---
> /*! The timeStep structure contains essential information for 
213c389
< typedef struct TIME_STEP{
---
> typedef struct timeStep_{
215c391
<   double inv_dta;   /**< Inverse of advection (hyperbolic) time step, 
---
>   double invDt_hyp;   /**< Inverse of hyperbolic time step, 
217c393
<   double inv_dtp;   /**< Inverse of diffusion (parabolic)  time step 
---
>   double invDt_par;   /**< Inverse of parabolic (diffusion)  time step 
218a395
>   double invDt_particles;
222c399,408
<   double rmax_par;  
---
>   double rmax_par;
>   double clock_particles;
>   double clock_particles_bound;
> 
>   double clock_hyp;
>   double clock_par;
>   double clock_cooling;
>   double clock_tot;
> 
>   int    Nsub_particles; /**< Number of sub-cycles in particles */
225,227c411,412
<   char  fill[24];   /* useless, just to make the structure size a power of 2 */
< } Time_Step;
< 
---
>   int    Nrkl;      /**< Maximum number of substeps used in RKL. */
> } timeStep;
232,248c417,440
< typedef struct OUTPUT{
<   int    type;            /**< output format (DBL, FLT, ...) - one per output */
<   int    nvar;            /**< tot. # of vars that can be written - same for all   */
<   int    user_outs;
<   int    cgs;             /**< when set to 1 saves data in c.g.s units     */
<   int    nfile;           /**< current number being saved - one per output */
<   int    dn;              /**< step increment between outputs - one per output */
<   int    *stag_var;       /**< centered or staggered variable - same for all   */
<   int    *dump_var;       /**< select vars being written      - one per output */
<   char   mode[32];        /**< single or multiple files       - one per output */
<   char   **var_name;      /**< variable names                 - same for all   */
<   char   ext[8];          /**< output extension                            */
<   char   dir[256];       /**< output directory name                        */
<   double dt;           /**< time increment between outputs   - one per output */
<   double dclock;       /**< time increment in clock hours     - one per output */
<   double ***V[64];     /**< pointer to arrays being written   - same for all  */
<   char   fill[168];    /**< useless, just to make the structure size a power of 2 */
---
> typedef struct Output_{
>   int    type;         /**< Output data format (DBL, FLT, VTK, ...). */
>   int    nvar;         /**< (Fluid only) Total # of vars that can potentially be written.
>                             This is the same for all kind of outputs   */
>   int    cgs;          /**< (Fluid only) When set to 1, save data in c.g.s units     */
>   int    nfile;        /**< Current number being saved. */
>   int    dn;           /**< Step increment between outputs. */
>   int    stag_var[MAX_OUTPUT_VARS];  /**< (Fluid only). Centered or staggered
>                                            variable - same for all outputs. */
>   int    dump_var[MAX_OUTPUT_VARS];  /**< (Fluid only) Include/exclude variables
>                                            being written.  */
>   int    field_dim[MAX_OUTPUT_VARS]; /**< (Particle only) The dimensionality
>                                           of the field being written
>                                           (scalar = 1, array > 1) */
>   char   mode[32];     /**< (Fluid only) Single or multiple files. */
>   char   **var_name;   /**< (Fluid only) Variable names. Same for all output types.  */
>   char   ext[8];       /**< File extension (.flt, .dbl, etc...)           */
>   char   dir[256];     /**< Output directory name                        */
> 
>   double dt;           /**< Time increment between outputs. */
>   double dclock;       /**< Time increment in clock hours. */
>   double ***V[MAX_OUTPUT_VARS]; /**< (Fluid only) Array of pointers to 3D arrays
>                                      to be written - same for all outputs. */
>   char   fill[140];    /**< Useless, just to make the structure size a power of 2 */
255c447
< typedef struct RUNTIME{
---
> typedef struct Runtime_{
269c461,462
<   char   output_dir[256];         /**< The name of the output directory
---
>   char   output_dir[256];         /**< The name of the output directory.
>                                        Default is current directory.
271a465,467
>   char   log_dir[256];            /**< The name of the output directory
>                                        where log files will be written to.
>                                        Default is output_dir. */
274d469
<   double ratio[5];
284a480,485
> 
>   int     Nparticles_glob;  /**< Total number of particles in the whole domain */
>   int     Nparticles_cell;  /**< Total number of particles per cell */
>   double  particles_anl_dt; /* analysis      frequency in time units      */
>   int     particles_anl_dn; /* analysis      frequency in number of steps */
>     
290,295d490
< typedef struct RESTART{
<   int nstep;
<   int nfile[MAX_OUTPUT_TYPES];
<   double t;
<   double dt;
< } Restart;
301c496
< typedef struct IMAGE{
---
> typedef struct Image_{
318,324d512
< typedef struct INDEX{
<   int ntot, beg, end;
<   int *pt1, t1, t1_beg, t1_end;
<   int *pt2, t2, t2_beg, t2_end;
<   char fill[20]; /* useless, just to make the structure size a power of 2 */
< } Index;
< 
327a516,522
>     Variables are stored sequentially in such a way that structure
>     elements can be conveniently initialized upon declaration:
> 
>     intList list = {4, MX1, MX2, MX3, ENG};
>     
>     list will have 4 elements so that, using the FOR_EACH macro
>     a loop will be done on MX1, MX2, MX3, ENG.
329,330c524
< typedef struct INT_LIST{
<   int indx[2046]; /**< Array of integers containg variables indices. */
---
> typedef struct intList_{
331a526
>   int indx[2046]; /**< Array of integers containg variables indices. */
335,361d529
< /* ********************************************************************* */
< /*! The RBox (= Rectangular Box) defines a rectangular portion of the 
<     domain in terms of the grid indices <tt>[ib,jb,kb]</tt> corresponding
<     to the lower corner and <tt>[ie,je,ke]</tt> corresponding to the
<     upper corner. 
<     The integer \c vpos specifies the variable location with respect to 
<     the grid (e.g. center/staggered). 
< 
<     \note The lower and upper grid indices may also be reversed 
<           (e.g. box->ib > box->ie). In this case the macro ::BOX_LOOP
<           automatically reset the directional increment (box->di) to -1.
<    ********************************************************************* */
< typedef struct RBOX{
<   int ib; /**< Lower corner index in the x1 direction. */
<   int ie; /**< Upper corner index in the x1 direction. */
<   int jb; /**< Lower corner index in the x2 direction. */
<   int je; /**< Upper corner index in the x2 direction. */
<   int kb; /**< Lower corner index in the x3 direction. */
<   int ke; /**< Upper corner index in the x3 direction. */
<   int di; /**< Directional increment (+1 or -1) when looping over the 1st 
<                dimension of the box. Automatically set by the ::BOX_LOOP macro. */
<   int dj; /**< Directional increment (+1 or -1) when looping over the 2nd 
<                dimension of the box. Automatically set by the ::BOX_LOOP macro. */
<   int dk; /**< Directional increment (+1 or -1) when looping over the 3rd 
<                dimension of the box. Automatically set by the ::BOX_LOOP macro. */
<   int vpos; /**< Location of the variable inside the cell. */
< } RBox;
diff Src/sts.c ../old/sts.c
10c10
<   ::g_dt and the number of substeps Nsts is given by solving the following
---
>   \c dt and the number of substeps Nsts is given by solving the following
40c40
<   \date    Aug 27, 2015
---
>   \date    May 15, 2017
52c52
< static double STS_FindRoot(double, double, double);
---
> static double STS_FindRoot(double, double);
55c55
< void STS (const Data *d, Time_Step *Dts, Grid *grid)
---
> void STS (const Data *d, double dt, timeStep *Dts, Grid *grid)
60c60,61
<  * \param [in,out]  Dts  pointer to Time_Step structure  
---
>  * \param [in]      dt   the time step increment
>  * \param [in,out]  Dts  pointer to timeStep structure  
67c68
<   double dt_par, tau, tsave, inv_dtp;
---
>   double dt_par, tau, tsave, invDt_par;
69c70
<   RBox *box = GetRBox(DOM, CENTER);
---
>   RBox  box;
71a73
>   RBoxDefine (IBEG, IEND, JBEG, JEND, KBEG, KEND, CENTER, &box);
73,77c75,80
< /* -------------------------------------------------------------
<     Compute the conservative vector in order to start the cycle. 
<     This step will be useless if the data structure 
<     contains Vc as well as Uc (for future improvements).
<    ------------------------------------------------------------- */
---
> /* --------------------------------------------------------
>    0. Compute the conservative vector in order to start
>       the cycle. 
>       This step will be useless if the data structure 
>       contains Vc as well as Uc (for future improvements).
>    -------------------------------------------------------- */
79c82
<   PrimToCons3D(d->Vc, d->Uc, box);
---
>   PrimToCons3D(d->Vc, d->Uc, &box);
82,84c85,87
< /* ------------------------------------------------------------
<                Main STS Loop starts here
<    ------------------------------------------------------------ */
---
> /* --------------------------------------------------------
>    1. Main STS Loop starts here
>    -------------------------------------------------------- */
92,96c95,99
<     inv_dtp = ParabolicRHS(d, rhs, 1.0, grid); 
<     
<   /* --------------------------------------------------------------
<       At the first step (m=0) compute (explicit) parabolic time 
<       step. Restriction on explicit time step should be
---
>     invDt_par = ParabolicRHS(d, rhs, &box, NULL, SUPER_TIME_STEPPING, 1.0, grid);
> 
>   /* -----------------------------------------------------------
>      1a. At the first step (m=0) compute (explicit) parabolic
>          time step. Restriction on explicit time step should be
105c108
<      -------------------------------------------------------------- */
---
>      ----------------------------------------------------------- */
108c111
<       Dts->inv_dtp = inv_dtp/(double)DIMENSIONS;  
---
>       Dts->invDt_par = invDt_par/(double)DIMENSIONS;  
110,111c113,114
<        MPI_Allreduce (&Dts->inv_dtp, &tau, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
<        Dts->inv_dtp = tau;
---
>       MPI_Allreduce (&Dts->invDt_par, &tau, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
>       Dts->invDt_par = tau;
113,114c116,117
<       Dts->inv_dtp = MAX(Dts->inv_dtp, 1.e-18);
<       dt_par = Dts->cfl_par/(2.0*Dts->inv_dtp); /* explicit parabolic 
---
>       Dts->invDt_par = MAX(Dts->invDt_par, 1.e-18);
>       dt_par = Dts->cfl_par/(2.0*Dts->invDt_par); /* explicit parabolic 
121c124
<       N = STS_FindRoot(1.0, dt_par, g_dt);
---
>       N = STS_FindRoot(dt_par, dt);
127c130
<         print1 ("! STS: the number of substeps (%d) is > %d\n",n, STS_MAX_STEPS); 
---
>         print ("! STS: the number of substeps (%d) is > %d\n",n, STS_MAX_STEPS); 
137c140
<         dt_par = STS_CorrectTimeStep(Dts->Nsts, g_dt);
---
>         dt_par = STS_CorrectTimeStep(Dts->Nsts, dt);
141,142c144
<       if (Dts->Nsts == 1) ts[0] = g_dt;
< 
---
>       if (Dts->Nsts == 1) ts[0] = dt;
147,149c149,151
<   /* -----------------------------------------------
<       Update cell-centered conservative variables
<      ----------------------------------------------- */
---
>   /* ------------------------------------------------------
>      1b. Update cell-centered conservative variables
>      ------------------------------------------------------ */
153,155c155,157
<        EXPAND(d->Uc[k][j][i][MX1] += tau*rhs[k][j][i][MX1];  ,
<               d->Uc[k][j][i][MX2] += tau*rhs[k][j][i][MX2];  ,
<               d->Uc[k][j][i][MX3] += tau*rhs[k][j][i][MX3];)
---
>       EXPAND(d->Uc[k][j][i][MX1] += tau*rhs[k][j][i][MX1];  ,
>              d->Uc[k][j][i][MX2] += tau*rhs[k][j][i][MX2];  ,
>              d->Uc[k][j][i][MX3] += tau*rhs[k][j][i][MX3];)
158,160c160,162
<        EXPAND(d->Uc[k][j][i][BX1] += tau*rhs[k][j][i][BX1];  ,
<               d->Uc[k][j][i][BX2] += tau*rhs[k][j][i][BX2];  ,
<               d->Uc[k][j][i][BX3] += tau*rhs[k][j][i][BX3];)
---
>       EXPAND(d->Uc[k][j][i][BX1] += tau*rhs[k][j][i][BX1];  ,
>              d->Uc[k][j][i][BX2] += tau*rhs[k][j][i][BX2];  ,
>              d->Uc[k][j][i][BX3] += tau*rhs[k][j][i][BX3];)
164c166
<            (RESISTIVITY      == SUPER_TIME_STEPPING) || \
---
>            (RESISTIVITY        == SUPER_TIME_STEPPING) || \
166c168
<         d->Uc[k][j][i][ENG] += tau*rhs[k][j][i][ENG]; 
---
>        d->Uc[k][j][i][ENG] += tau*rhs[k][j][i][ENG]; 
170d171
<     #if (defined STAGGERED_MHD) && (RESISTIVITY == SUPER_TIME_STEPPING)
172,200c173,175
<   /* -----------------------------------------------
<       Update staggered magnetic field variables
<      ----------------------------------------------- */
< 
< /* This piece of code should be used for simple Cartesian 2D
<    configurations with constant resistivity.
<    It shows that the stability limit of the resistive part of the
<    induction equation is larger if the right hand side is written 
<    as Laplacian(B) rather than curl(J) 
<    
< double ***Bx, ***By, ***Bz, Jz, dx, dy, dt;
< static double ***Ez, ***Rx, ***Ry;
< if (Ez == NULL) {
<   Ez = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
<   Rx = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
<   Ry = ARRAY_3D(NX3_TOT, NX2_TOT, NX1_TOT, double);
< }
< Bx = d->Vs[BX1s];
< By = d->Vs[BX2s];
< dx = grid[IDIR].dx[IBEG];
< dy = grid[JDIR].dx[JBEG];
< 
< dt = tau;
< k=0;
< for (j = 1; j < NX2_TOT-1; j++) for (i = 1; i < NX1_TOT-1; i++){
<  Jz = (By[k][j][i+1] - By[k][j][i])/dx - (Bx[k][j+1][i] - Bx[k][j][i])/dy;
<  Ez[k][j][i] = Jz*g_inputParam[ETAZ];
<  Rx[k][j][i] =  (Bx[k][j][i+1] - 2.0*Bx[k][j][i] + Bx[k][j][i-1])/(dx*dx)
<               + (Bx[k][j+1][i] - 2.0*Bx[k][j][i] + Bx[k][j-1][i])/(dy*dy);
---
>   /* ------------------------------------------------------
>      1c. Update staggered magnetic field variables
>      ------------------------------------------------------ */
202,217c177,180
<  Ry[k][j][i] =   (By[k][j][i+1] - 2.0*By[k][j][i] + By[k][j][i-1])/(dx*dx)
<                + (By[k][j+1][i] - 2.0*By[k][j][i] + By[k][j-1][i])/(dy*dy);
< }
< 
< JDOM_LOOP(j) for (i = IBEG-1; i <= IEND; i++){
< // Bx[k][j][i] += - dt/dy*(Ez[k][j][i] - Ez[k][j-1][i]);
<  Bx[k][j][i] +=   dt*g_inputParam[ETAZ]*Rx[k][j][i];
< }
< 
< for (j = JBEG-1; j <= JEND; j++) IDOM_LOOP(i){
< // By[k][j][i] += dt/dx*(Ez[k][j][i] - Ez[k][j][i-1]);
<  By[k][j][i] +=   dt*g_inputParam[ETAZ]*Ry[k][j][i];
< }
< */
<      CT_Update  (d, d->Vs, tau, grid);
<      CT_AverageMagneticField (d->Vs, d->Uc, grid);
---
>     #if (defined STAGGERED_MHD) && (RESISTIVITY == SUPER_TIME_STEPPING)
>     CT_ResistiveEMF(d, 0, grid);
>     CT_Update  (d, d->Vs, tau, grid);
>     CT_AverageMagneticField (d->Vs, d->Uc, grid);
220,223c183,186
<   /* --------------------------------------------------
<       Unflag zone tagged with the ENTROPY_SWITCH since
<       only total energy can be evolved using STS
<      -------------------------------------------------- */
---
>   /* ------------------------------------------------------
>      1d. Unflag zone tagged with the ENTROPY_SWITCH since
>          only total energy can be evolved using STS
>      ------------------------------------------------------ */
226c189
<      TOT_LOOP(k,j,i) d->flag[k][j][i] &= ~FLAG_ENTROPY;
---
>     TOT_LOOP(k,j,i) d->flag[k][j][i] &= ~FLAG_ENTROPY;
230,231c193,194
<       convert conservative variables to primitive 
<       for next iteration. Increment loop index.
---
>      1e. Convert conservative variables to primitive 
>          for next iteration. Increment loop index.
234c197
<     ConsToPrim3D(d->Uc, d->Vc, d->flag, box);
---
>     ConsToPrim3D(d->Uc, d->Vc, d->flag, &box);
242,243c205,208
< void STS_ComputeSubSteps(double dtex, double tau[], int ssorder)
< /*
---
> void STS_ComputeSubSteps(double dtex, double tau[], int N)
> /*!
>  * Compute the single sub-step sequence (Eq. [2.9]).
>  * N must be an integer by now.
250,251c215,216
<   for (i = 0; i < ssorder; i++) {
<     tau[i] = dtex / ((-1.0 + STS_NU)*cos(((2.0*i+1.0)*CONST_PI)/(2.0*ssorder)) 
---
>   for (i = 0; i < N; i++) {
>     tau[i] = dtex / ((-1.0 + STS_NU)*cos(((2.0*i+1.0)*CONST_PI)/(2.0*N)) 
258,259c223,230
< double STS_FindRoot(double x0, double dtr, double dta)
< /*
---
> double STS_FindRoot(double dt_exp, double dT)
> /*!
>  * Find the number of sub-steps N by solving Eq. (2.10) of AAG using a
>  * Newton-Raphson scheme. 
>  * Input to the function are:
>  * 
>  * \param [in]  dt_exp   the explicit time step
>  * \param [in]  dt       the super-step.
263,267c234,253
<   double a,b,c;
<   double Ns, Ns1;
<   int n;
< 
<   n = 0;
---
>   int k;  /* Iteration number */
>   double a,b,c, scrh;
>   double fN, N, dN, dfN;
>   double db_dN, sqrt_nu = sqrt(STS_NU);
> 
>   k = 0;
>   N = 1.0;
>   a = (1.0 - sqrt_nu)/(1.0 + sqrt_nu);
>   while(k < 128){
>     b     = pow(a,2.0*N);
>     c     = (1.0-b)/(1.0+b);    /* round bracket in Eq. [10] in AAG */
>     db_dN = 2.0*log(a)*b;
>     scrh  = c - N*2.0/((1.0+b)*(1.0+b))*db_dN;
> 
>     fN  = dT - 0.5*dt_exp/sqrt_nu*N*c;
>     dfN =    - 0.5*dt_exp/sqrt_nu*scrh;
>     dN  = fN/dfN; 
>     
>     N -= dN;
>     k++;
269,283c255
<   Ns  = x0+1.0;
<   Ns1 = x0;
<    
<   while(fabs(Ns-Ns1) >= 1.0e-5){
<     Ns = Ns1;
<     a = (1.0-sqrt(STS_NU))/(1.0+sqrt(STS_NU));
<     b = pow(a,2.0*Ns);
<     c = (1.0-b)/(1.0+b);
<     Ns1 = Ns + (dta - dtr*Ns/(2.0*sqrt(STS_NU))*c)
<               /(dtr/(2.0*sqrt(STS_NU))*(c-2.0*Ns*b*log(a)*(1.0+c)/(1.0+b)));
<     n += 1;
<     if (n == 128){
<       print1 ("! STS_FindRoot: max number of iterations exceeded");
<       QUIT_PLUTO(1);
<     }
---
>     if (fabs(dN) < 1.e-5) return N;
285c257,260
<   return(Ns);
---
> 
>   print ("! STS_FindRoot: too many iterations\n");
>   QUIT_PLUTO(1);
>   return -1.0;
diff Src/tools.c ../old/tools.c
13c13
<   \date   Sept 1, 2014
---
>   \date   July 15, 2017
17a18
>    
21,22c22,23
<  * Cheeck whether the array \c u contains Not-a-Number
<  *  (NaN)
---
>  * Check whether the array \c u contains Not-a-Number
>  *  (NaN). QUIT if true.
39a41,149
> void GetNeighbourRanks (Grid *grid, int **nranks)
> /*! 
>  *  Find the ranks of neighbour processors direction by direction.
>  *  Store them in the array \c nrank[dir][s] where \c dir is the
>  *  direction and <tt> s = 0,1 </tt> stands for the left (0) or right
>  *  (1) processor.
>  *  If a processor touches the physical boundary that is not periodic,
>  *  the corresponding neighbour rank will be set to -1.
>  *
>  * \param [in]   grid    pointer to an array of grid structures.
>  * \param [out]  nranks  an array of integers containing the ranks of
>  *                       the neighbouring processors
>  *********************************************************************** */
> {
> #ifdef PARALLEL
>   int dir, coords[3], rnk;
>   int lbound, rbound;
>   MPI_Comm cartcomm;
>   
> 
>   AL_Get_cart_comm(SZ, &cartcomm);
>     
> /* ------------------------------------------------------------
>     Neighbour exists when there's no physical boundary, or
>     when PERIODIC or SHEARING boundary conditions are imposed
>     along that direction.
>    ------------------------------------------------------------ */
> 
>   for (dir = 0; dir < 3;dir++){
> 
>   /* -- Obtain local processor coordinates -- */
> 
>     D_EXPAND(coords[IDIR] = grid->rank_coord[IDIR];  ,
>              coords[JDIR] = grid->rank_coord[JDIR];  ,
>              coords[KDIR] = grid->rank_coord[KDIR];)
> 
>     nranks[dir][0] = nranks[dir][1] = -1;
> 
>     lbound = grid->lbound[dir];
>     if (lbound == 0 || lbound == PERIODIC || lbound == SHEARING){
>       coords[dir] = grid->rank_coord[dir] - 1;
>       MPI_Cart_rank(cartcomm, coords, &rnk);
>       nranks[dir][0] = rnk;
>     }
> 
>     rbound = grid->rbound[dir];
> 
>     if (rbound == 0 || rbound == PERIODIC || rbound == SHEARING){
>       coords[dir] = grid->rank_coord[dir] + 1;
>       MPI_Cart_rank(cartcomm, coords, &rnk);
>       nranks[dir][1] = rnk;
>     }
>   }
>   
>   MPI_Barrier(MPI_COMM_WORLD);
> 
>   return;
> #endif  /* PARALLEL */
> }
> 
> #if !(defined CHOMBO) && (defined GNUPLOT)
> /* ********************************************************************* */
> void GnuplotSetting(Grid *grid)
> /*
>  * Set-up a gnuplot script containing grid info, variable names, etc...
>  *********************************************************************** */
> {
>   int  nv, count;
>   char *var_name[256];
>   FILE *fp;
> 
> /* --------------------------------------------------------
>    0. Allocate memory for an array of strings containing
>       the names of the variables.
>       Get the variable names being written to disk.
>    -------------------------------------------------------- */
> 
>   for (nv = 0; nv < 255; nv++) var_name[nv] = ARRAY_1D(32,char);
>   count = GetOutputVarNames(FLT_OUTPUT, var_name);
> 
> /* --------------------------------------------------------
>    1. Open file and write relevant info.
>    -------------------------------------------------------- */
> 
>   fp = fopen("pluto.gp","w");
> 
>   fprintf (fp, "# ***********************************************************\n");
>   fprintf (fp, "# Initialize grid quantities for reading binary data with \n");
>   fprintf (fp, "# Gnuplot.\n");
>   fprintf (fp, "# ***********************************************************\n");
> 
>   fprintf (fp, "nx = %d\n", grid->np_int_glob[IDIR]);
>   fprintf (fp, "ny = %d\n", grid->np_int_glob[JDIR]);
>   fprintf (fp, "nz = %d\n", grid->np_int_glob[KDIR]);
>   
>   fprintf (fp, "xbeg = %f; xend = %f\n", grid->xbeg_glob[IDIR],
>                                          grid->xend_glob[IDIR]);
> 
>   fprintf (fp, "ybeg = %f; yend = %f\n", grid->xbeg_glob[JDIR],
>                                          grid->xend_glob[JDIR]);
>     
>   fprintf (fp, "\n# -- Set variables indices --\n\n");
>   for (nv = 0; nv < count; nv++) fprintf (fp, "%s = %d\n",var_name[nv], nv);
>   
>   fclose(fp);
> }
> #endif
> 
> /* ********************************************************************* */
51c161
< void MakeState (State_1D *state)
---
> void MakeState (Sweep *sweep)
53,54c163
<  *
<  * Allocate memory areas for arrays inside the state
---
>  * Allocate memory areas for arrays inside the sweep
56,57d164
<  *
<  *
60,78c167,169
<   state->v       = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->vp      = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->vm      = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->up      = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->um      = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->flux    = ARRAY_2D(NMAX_POINT, NVAR, double);
< 
<   state->src     = ARRAY_2D(NMAX_POINT, NVAR, double);
< 
<   state->visc_flux = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->visc_src  = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->tc_flux   = ARRAY_2D(NMAX_POINT, NVAR, double);    
<   state->res_flux  = ARRAY_2D(NMAX_POINT, NVAR, double); 
< 
<   state->rhs     = ARRAY_2D(NMAX_POINT, NVAR, double);
<   state->press   = ARRAY_1D(NMAX_POINT, double);
<   state->bn      = ARRAY_1D(NMAX_POINT, double);
<   state->SL      = ARRAY_1D(NMAX_POINT, double);
<   state->SR      = ARRAY_1D(NMAX_POINT, double);
---
>   State *stateC = &(sweep->stateC);
>   State *stateL = &(sweep->stateL);
>   State *stateR = &(sweep->stateR);
80c171,173
< /* -- eigenvectors -- */
---
> /* --------------------------------------------------------
>    0. Allocate memory for sweep structure members
>    -------------------------------------------------------- */
82,101c175,185
<   state->Lp      = ARRAY_3D(NMAX_POINT, NFLX, NFLX, double);
<   state->Rp      = ARRAY_3D(NMAX_POINT, NFLX, NFLX, double);
<   state->lambda  = ARRAY_2D(NMAX_POINT, NFLX, double);
<   state->lmax    = ARRAY_1D(NVAR, double);
< 
<   state->a2   = ARRAY_1D(NMAX_POINT, double);
<   state->h    = ARRAY_1D(NMAX_POINT, double);
< 
< /*  state->dwlim   = ARRAY_2D(NMAX_POINT, NVAR, double);*/
< 
<   state->flag    = ARRAY_1D(NMAX_POINT, unsigned char);
< 
< /* --------------------------------------
<      define shortcut pointers for
<      left and right values with respect
<      to the cell center
<    -------------------------------------- */
<    
<   state->vL = state->vp;
<   state->vR = state->vm + 1;
---
>   sweep->vn      = ARRAY_2D(NMAX_POINT, NVAR, double);
>   sweep->flux    = ARRAY_2D(NMAX_POINT, NVAR, double);
>   sweep->src     = ARRAY_2D(NMAX_POINT, NVAR, double);
> 
>   sweep->tc_flux = ARRAY_2D(NMAX_POINT, NVAR, double);    
> 
>   sweep->rhs     = ARRAY_2D(NMAX_POINT, NVAR, double);
>   sweep->press   = ARRAY_1D(NMAX_POINT, double);
>   sweep->bn      = ARRAY_1D(NMAX_POINT, double);
>   sweep->SL      = ARRAY_1D(NMAX_POINT, double);
>   sweep->SR      = ARRAY_1D(NMAX_POINT, double);
103,104c187
<   state->uL = state->up;
<   state->uR = state->um + 1;
---
> /* -- eigenvectors -- */
106,110c189,199
<   #if (TIME_STEPPING == HANCOCK) || (TIME_STEPPING == CHARACTERISTIC_TRACING)
<    state->vh = ARRAY_2D(NMAX_POINT, NVAR, double);
<   #else
<    state->vh = state->v;
<   #endif
---
>   sweep->lmax    = ARRAY_1D(NVAR, double);
>   sweep->flag    = ARRAY_1D(NMAX_POINT, unsigned char);
> 
> /* --------------------------------------------------------
>    1. Allocate memory for state structure members.
>       C/L stand, respectively, for cell center and
>       left interfaces (i+1/2, L).
>    -------------------------------------------------------- */
>   
>   StateStructAllocate (stateC);
>   StateStructAllocate (stateL);
111a201,229
> /* --------------------------------------------------------
>    2. Allocate memory for the right state structure.
>       Note that we add an offset +1 in order to access
>       stateR->v[i-1].
>    -------------------------------------------------------- */
>   
>   stateR->v      = ARRAY_2D(NMAX_POINT, NVAR, double)+1;
>   stateR->u      = ARRAY_2D(NMAX_POINT, NVAR, double)+1;
>   stateR->flux   = ARRAY_2D(NMAX_POINT, NVAR, double)+1;
>   stateR->lambda = ARRAY_2D(NMAX_POINT, NVAR, double)+1;
>   stateR->prs    = ARRAY_1D(NMAX_POINT, double)+1;
>   stateR->a2     = ARRAY_1D(NMAX_POINT, double)+1;
>   stateR->cw     = ARRAY_1D(NMAX_POINT, double)+1;
>   stateR->h      = ARRAY_1D(NMAX_POINT, double)+1;
>   stateR->Lp     = ARRAY_3D(NMAX_POINT, NFLX, NFLX, double)+1;
>   stateR->Rp     = ARRAY_3D(NMAX_POINT , NFLX, NFLX, double)+1;
>   stateR->J      = stateL->J;
>   stateR->cCR    = stateL->cCR;
>   stateR->Fcr    = ARRAY_2D(NMAX_POINT, 4, double) + 1; 
>   stateR->fluxCR = ARRAY_2D(NMAX_POINT, NVAR, double)+1;
>   stateR->Bbck   = stateL->Bbck;
> 
> //  StateStructAllocate (stateR);
> 
> /* -- Allocate shared memory areas -- */
> 
> //  stateL->Bbck = ARRAY_2D(NMAX_POINT, 3, double);
> //  stateR->Bbck = stateL->Bbck;
> //  stateC->Bbck = ARRAY_2D(NMAX_POINT, 3, double);
131a250,272
> void StateStructAllocate (State *p)
> /*!
>  * Allocate memory areas for arrays inside the State structure.
>  *********************************************************************** */
> {
>   p->v      = ARRAY_2D(NMAX_POINT, NVAR, double);
>   p->u      = ARRAY_2D(NMAX_POINT, NVAR, double);
>   p->flux   = ARRAY_2D(NMAX_POINT, NVAR, double);
>   p->lambda = ARRAY_2D(NMAX_POINT, NVAR, double);
>   p->prs    = ARRAY_1D(NMAX_POINT, double);
>   p->a2     = ARRAY_1D(NMAX_POINT, double);
>   p->cw     = ARRAY_1D(NMAX_POINT, double);
>   p->h      = ARRAY_1D(NMAX_POINT, double);
>   p->Lp     = ARRAY_3D(NMAX_POINT, NFLX, NFLX, double);
>   p->Rp     = ARRAY_3D(NMAX_POINT, NFLX, NFLX, double);
>   p->J      = ARRAY_2D(NMAX_POINT, 3, double);
>   p->cCR    = ARRAY_2D(NMAX_POINT, 3, double);
>   p->Fcr    = ARRAY_2D(NMAX_POINT, 4, double); 
>   p->fluxCR = ARRAY_2D(NMAX_POINT, NVAR, double);
>   p->Bbck   = ARRAY_2D(NMAX_POINT, 3, double);
> }
> 
> /* ********************************************************************* */
161d301
< 
163c303
<     print ("%12.6e  ", a[ip][nv]);
---
>     print ("%8.3e  ", a[ip][nv]);
168a309,329
> void ShowMatrix(double **A, int n, double eps)
> /*!
>  * Make a nice printing of a 2D matrix \c A[0..n-1][0..n-1]
>  * Entries with values below eps will display "0.0"
>  *
>  *
>  *********************************************************************** */
> {
>   int k1,k2;
> 
>   print ("----------------------------------------------------------------\n");
>   for (k1 = 0; k1 < n; k1++){
>     for (k2 = 0; k2 < n; k2++){
>       print ("%12.3e   ", fabs(A[k1][k2]) > eps ? A[k1][k2]:0.0);
>     }
>     print ("\n");
>   }
>   print ("----------------------------------------------------------------\n");
> }
> 
> /* ********************************************************************* */
171c332
<  * Print the component of the array \c a at grid index \c ip  
---
>  * Print the first n components of the vector v[]  
182c343
< void ShowMatrix(double **A, int n, double eps)
---
> int StringArrayIndex (char *str_arr[], int size, char *str)
184,186c345,346
<  * Make a nice printing of a 2D matrix \c A[0..n-1][0..n-1]
<  * Entries with values below eps will display "0.0"
<  *
---
>  *  Find the index of an array of strings whose value matches the
>  *  input string \c *str.
187a348,350
>  * \param [in]  str_arr  the array of strings
>  * \param [in]  size     the size of the array
>  * \param [in]  str      the string to search for
190c353
<   int k1,k2;
---
>   int i;
192,195c355,426
<   print ("----------------------------------------------------------------\n");
<   for (k1 = 0; k1 < n; k1++){
<     for (k2 = 0; k2 < n; k2++){
<       print ("%12.3e   ", fabs(A[k1][k2]) > eps ? A[k1][k2]:0.0);
---
>   for (i = 0; i < size; i++){
>     if (!strcmp(str_arr[i],str)) return i;
>   }
>   return -1;
> 
> }
> 
> /* ********************************************************************* */
> void SymmetryCheck (Data_Arr V, int where, RBox *box)
> /*!
>  * Check if vectors preserve symmetry / antisymmetry properties
>  * at a symmetry axis (r = 0 for cylindrical or theta = 0 for spherical)
>  * Vectors can only be cell-centered (meaning that *all* components must
>  * be cell-centered) or face-centered (meaning that *all* components must
>  * be face-centered).
>  * Staggered fields are not allowed.
>  *********************************************************************** */
> {
>   int i,j,k;
>   int ip, jp;
>   double ***Vx1 = V[0];
>   double ***Vx2 = V[1];
>   double ***Vx3 = V[2];
>   double scrh1, scrh2, scrh3;
> 
>   BOX_LOOP(box,k,j,i){
> 
>     #if GEOMETRY == CYLINDRICAL
>     if (i >= IBEG) continue;
> 
>     if (where == X1FACE){   /* Vector is defined at radial i+1/2 interfaces */
>       ip = 2*IBEG-i-2;
>       jp = j;
> 
>     /* At IBEG-1/2 interface, check that there're no Inf or Nan values */
>       if (i == IBEG-1){
>         if (   fabs(Vx1[k][j][i]) > 1.e8 || Vx1[k][j][i] != Vx1[k][j][i]
>             || fabs(Vx2[k][j][i]) > 1.e8 || Vx2[k][j][i] != Vx2[k][j][i]
>             || fabs(Vx3[k][j][i]) > 1.e8 || Vx3[k][j][i] != Vx3[k][j][i]){
>           print ("! SymmetryCheck(): invalid value\n");
>           QUIT_PLUTO(1);
>         }
>         continue; /* Skip this point since i = ip would be the same */
>       }
>     }else {                /* Vector is defined at center or j+1/2 interface */
>       ip = 2*IBEG-i-1;
>       jp = j;
>     }
>     scrh1 = fabs(Vx1[k][j][i] + Vx1[k][jp][ip]); /* r-component:   antisymmetric */
>     scrh2 = fabs(Vx2[k][j][i] - Vx2[k][jp][ip]); /* z-component:   symmetric */
>     scrh3 = fabs(Vx3[k][j][i] + Vx3[k][jp][ip]); /* phi-component: antisymmetric */
>     #elif GEOMETRY == SPHERICAL
>     if (j >= JBEG) continue;
> 
>     if (where == X2FACE){  /* Vector is define at meridional j+1/2 interfaces */
>       ip = i;
>       jp = 2*JBEG-j-2;
>     /* At JBEG-1/2 interface, check that there're no Inf or Nan values */
>       if (j == JBEG-1){
>         if (   fabs(Vx1[k][j][i]) > 1.e8 || Vx1[k][j][i] != Vx1[k][j][i]
>             || fabs(Vx2[k][j][i]) > 1.e8 || Vx2[k][j][i] != Vx2[k][j][i]
>             || fabs(Vx3[k][j][i]) > 1.e8 || Vx3[k][j][i] != Vx3[k][j][i]){
>           print ("! SymmetryCheck(): invalid value\n");
>           print ("! V = (%12.6e, %12.6e, %12.6e\n",
>                     Vx1[k][j][i],Vx2[k][j][i],Vx3[k][j][i]);
>           QUIT_PLUTO(1);
>         }
>         continue; /* Skip this point since j = jp would be the same */
>       }
>     }else {             /* Vector is define at center or radial interfaces */     
>       ip = i;
>       jp = 2*JBEG-j-1;
197c428,458
<     printf ("\n");
---
>     scrh1 = fabs(Vx1[k][j][i] - Vx1[k][jp][ip]); /* r-component:   symmetric */
>     scrh2 = fabs(Vx2[k][j][i] + Vx2[k][jp][ip]); /* th-component:  antisymmetric */
>     scrh3 = fabs(Vx3[k][j][i] + Vx3[k][jp][ip]); /* phi-component: antisymmetric */
>     #endif
> 
> 
>     if (scrh1 > 1.e-14 || scrh2 > 1.e-14 || scrh3 > 1.e-14){
>       #if GEOMETRY == CYLINDRICAL
>       if (where == X1FACE){
>         print ("! SymmetryCheck(): Vector not symmetric at i+1/2,j = %d+1/2, %d\n",i,j);
>       }else if (where == X2FACE){
>         print ("! SymmetryCheck(): Vector not symmetric at i,j+1/2 = %d, %d+1/2\n",i,j);
>       }else {
>         print ("! SymmetryCheck(): Vector not symmetric at i,j = %d, %d\n",i,j);
>       }
>       #elif GEOMETRY == SPHERICAL
>       if (where == X1FACE){
>         print ("! SymmetryCheck(): Vector not symmetric at i+1/2,j = %d+1/2, %d\n",i,j);
>       }else if (where == X2FACE){
>         print ("! SymmetryCheck(): Vector not symmetric at i,j+1/2 = %d, %d+1/2\n",i,j);
>       }else{
>         print ("! SymmetryCheck(): Vector not symmetric at i,j = %d, %d\n",i,j);
>       }
>       #endif
>       print ("! i, j, k = %d, %d, %d --> V = (%12.6e, %12.6e, %12.6e) \n",
>                    i,j,k,Vx1[k][j][i],Vx2[k][j][i], Vx3[k][j][i]);
>       print ("! ip,jp,k = %d, %d, %d --> V = (%12.6e, %12.6e, %12.6e)\n",
>                  ip,jp,k, Vx1[k][jp][ip],Vx2[k][jp][ip], Vx3[k][jp][ip]);
> 
>       QUIT_PLUTO(1);
>     } 
199d459
<   print ("----------------------------------------------------------------\n");
231c491
<   printf ("Trace ------> %f ,  %d\n", xx, ++ik);
---
>   print ("Trace ------> %f ,  %d\n", xx, ++ik);
249c509
<   static Grid *grid1, *grid2, *grid3;
---
>   static Grid *grid_copy;
256,258c516
<     grid1 = grid + IDIR;
<     grid2 = grid + JDIR;
<     grid3 = grid + KDIR;
---
>     grid_copy = grid;
278,280c536,538
<     x1 = grid1->x[ii];  ,
<     x2 = grid2->x[jj];  ,
<     x3 = grid3->x[kk];
---
>     x1 = grid_copy->x[IDIR][ii];  ,
>     x2 = grid_copy->x[JDIR][jj];  ,
>     x3 = grid_copy->x[KDIR][kk];
284,285c542
<     print ("zone [x1(%d) = %f]",
<             ii, grid1->x[ii]);  ,
---
>     print ("  [i = %d], [x1 = %f]", ii, x1);  ,
287,294c544,547
<     print ("zone [x1(%d) = %f, x2(%d) = %f]",
<             ii, grid1->x[ii], 
<             jj, grid2->x[jj]);  ,
< 
<     print ("zone [x1(%d) = %f, x2(%d) = %f, x3(%d) = %f]",
<             ii, grid1->x[ii], 
<             jj, grid2->x[jj],
<             kk, grid3->x[kk]);
---
>     print ("  [i,j = %d, %d], [x1,x2 =  %f, %f]", ii, jj, x1, x2);  ,
> 
>     print ("  [i,j,k = %d, %d, %d], [x1,x2,x3 = %f, %f, %f]", ii, jj, kk,
>             x1, x2, x3);
298,409c551,552
<    print (", Level = %d\n", grid1->level);
<    return;
<   #endif
<   #ifdef PARALLEL
<    print (", proc %d\n", prank);
<    return;
<   #else
<    print ("\n");
<    return;
<   #endif  
< }
< 
< /* /////////////////////////////////////////////////////////////////////
<     The next set of functions provides basic functionalities to
<      
<      - set the log file
<      - formatted output to the log file through the print() and print1()
<        functions
<    ///////////////////////////////////////////////////////////////////// */
< 
< static char log_file_name[512];
< 
< /* ********************************************************************* */
< int SetLogFile(char *output_dir, Cmd_Line *cmd)
< /*!
<  * Set the name of the log file and open in write or append mode
<  * depending on whether restart is enabled or not.
<  *
<  * \param [in] output_dir  the name of the output directory
<  * \param [in] cmd         pointer to cmd line option structure.
<  *                           
<  *********************************************************************** */
< {
< #if PRINT_TO_FILE == YES
<   FILE *fl;
< 
< /* ------------------------------------------------
<     All processors set log file name
<    ------------------------------------------------ */
< 
<   sprintf (log_file_name, "%s/pluto.log",output_dir);    
< 
< /* ------------------------------------------------
<     Proc. #0 opens log file for writing if 
<     -restart or -h5restart have not been given.
<     Otherwise, open in append mode.
<    ------------------------------------------------ */
<   
<   if (prank == 0){
<     if (cmd->restart == NO && cmd->h5restart == NO){
<       fl = fopen(log_file_name,"w");
<     }else{
<       fl = fopen(log_file_name,"aw");
<     } 
< 
<   /* -- check that we have a valid directory name -- */
< 
<     if (fl == NULL){
<       printf ("! SetLogFile: pluto.log cannot be written.\n");
<       QUIT_PLUTO(1);
<     }
<     fprintf(fl,"\n");
<     fclose(fl);
<   }
< #endif
< }
< 
< #ifndef CH_SPACEDIM
< /* ********************************************************************* */
< void print (const char *fmt, ...)
< /*!
<  * Define print function for the static grid version
<  * of PLUTO. The Chombo version is defined in Chombo/amrPLUTO.cpp
<  *
<  *********************************************************************** */
< {
<   FILE *fl;
< 
<   va_list args;
<   va_start(args, fmt);
< 
< #if PRINT_TO_FILE == YES
<   fl = fopen(log_file_name,"a");
<   vfprintf(fl, fmt, args);
<   fclose (fl);
< #else
<   vprintf(fmt, args);
< #endif
< 
<   va_end(args);
< }
< /* ********************************************************************* */
< void print1 (const char *fmt, ...)
< /*!
<  *
<  *   Define print1 function
<  *
<  *********************************************************************** */
< {
<   FILE *fl;
< 
<   va_list args;
<   va_start(args, fmt);
< 
<   #if PRINT_TO_FILE == YES
<    if (prank == 0){
<      fl = fopen(log_file_name,"a");
<      vfprintf(fl,fmt, args);
<      fclose(fl);
<    }
<   #else
<    if (prank == 0) vprintf(fmt, args);
---
>   print (", Level = %d\n", grid_copy->level);
>   return;
411c554
<   va_end(args);
---
>   print ("\n");
413d555
< #endif
442a585
> 
diff Src/userdef_output.c ../old/userdef_output.c
21c21
< void ChangeDumpVar ()
---
> void ChangeOutputVar ()
28a29,34
> #ifdef PARTICLES
>   //SetOutputVar ("energy",PARTICLES_FLT_OUTPUT, NO);
> //  SetOutputVar ("x1",    PARTICLES_FLT_OUTPUT, NO);
>   //SetOutputVar ("vx1",   PARTICLES_FLT_OUTPUT, NO);
> #endif
> 
diff Src/userdef_output.dt.c ../old/userdef_output.dt.c
21c21
<   static State_1D state;
---
>   static Sweep sweep;
24,25c24,25
<   if (state.rhs == NULL) {
<     MakeState(&state);
---
>   if (sweep.rhs == NULL) {
>     MakeState(&sweep);
53c53
<       for (nv = NVAR; nv--;  ) state.v[i][nv] = d->Vc[nv][k][j][i];
---
>       for (nv = NVAR; nv--;  ) sweep.v[i][nv] = d->Vc[nv][k][j][i];
55,57c55,57
<     States (&state, IBEG-1, IEND+1, grid);
<     HLL_Solver(&state, IBEG-1, IEND, cmax, grid);
<     TC_Flux (T, &state, dcoeff, IBEG-1, IEND, grid);  
---
>     States (&sweep, IBEG-1, IEND+1, grid);
>     HLL_Solver(&sweep, IBEG-1, IEND, cmax, grid);
>     TC_Flux (T, &sweep, dcoeff, IBEG-1, IEND, grid);  
76c76
<       for (nv = NVAR; nv--;  ) state.v[j][nv] = d->Vc[nv][k][j][i];
---
>       for (nv = NVAR; nv--;  ) sweep.v[j][nv] = d->Vc[nv][k][j][i];
78,80c78,80
<     States (&state, JBEG-1, JEND+1, grid);
<     HLL_Solver(&state, JBEG-1, JEND, cmax, grid);
<     TC_Flux (T, &state, dcoeff, JBEG-1, JEND, grid);  
---
>     States (&sweep, JBEG-1, JEND+1, grid);
>     HLL_Solver(&sweep, JBEG-1, JEND, cmax, grid);
>     TC_Flux (T, &sweep, dcoeff, JBEG-1, JEND, grid);  
diff Src/userdef_output.shock_tracking.c ../old/userdef_output.shock_tracking.c
24c24
< void ChangeDumpVar ()
---
> void ChangeOutputVar ()
diff Src/var_names.c ../old/var_names.c
0a1,16
> /* ///////////////////////////////////////////////////////////////////// */
> /*! 
>   \file  
>   \brief Set default variable names. 
> 
>   Create a correspondence between the index of a variable (e.g., RHO, VX1,
>   etc...) and its actual name (e.g., "rho", "vx1", etc...).
>   These names are used when writing the output file descriptor (.flt, .dbl,
>   etc...) only if the variable has been enabled for writing
>   (output->dump_var[nv]= YES/NO).
> 
>   \authors A. Mignone (mignone@ph.unito.it)\n
> 
>   \date    Nov 14, 2017
> */
> /* ///////////////////////////////////////////////////////////////////// */
7,10d22
<  *  PURPOSE
<  *
<  *    Set file names for I/O
<  *
25c37
< #if HAVE_ENERGY
---
>   #if HAVE_ENERGY
27c39
< #endif
---
>   #endif
29,33c41,45
< #if PHYSICS == MHD || PHYSICS == RMHD
<   EXPAND(output->var_name[BX1] = "bx1";  ,
<          output->var_name[BX2] = "bx2";  ,
<          output->var_name[BX3] = "bx3";)
< #endif
---
>   #if PHYSICS == MHD || PHYSICS == RMHD
>   EXPAND(output->var_name[BX1] = "Bx1";  ,
>          output->var_name[BX2] = "Bx2";  ,
>          output->var_name[BX3] = "Bx3";)
>   #endif
34a47,53
>   #if PHYSICS == RMHD && RESISTIVITY != NO
>   EXPAND(output->var_name[EX1] = "Ex1";  ,
>          output->var_name[EX2] = "Ex2";  ,
>          output->var_name[EX3] = "Ex3";)
>   output->var_name[CRG] = "qg";
>   #endif
> 
38a58,60
>   #ifdef PHI_GLM
>   output->var_name[PHI_GLM] = "phi_glm";
>   #endif
45c67
< #if DUST == YES
---
> #if DUST_FLUID == YES
73c95
<                         S_EXPAND("X_SI","X_SI I", "X_SIII", "X_SIV", "X_SV")
---
>                         S_EXPAND("X_SI","X_SII", "X_SIII", "X_SIV", "X_SV")
86c108
<   }  
---
>   } 
87a110,112
> #elif COOLING == KROME
>   /* kromenames are reaction network dependent and are defined in cooling.h */
>     NIONS_LOOP(nv) output->var_name[nv] = kromenames[nv-NFLX];
diff Src/vec_pot_diff.c ../old/vec_pot_diff.c
37a38,44
> 
>   For staggered MHD the convention is the following:
>   
>   - <tt> Ax1[i,j,k] --> Ax1(0++) </tt> \f$= A_{x_1, i, j+\HALF, k+\HALF}\f$
>   - <tt> Ax2[i,j,k] --> Ax2(+0+) </tt> \f$= A_{x_2, i+\HALF, j, k+\HALF}\f$
>   - <tt> Ax3[i,j,k] --> Ax3(++0) </tt> \f$= A_{x_3, i+\HALF, j+\HALF, k}\f$
> 
64,66c71,72
<   \authors A. Mignone (mignone@ph.unito.it)\n
<            P. Tzeferacos (petros.tzeferacos@ph.unito.it)
<   \date   Sep 24, 2012
---
>   \last change  D. Mukherjee, A. Mignone (dipanjan.mukherjee@unito.it) \n
>   \date         May 21, 2018
73c79
< void VectorPotentialDiff (double *b, int i, int j, int k, Grid *grid)
---
> void VectorPotentialDiff (double *b, Data *d, int i, int j, int k, Grid *grid)
78,79c84,86
<  * \param [out] b  array of magnetic field starting at 0, 
<  *               \f$ B_{x_1} = b[0]\,, B_{x_2} = b[1]\,, B_{x_3} = b[2] \f$
---
>  * \param [out]    b  array of magnetic field starting at 0, 
>  *                 \f$ B_{x_1} = b[0]\,, B_{x_2} = b[1]\,, B_{x_3} = b[2] \f$
>  * \param [in/out] Data structure                
87,90c94,98
<   int    l_convert;
<   double dx1, x1, x1p, x1m;
<   double dx2, x2, x2p, x2m;
<   double dx3, x3, x3p, x3m;
---
>   double dx1,dx2,dx3;
>   double x1,x2,x3;
>   double x1p,x2p,x3p;
>   double x1m,x2m,x3m;
>   double x1f, x2f, x3f; 
92,141d99
<   double us_p[256], us_m[256];
<   double r_2;
<   double x1f, x2f, x3f; /* point at which magnetic field is desired */
< 
<   x1 = grid[IDIR].x[i]; 
<   x2 = grid[JDIR].x[j]; 
<   x3 = grid[KDIR].x[k]; 
< 
<   dx1 = grid[IDIR].dx[i];
<   dx2 = grid[JDIR].dx[j];
<   dx3 = grid[KDIR].dx[k];
< 
<   #ifdef STAGGERED_MHD   
<    x1p = grid[IDIR].xr[i]; x1m = grid[IDIR].xl[i];
<    x2p = grid[JDIR].xr[j]; x2m = grid[JDIR].xl[j];
<    x3p = grid[KDIR].xr[k]; x3m = grid[KDIR].xl[k];
<    x1f = grid[IDIR].xr[i]; /* for staggered MHD, we compute magnetic */
<    x2f = grid[JDIR].xr[j]; /* field at face centers                  */
<    x3f = grid[KDIR].xr[k];
<    
<   #else
<    x1p = grid[IDIR].x[i] + dx1; x1m = grid[IDIR].x[i] - dx1;
<    x2p = grid[JDIR].x[j] + dx2; x2m = grid[JDIR].x[j] - dx2;
<    x3p = grid[KDIR].x[k] + dx3; x3m = grid[KDIR].x[k] - dx3;
<    x1f = grid[IDIR].x[i]; /* for cell-centered MHD, we compute magnetic */
<    x2f = grid[JDIR].x[j]; /* field at cell-centers                      */
<    x3f = grid[KDIR].x[k];
<    
<    dx1 = 2.*grid[IDIR].dx[i]; /* redefine the spacing between cell-centers */
<    dx2 = 2.*grid[JDIR].dx[j];
<    dx3 = 2.*grid[KDIR].dx[k];
<   #endif 
<   
<   #if GEOMETRY == CARTESIAN
< 
<   /* ---- assign bx at i_f, j, k  ---- */
< 
<    Init (us_p, x1f, x2p, x3);
<    Init (us_m, x1f, x2m, x3);
< 
<    bx = (us_p[AX3] - us_m[AX3])/dx2;
< 
<    #if DIMENSIONS == 3
<     Init (us_p, x1f, x2, x3p);
<     Init (us_m, x1f, x2, x3m);
< 
<     bx -= (us_p[AX2] - us_m[AX2])/dx3;
<    #endif
< 
<   /* ---- assign by at i, j_f, k  ---- */
143,167c101,118
<    Init (us_p, x1p, x2f, x3);
<    Init (us_m, x1m, x2f, x3);
< 
<    by = -(us_p[AX3] - us_m[AX3])/dx1;
< 
<    #if DIMENSIONS == 3
<     Init (us_p, x1, x2f, x3p);
<     Init (us_m, x1, x2f, x3m);
<    
<     by += (us_p[AX1] - us_m[AX1])/dx3;
<    #endif
< 
<   /* ---- assign bz at i, j, k_f  ---- */
< 
<    Init (us_p, x1p, x2, x3f);
<    Init (us_m, x1m, x2, x3f);
<    
<    bz = (us_p[AX2] - us_m[AX2])/dx1;
< 
<    Init (us_p, x1, x2p, x3f);
<    Init (us_m, x1, x2m, x3f);
<    
<    bz -= (us_p[AX1] - us_m[AX1])/dx2;
< 
<    b[0] = bx; b[1] = by; b[2] = bz;
---
>   double ***A1, ***A2, ***A3;
>   double A1_x2p, A1_x3p;
>   double A1_x2m, A1_x3m;
>   double A2_x1p, A2_x3p;
>   double A2_x1m, A2_x3m;
>   double A3_x1p, A3_x2p;
>   double A3_x1m, A3_x2m;
> 
>   x1  = grid->x[IDIR][i]; 
>   x2  = grid->x[JDIR][j]; 
>   x3  = grid->x[KDIR][k];
>  
>   dx1 = grid->dx[IDIR][i];
>   dx2 = grid->dx[JDIR][j];
>   dx3 = grid->dx[KDIR][k];
> 
> /* -- Define pointers to A[] -- */
>   A1 = d->Ax1;  A2 = d->Ax2; A3 = d->Ax3; 
169,183d119
<   #elif GEOMETRY == CYLINDRICAL  /* -- only 2D -- */
<   
<   /* ---- assign br at i_f, j, k  ---- */
<   
<    Init (us_p, x1f, x2p, x3);
<    Init (us_m, x1f, x2m, x3);
<    
<    br = - (us_p[AX3] - us_m[AX3])/dx2;
< 
<   /* ---- assign bz at i, j_f, k  ---- */
<      
<    Init (us_p, x1p, x2f, x3);
<    Init (us_m, x1m, x2f, x3);
<    
<    bz = (x1p*us_p[AX3] - x1m*us_m[AX3])/(x1*dx1);
185c121,126
<   /* ---- assign bphi at i, j, k ---- */  /* -- Only non STAG-- */
---
>   x1p = grid->xr[IDIR][i]; x1m = grid->xl[IDIR][i];
>   x2p = grid->xr[JDIR][j]; x2m = grid->xl[JDIR][j];
>   x3p = grid->xr[KDIR][k]; x3m = grid->xl[KDIR][k];
>   x1f = grid->xr[IDIR][i]; /* for staggered MHD, we compute magnetic */
>   x2f = grid->xr[JDIR][j]; /* field at face centers                  */
>   x3f = grid->xr[KDIR][k];
187,205c128,129
<    #ifdef STAGGERED_MHD   
<     bphi = 0.0;
<    #else
<     Init (us_p, x1, x2p, x3);
<     Init (us_m, x1, x2m, x3);
<     
<     bphi = (us_p[AX1] - us_m[AX1])/dx2;
<     
<     Init (us_p, x1p, x2, x3);
<     Init (us_m, x1m, x2, x3);
<     
<     bphi -= (us_p[AX2] - us_m[AX2])/dx1;
<    #endif
<    
<    b[0] = br; b[1] = bz; b[2] = bphi;
< 
<   #elif GEOMETRY == POLAR 
< 
<    /* ---- assign br at i_f, j, k ---- */
---
>   A1_x2p = A1[k][j][i]; A1_x2m = A1[k][j-1][i];
>   A1_x3p = A1[k][j][i]; A1_x3m = A1[k-1][j][i];
207,210c131,132
<    Init (us_p, x1f, x2p, x3);
<    Init (us_m, x1f, x2m, x3);
<    
<    br = (us_p[AX3] - us_m[AX3])/(x1f*dx2);
---
>   A2_x1p = A2[k][j][i]; A2_x1m = A2[k][j][i-1];
>   A2_x3p = A2[k][j][i]; A2_x3m = A2[k-1][j][i];
212,243c134,135
<    Init (us_p, x1f, x2, x3p);
<    Init (us_m, x1f, x2, x3m);
< 
<    br -= (us_p[AX2] - us_m[AX2])/dx3;
< 
<   /* ---- assign bphi at i, j_f, k  ---- */
< 
<    Init (us_p, x1p, x2f, x3);
<    Init (us_m, x1m, x2f, x3);
< 
<    bphi = -(us_p[AX3] - us_m[AX3])/dx1;
<      
<    #if DIMENSIONS == 3
<     Init (us_p, x1, x2f, x3p);
<     Init (us_m, x1, x2f, x3m);
< 
<     bphi += (us_p[AX1] - us_m[AX1])/dx3;
<    #endif
< 
<   /* ---- assign bz at i, j, k_f  ---- */
< 
<    Init (us_p, x1p, x2, x3f);
<    Init (us_m, x1m, x2, x3f);
< 
<    bz = (x1p*us_p[AX2] - x1m*us_m[AX2])/(x1*dx1);
< 
<    Init (us_p, x1, x2p, x3f);
<    Init (us_m, x1, x2m, x3f);
< 
<    bz -= (us_p[AX1] - us_m[AX1])/(x1*dx2);
< 
<    b[0] = br; b[1] = bphi; b[2] = bz;
---
>   A3_x1p = A3[k][j][i]; A3_x1m = A3[k][j][i-1];
>   A3_x2p = A3[k][j][i]; A3_x2m = A3[k][j-1][i];
245d136
<   #elif GEOMETRY == SPHERICAL
247d137
<    /* ---- assign br at i_f, j, k ---- */
249,250c139,146
<    Init (us_p, x1f, x2p, x3);
<    Init (us_m, x1f, x2m, x3);
---
> #if GEOMETRY == CARTESIAN
> /* -----------------------------------------------------
>     Compute Bx
>     - For cell centred: Bx = dely Az   - delz Ay
>     - For Staggered:    Bx =  (Az[++0] - Az[+-0])/dy
>                              -(Ay[+0+] - Ay[+0-])/dz
>    ----------------------------------------------------- */
>   bx = (A3_x2p - A3_x2m)/dx2;
252,256c148,161
<    br = (sin(x2p)*us_p[AX3] - sin(x2m)*us_m[AX3])/(x1f*(cos(x2m) - cos(x2p)));
< 
<    #if DIMENSIONS == 3
<     Init (us_p, x1f, x2, x3p);
<     Init (us_m, x1f, x2, x3m);
---
>   #if DIMENSIONS == 3
>   bx -= (A2_x3p - A2_x3m)/dx3;
>   #endif 
>   
> /* -----------------------------------------------------
>     Compute By
>     - For cell centred: By = -delx Az  + delz Ax
>     - For Staggered:    By = -(Az[++0] - Az[-+0])/dx
>                              +(Ax[0++] - Ax[0+-])/dz
>    ----------------------------------------------------- */
>   by = -(A3_x1p - A3_x1m)/dx1;
>   #if DIMENSIONS == 3
>   by += (A1_x3p - A1_x3m)/dx3;
>   #endif 
258,261c163,213
<     br -= 1.0/(x1f*sin(x2)*dx3)*(us_p[AX2] - us_m[AX2]);
<    #endif
<    
<   /* ---- assign btheta at i, j_f, k  ---- */
---
> /* -----------------------------------------------------
>     Compute Bz
>     - For cell centred: Bz =  delx Ay  - dely Ax
>     - For Staggered:    Bz =  (Ay[+0+] - Ay[-0+])/dx
>                              -(Ax[0++] - Ax[0-+])/dy
>    ----------------------------------------------------- */
>   bz =  (A2_x1p - A2_x1m)/dx1 - (A1_x2p - A1_x2m)/dx2;
> 
>   b[0] = bx; b[1] = by; b[2] = bz;
> 
> #elif GEOMETRY == CYLINDRICAL  /* -- only 2D -- */
> /* -----------------------------------------------------
>    Compute Br   
>    - For cell centred: Br = - delz Aphi
> 
>    Convention for  Components: 
>    - Field:      (Br, Bz)
>    - Potential:  (Ar, Az, -Aphi) = (AX1, AX2, AX3)
> 
>    Note that A3 = -A_\phi since in cylindrical
>    coordinates (R,z) are not right-handed
>    -----------------------------------------------------*/
>    br = -(A3_x2p   - A3_x2m)/dx2;
> 
> /* ----------------------------------------------------------
>    Compute Bz  
>    - For cell centred: Bz = 1/r delr (r*Aphi) 
>    - For Staggered:    Bz = (r+ A3[0,0] - r- A3[0,-])/(r dr)
>   -----------------------------------------------------------*/
>   bz =  (x1p*A3_x1p   - x1m*A3_x1m)/(x1*dx1);
> 
> /* ----------------------------------------------
>     Compute Bphi  
>     - For cell centred: Bphi = delz Ar - delr Az  
>     - For Staggered:    Bphi = 0.
>    ----------------------------------------------*/
>   bphi = 0.0;
>   b[0] = br; b[1] = bz; b[2] = bphi;
> 
> #elif GEOMETRY == POLAR 
> /* ------------------------------------------------------------
>    Compute Br 
>      Convention for  Components: 
>     - Field:      (Br, Bphi, Bz)
>     - Potential:  (Ar, Aphi, Az)
>  
>     - For cell centred: Br =  1/r delphi Az - delz Aphi
>     - For Staggered:    Br =  (Az[++0]   - Az[+-0]  )/(r dphi)
>                              -(Aphi[+0+] - Aphi[+0-])/dz
>   --------------------------------------------------------------*/
>   br = (A3_x2p - A3_x2m)/(x1f*dx2);
263,264c215,217
<    Init (us_p, x1p, x2f, x3);
<    Init (us_m, x1m, x2f, x3);
---
>   #if DIMENSIONS == 3
>   br -= (A2_x3p   - A2_x3m)/dx3;
>   #endif 
266c219,225
<    bth = - (x1p*us_p[AX3] - x1m*us_m[AX3])/(x1*dx1);
---
> /* -----------------------------------------------------------
>     Compute Bphi 
>     - For cell centred: Bphi = - delr Az + delz Ar
>     - For Staggered:    Bphi =  (Az[++0] - Az[-+0])/dr 
> 		               -(Ar[0++] - Ar[0+-])/dz
>   -------------------------------------------------------------*/
>   bphi = -(A3_x1p   - A3_x1m)/dx1;
268,273c227,229
<    #if DIMENSIONS == 3
<     Init (us_p, x1, x2f, x3p);
<     Init (us_m, x1, x2f, x3m);
<    
<     bth += (us_p[AX1] - us_m[AX1])/(x1*sin(x2f)*dx3);
<    #endif
---
>   #if DIMENSIONS == 3
>   bphi += (A1_x3p - A1_x3m)/dx3;
>   #endif 
275c231,255
<   /* ---- assign bphi at i, j, k_f  ---- */
---
> /* ------------------------------------------------------------------
>    Compute Bz  
>     - For cell centred: Bz = 1/r( delr (r Aphi) - delphi Ar)
>     - For Staggered:    Bz = ((r+) Aphi[+0+] - (r-) Aphi[+0-])/(r dr)
> 		            -(     Ar[0++]   -      Ar[0-+]  )/(r dphi) 
>    --------------------------------------------------------------------*/
>   bz =  (x1p*A2_x1p - x1m*A2_x1m)/(x1*dx1) - (A1_x2p - A1_x2m)/(x1*dx2);
>   b[0] = br; b[1] = bphi; b[2] = bz;
> 
> #elif GEOMETRY == SPHERICAL
> /* ----------------------------------------------------------------------
>     Compute Br 
>      Convention for  Components: 
>     - Field:      (Br, Bth, Bphi)
>     - Potential:  (Ar, Ath, Aphi)
> 
>     - For cell centred: 
>       Br = 1/(r sin_theta) (deltheta (sin_theta Aphi) - delphi Ath)
> 	 =  (1/(-r del_costheta) (sin_theta Aphi)) 
>            -1/(r sin_theta) delphi Ath 
>     - For Staggered: 
>       Br = (sin(th+)Aphi[++0] - sin(th-)Aphi[+-0])/(r (cos(th-)-cos(th+)) ) 
>           -(Ath[+0+] - Ath[-0+])/(r sin(th) dphi)  
>    -------------------------------------------------------------------------*/
>   br = (A3_x2p*sin(x2p)   - A3_x2m*sin(x2m))/(x1f*(cos(x2m)-cos(x2p)));
277c257,259
<    bphi = 0.0;
---
>   #if DIMENSIONS == 3
>   br -= 1./(x1p*sin(x2)*dx3)*(A2_x3p - A2_x3m);
>   #endif 
279,280c261,269
<    Init (us_p, x1p, x2, x3f);
<    Init (us_m, x1m, x2, x3f);
---
> /* -------------------------------------------------------------
>    Compute Bth
>     - For cell centred: 
>       Bth = 1/(r) (-delr (r Aphi) +1/(sin_theta) delphi Ar)
>     - For Staggered: 
>       Bth = -( (r+) Aphi[++0] - (r-) Aphi[-+0])/(r dr)
>             +(Ar[0++] - Ar[0+-])/(r+ sin(th) dphi)
>    -------------------------------------------------------------*/
>   bth = -(x1p*A3_x1p   - x1m*A3_x1m)/(x1*dx1);
282,285c271,273
<    bphi = (x1p*us_p[AX2] - x1m*us_m[AX2])/(x1*dx1);
<  
<    Init (us_p, x1, x2p, x3f);
<    Init (us_m, x1, x2m, x3f);
---
>   #if DIMENSIONS == 3
>   bth += 1./(x1p*sin(x2)*dx3)*(A1_x3p   - A1_x3m);
>   #endif 
287,289c275,284
<    bphi -= (us_p[AX1] - us_m[AX1])/(x1*dx2);
<    
<    b[0] = br; b[1] = bth; b[2] = bphi;
---
> /* -------------------------------------------------------------
>     Compute Bphi
>     - For cell centred: 
>       Bphi = 1/(r) (delr (r Ath) - deltheta Ar)
>     - For Staggered:
>       Bphi = ((r+) Ath[+0+] - (r-) Ath[-0+])/(r dr)
>             -(Ar[0++] - Ar[0-+])/(r dth) 
>   -------------------------------------------------------------*/
>   bphi = (x1p*A2_x1p - x1m*A2_x1m)/(x1*dx1) - (A1_x2p     - A1_x2m)/(x1*dx2);
>   b[0] = br; b[1] = bth; b[2] = bphi;
291c286
<   #endif
---
> #endif /* GEOMETRY == SPHERICAL */
294a290
> 
Only in ../old: vec_pot_diff_old.c
diff Src/vec_pot_update.c ../old/vec_pot_update.c
43c43
<   \param [in] state   pointer to State_1D structure containing the 
---
>   \param [in] sweep   pointer to Sweep structure containing the 
81c81
<                             const State_1D *state, const Grid *grid)
---
>                             const Sweep *sweep, const Grid *grid)
180c180
<     f = state->flux;
---
>     f = sweep->flux;
diff Src/write_data.c ../old/write_data.c
4c4
<   \brief Main output driver.
---
>   \brief Main output driver for fluid variables.
21c21
<   \date   Aug 24, 2012
---
>   \date   Sep 30, 2016
52c52
<             Increment the file number and initialize units
---
>    0. Increment the file number and initialize units
57c57
<   print1 ("> Writing file #%d (%s) to disk...", output->nfile, output->ext);
---
>   print ("> Writing file #%d (%s) to disk...", output->nfile, output->ext);
59,62c59,62
<   #ifdef PARALLEL
<    MPI_Barrier (MPI_COMM_WORLD);
<    if (prank == 0) time(&tbeg);
<   #endif
---
> #ifdef PARALLEL
>   MPI_Barrier (MPI_COMM_WORLD);
>   if (prank == 0) time(&tbeg);
> #endif
68c68
<             Get user var if necessary 
---
>    1. Compute user-defined output arrays if necessary 
77c77,89
<             Select the output type 
---
>    2. With FARGO, we can output total or residual velocity 
>    -------------------------------------------------------- */
> 
> #if (defined FARGO)
>   #if  (FARGO_OUTPUT_VTOT == YES)
>   if (FARGO_TotalVelocityIsSet() == 0) FARGO_AddVelocity (d,grid); 
>   #else 
>   if (FARGO_TotalVelocityIsSet() == 1) FARGO_SubtractVelocity (d,grid); 
>   #endif
> #endif
> 
> /* --------------------------------------------------------
>    3. Select the output type 
107a120,121
>  
>       FileDelete (filename);  /* Avoid partial fill of pre-existing files */
110c124
<        fbin = OpenBinaryFile (filename, 0, "w");
---
>        fbin = FileOpen (filename, 0, "w");
129c143
<          fbin = OpenBinaryFile (filename, sz, "w");
---
>          fbin = FileOpen (filename, sz, "w");
132c146
<         WriteBinaryArray (Vpt, dsize, sz, fbin, output->stag_var[nv]);
---
>         FileWriteData (Vpt, dsize, sz, fbin, output->stag_var[nv]);
135c149
<          CloseBinaryFile(fbin, sz);
---
>          FileClose(fbin, sz);
139c153
<        CloseBinaryFile(fbin, sz);
---
>        FileClose(fbin, sz);
148a163
>         FileDelete (filename);  /* Avoid partial fill of pre-existing files */
162,164c177,179
<         fbin = OpenBinaryFile (filename, sz, "w");
<         WriteBinaryArray (Vpt, dsize, sz, fbin, output->stag_var[nv]);
<         CloseBinaryFile (fbin, sz);
---
>         fbin = FileOpen (filename, sz, "w");
>         FileWriteData (Vpt, dsize, sz, fbin, output->stag_var[nv]);
>         FileClose (fbin, sz);
179c194,195
<       fbin = OpenBinaryFile (filename, SZ_float, "w");
---
>       FileDelete (filename);  /* Avoid partial fill of pre-existing files */
>       fbin = FileOpen (filename, SZ_float, "w");
182d197
< /*        Vpt = (void *)(Convert_dbl2flt(output->V[nv],0))[0][0];  */
185c200
<         WriteBinaryArray (Vpt, sizeof(float), SZ_float, fbin, 
---
>         FileWriteData (Vpt, sizeof(float), SZ_float, fbin, 
188c203
<       CloseBinaryFile(fbin, SZ_float);
---
>       FileClose(fbin, SZ_float);
199,200c214,215
<         fbin = OpenBinaryFile (filename, SZ_float, "w");
< /*        Vpt = (void *)(Convert_dbl2flt(output->V[nv],0))[0][0];   */
---
>         FileDelete (filename);  /* Avoid partial fill of pre-existing files */
>         fbin = FileOpen (filename, SZ_float, "w");
203c218
<         WriteBinaryArray (Vpt, sizeof(float), SZ_float, fbin, 
---
>         FileWriteData (Vpt, sizeof(float), SZ_float, fbin, 
205c220
<         CloseBinaryFile (fbin, SZ_float);
---
>         FileClose (fbin, SZ_float);
219c234
<      print1 ("! WriteData: HDF5 library not available\n");
---
>      print ("! WriteData: HDF5 library not available\n");
239c254,255
<       fbin  = OpenBinaryFile(filename, SZ_Float_Vect, "w");
---
>       FileDelete (filename);  /* Avoid partial fill of pre-existing files */
>       fbin  = FileOpen(filename, SZ_Float_Vect, "w");
249,250c265,266
<        CloseBinaryFile(fbin, SZ_Float_Vect);
<        fbin  = OpenBinaryFile(filename, SZ_float, "w");
---
>        FileClose(fbin, SZ_Float_Vect);
>        fbin  = FileOpen(filename, SZ_float, "w");
259c275
<       CloseBinaryFile(fbin, SZ_float);
---
>       FileClose(fbin, SZ_float);
272c288
<           print1 ("! WriteData: unknown vector type in VTK output\n"); 
---
>           print ("! WriteData: unknown vector type in VTK output\n"); 
276c292,293
<         fbin = OpenBinaryFile(filename, SZ_Float_Vect, "w");
---
>         FileDelete (filename);  /* Avoid partial fill of pre-existing files */
>         fbin = FileOpen(filename, SZ_Float_Vect, "w");
280c297
<         CloseBinaryFile(fbin, SZ_Float_Vect);
---
>         FileClose(fbin, SZ_Float_Vect);
287c304,305
<         fbin = OpenBinaryFile(filename, SZ_Float_Vect, "w");
---
>         FileDelete (filename);  /* Avoid partial fill of pre-existing files */
>         fbin = FileOpen(filename, SZ_Float_Vect, "w");
289,294c307,312
<         #ifdef PARALLEL
<          offset = AL_Get_offset(SZ_Float_Vect);
<          CloseBinaryFile(fbin, SZ_Float_Vect);
<          fbin  = OpenBinaryFile(filename, SZ_float, "w");
<          AL_Set_offset(SZ_float, offset);
<         #endif
---
>       #ifdef PARALLEL
>         offset = AL_Get_offset(SZ_Float_Vect);
>         FileClose(fbin, SZ_Float_Vect);
>         fbin  = FileOpen(filename, SZ_float, "w");
>         AL_Set_offset(SZ_float, offset);
>       #endif
297c315
<         CloseBinaryFile (fbin, SZ_float);
---
>         FileClose (fbin, SZ_float);
341c359
<      print1 ("! PNG library not available\n");
---
>      print ("! PNG library not available\n");
344,345c362
< 
<   }
---
>   }       
348c365
<            Update corresponding ".out" file
---
>    3. Update corresponding ".out" file
381,550c398,402
<   #ifdef PARALLEL
<    MPI_Barrier (MPI_COMM_WORLD);
<    if (prank == 0){
<      time(&tend);
<      print1 (" [%5.2f sec]",difftime(tend,tbeg));
<    }
<   #endif
<   print1 ("\n");
< 
< }
< 
< #ifdef USE_ASYNC_IO
< static float ****Vflt;
< static int perf_output[16] = {0};
< /* ********************************************************************* */
< void Async_BegWriteData (const Data *d, Output *output, Grid *grid)
< /*!
<  *
<  * PURPOSE:
<  *
<  *  Write data to disk using binary format and asyncronous MPI functions: 
<  *   dbl, flt.
<  *
<  *  \author CINECA (g.muscianisi@cineca.it), A. Mignone (mignone@ph.unito.it)
<  *
<  *********************************************************************** */
< {
<   int  i, j, k, nv;
<   size_t dsize;
<   char   filename[128];
<   static int last_computed_var = -1;
< 
< /* -----------------------------------------------------------
<                 Increment the file number 
<    ----------------------------------------------------------- */
< 
<   output->nfile++;
<   print1 ("> Writing file #%d (%s) to disk [async: beg]...\n",
<              output->nfile, output->ext);
< 
< /* --------------------------------------------------------
<             Get user var if necessary 
<    -------------------------------------------------------- */
< 
<   if (last_computed_var != g_stepNumber && d->Vuser != NULL) {
<     ComputeUserVar (d, grid);
<     last_computed_var = g_stepNumber;
<   }
< 
< /* ------------------------------------------------------
<                   DBL/FLT OUTPUTS 
<    ------------------------------------------------------ */
< 
<   if (output->type == DBL_OUTPUT) {
<     dsize = sizeof(double);
<     perf_output[DBL_OUTPUT] = 1;
<   } else{
<     dsize = sizeof(float);
<     perf_output[FLT_OUTPUT] = 1;
<   }    
<   
<   sprintf (filename, "%s/data.%04d.%s", output->dir, output->nfile,
<                                         output->ext);
< 
<   if (dsize == sizeof(double)) AL_File_open(filename, SZ);
<   if (dsize == sizeof(float))  AL_File_open(filename, SZ_float);
< 
<   if (dsize == sizeof(double)){
<     AL_Write_array_begin ((void *)output->V[0][0][0], SZ, output->stag_var,
<                                   output->dump_var, output->nvar);
<   }
<   if (dsize == sizeof(float)){
<     if (Vflt == NULL){
<       Vflt = ARRAY_4D(output->nvar, NX3_TOT, NX2_TOT, NX1_TOT, float);
<     }
<   
<     /* similar to CONVERT_TO_FLOAT, with swap_endian disabled */
<     
<     for (nv = 0; nv < output->nvar; nv++){
<       DOM_LOOP(k,j,i) Vflt[nv][k][j][i] = (float)output->V[nv][k][j][i]; 
<     }
<     AL_Write_array_begin ((void *)Vflt[0][0][0], SZ_float, 
<                           output->stag_var, output->dump_var, output->nvar);
<   }
< }
< 
< /* ********************************************************************* */
< void Async_EndWriteData (Runtime *ini)
< /*!
<  *
<  * PURPOSE:
<  *
<  *  Writing data completition using binary format and asyncronous 
<  *  MPI functions: dbl, flt.
<  *
<  * \author CINECA (g.muscianisi@cineca.it), A. Mignone (mignone@ph.unito.it)
<  *
<  *********************************************************************** */
< {
<   char filename[128], sline[512];
<   FILE *fout;
<   int nv;
<   Output *output;
< 
<   if (perf_output[DBL_OUTPUT]){   /* asynchronous dbl output */
<     output = ini->output + 0;
<     print1 ("> Writing file #%d (%s) to disk [async: end]...\n",
<              output->nfile, output->ext);
<     AL_Write_array_end((void *)output->V[0][0][0], SZ);
<     AL_File_close(SZ);
< 
<     sprintf (filename,"%s.out",output->ext);   
<     if (prank == 0) {
<       if (output->nfile == 0) {
<         fout = fopen (filename, "w");
<       }else{
<         fout = fopen (filename, "r+");
<         for (nv = 0; nv < output->nfile; nv++) fgets (sline, 512, fout);
<            fseek (fout, ftell(fout), SEEK_SET);
<       }
< 
<       /* -- write a multi-column file -- */
<       fprintf (fout, "%d %8.3e %8.3e %ld ", output->nfile, g_time, 
<                                             g_dt, g_stepNumber);
<       fprintf (fout,"single_file ");
< 
<       if (IsLittleEndian()) fprintf (fout, "little ");
<       else                 fprintf (fout, "big ");
< 
<       for (nv = 0; nv < output->nvar; nv++) {
<          if (output->dump_var[nv]) fprintf (fout, "%s ", output->var_name[nv]);
<       }
<       fprintf (fout,"\n");
<       fclose (fout);
<     }
<     perf_output[DBL_OUTPUT] = 0;
<   }
<   if (perf_output[FLT_OUTPUT]){  /* asynchronous flt output */
<     output =ini->output + 1;
<     print1 ("> Writing file #%d (%s) to disk [async: end]...\n",
<              output->nfile, output->ext);
< 
<     AL_Write_array_end((void *)Vflt[0][0][0], SZ_float);
<     AL_File_close(SZ_float);
< 
<     sprintf (filename,"%s.out",output->ext);  
<     if (prank == 0) {
<       if (output->nfile == 0) {
<         fout = fopen (filename, "w");
<       }else {
<         fout = fopen (filename, "r+");
<         for (nv = 0; nv < output->nfile; nv++) fgets (sline, 512, fout);
<            fseek (fout, ftell(fout), SEEK_SET);
<       }
< 
<       /* -- write a multi-column file -- */
<       fprintf (fout, "%d %8.3e %8.3e %ld ", 
<                 output->nfile, g_time, g_dt, g_stepNumber);
<       fprintf (fout,"single_file ");
< 
<       if (IsLittleEndian()) fprintf (fout, "little ");
<       else                  fprintf (fout, "big ");
< 
<       for (nv = 0; nv < output->nvar; nv++) {
<          if (output->dump_var[nv]) fprintf (fout, "%s ", output->var_name[nv]);
<       }
<       fprintf (fout,"\n");
<       fclose (fout);
<     }
<     perf_output[FLT_OUTPUT] = 0;
---
> #ifdef PARALLEL
>   MPI_Barrier (MPI_COMM_WORLD);
>   if (prank == 0){
>     time(&tend);
>     print (" [%5.2f sec]",difftime(tend,tbeg));
551a404,405
> #endif
>   print ("\n");
554d407
< #endif /* USE_ASYNC_IO */
diff Src/write_img.c ../old/write_img.c
172c172
<    print1 ("! PPM output disabled in 1-D\n");
---
>    print ("! PPM output disabled in 1-D\n");
181,183c181,183
<   fl = OpenBinaryFile ("tmp_file.out", SZ_float, "w");
<   WriteBinaryArray ((Convert_dbl2flt(Vdbl,1.0, 0))[0][0], dsize, SZ_float, fl, -1); 
<   CloseBinaryFile (fl, SZ_float);
---
>   fl = FileOpen ("tmp_file.out", SZ_float, "w");
>   FileWriteData ((Convert_dbl2flt(Vdbl,1.0, 0))[0][0], dsize, SZ_float, fl, -1); 
>   FileClose (fl, SZ_float);
194,196c194,196
<   nx = grid[IDIR].gend + 1 - grid[IDIR].nghost;
<   ny = grid[JDIR].gend + 1 - grid[JDIR].nghost;
<   nz = grid[KDIR].gend + 1 - grid[KDIR].nghost;
---
>   nx = grid->gend[IDIR] + 1 - grid->nghost[IDIR];
>   ny = grid->gend[JDIR] + 1 - grid->nghost[JDIR];
>   nz = grid->gend[KDIR] + 1 - grid->nghost[KDIR];
331,333c331,333
<   for (i = 0; i < grid[dir].np_tot_glob; i++){
<     xl = grid[dir].x_glob[i] - 0.5*grid[dir].dx_glob[i];
<     xr = grid[dir].x_glob[i] + 0.5*grid[dir].dx_glob[i];
---
>   for (i = 0; i < grid->np_tot_glob[dir]; i++){
>     xl = grid->x_glob[dir][i] - 0.5*grid->dx_glob[dir][i];
>     xr = grid->x_glob[dir][i] + 0.5*grid->dx_glob[dir][i];
diff Src/write_tab.c ../old/write_tab.c
25c25
<   \date   June 27, 2014
---
>   \date   April 6, 2017
45c45
<    print1 ("! WriteTabArray: tab output not supported in parallel\n");
---
>    print ("! WriteTabArray: tab output not supported in parallel\n");
50c50
<    print1 ("! WriteTabArray: tab output not supported in 3D\n");
---
>    print ("! WriteTabArray: tab output not supported in 3D\n");
62c62
<       fprintf (fout, "%f %f ", grid[IDIR].x[i], grid[JDIR].x[j]);
---
>       fprintf (fout, "%f %f ", grid->x[IDIR][i], grid->x[JDIR][j]);
diff Src/write_vtk.c ../old/write_vtk.c
6,7c6
<   Collection of basic functions to write VTK files using the
<   simple legacy format.
---
>   Collection of basic functions to write legacy VTK binary files.
11,17c10,16
<   -# File version and identifier
<   -# Header consisting of a string
<   -# File format
<   -# Dataset structure: describes the gwometry and topology of the 
<      dataset. 
<   -# Dataset attributes. This section is used to write the actual binary
<      data as a vector or scalar data.
---
>   1. File version and identifier
>   2. Header, consisting of a string
>   3. File format
>   4. Dataset structure: describes the geometry and topology of the 
>      dataset 
>   5. Dataset attributes. This section is used to write the actual binary
>      data as a vector or scalar data
21c20
<   VTK file are usually written following big endian order. 
---
>   VTK file are written following big endian order. 
28,29c27,30
<   "RECTILINEAR_GRIDS" whereas for polar/spherical we employ 
<   "STRUCTURED_GRID" to provide a convenient mapping to a cartesian mesh.\n
---
>   <em>rectilinear grid</em> (\c VTK_RECTILINEAR_GRIDS) whereas for
>   polar/spherical we employ <em>structured grid</em> (\c VTK_STRUCTURED_GRID)
>   to provide a convenient mapping to a cartesian mesh.
> 
48c49
<   \date   Aug 17, 2015
---
>   \date   Nov 11, 2015
53,54c54,55
< #define RECTILINEAR_GRID    14
< #define STRUCTURED_GRID     35
---
> #define VTK_RECTILINEAR_GRID    14
> #define VTK_STRUCTURED_GRID     35
58c59
<     #define VTK_FORMAT  RECTILINEAR_GRID
---
>     #define VTK_FORMAT  VTK_RECTILINEAR_GRID
60c61
<     #define VTK_FORMAT  STRUCTURED_GRID
---
>     #define VTK_FORMAT  VTK_STRUCTURED_GRID
96,97c97
<  *
<  *
---
>  * 
104,150c104,124
<   int    i, j, k;
<   int    nx1, nx2, nx3;
<   char   header[1024];
<   float  x1, x2, x3;
<   static float  ***node_coord, *xnode, *ynode, *znode;
< 
< /* ------------------------------------------------
<           get global dimensions
<    ------------------------------------------------ */
< 
<   nx1 = grid[IDIR].gend + 1 - grid[IDIR].nghost;
<   nx2 = grid[JDIR].gend + 1 - grid[JDIR].nghost;
<   nx3 = grid[KDIR].gend + 1 - grid[KDIR].nghost;
< 
< /* -------------------------------------------------------------
<      Allocate memory and define node coordinates only once.
<    ------------------------------------------------------------- */
< 
<   if (node_coord == NULL){
<     node_coord = ARRAY_3D(nx2 + JOFFSET, nx1 + IOFFSET, 3, float);
< 
<     #if VTK_FORMAT == RECTILINEAR_GRID
<      xnode = ARRAY_1D(nx1 + IOFFSET, float);
<      ynode = ARRAY_1D(nx2 + JOFFSET, float);
<      znode = ARRAY_1D(nx3 + KOFFSET, float);
< 
<      for (i = 0; i < nx1 + IOFFSET; i++){
<        x1 = (float)(grid[IDIR].xl_glob[i+IBEG]);
<        if (IsLittleEndian()) SWAP_VAR(x1);
<        xnode[i] = x1;
<      }
<      for (j = 0; j < nx2 + JOFFSET; j++){
<        x2 = (float)(grid[JDIR].xl_glob[j+JBEG]);
<        if (IsLittleEndian()) SWAP_VAR(x2);
<        ynode[j] = x2;
<      }
<      for (k = 0; k < nx3 + KOFFSET; k++){
<        x3 = (float)(grid[KDIR].xl_glob[k+KBEG]);
<        if (IsLittleEndian()) SWAP_VAR(x3);
<        #if DIMENSIONS == 2
<         znode[k] = 0.0;
<        #else
<         znode[k] = x3;
<        #endif
<      }
<     #endif
<   }
---
>   long int i, j, k;
>   long int nx1, nx2, nx3;
>   char     header[1024];
>   float    x1, x2, x3;
>   static float  **node_coord, *xnode, *ynode, *znode;
> 
> /* -- Get global domain sizes -- */
> 
>   nx1 = grid->gend[IDIR] + 1 - grid->nghost[IDIR];
>   nx2 = grid->gend[JDIR] + 1 - grid->nghost[JDIR];
>   nx3 = grid->gend[KDIR] + 1 - grid->nghost[KDIR];
> 
> /* -------------------------------------------
>    1. File version and identifier
>    ------------------------------------------- */
> 
>   sprintf(header,"# vtk DataFile Version 2.0\n");
> 
> /* -------------------------------------------
>    2. Header
>    ------------------------------------------- */
152,157d125
< /* ----------------------------------------------------------
<     Part I, II, III: 
<     Write file header on string "header" 
<    ---------------------------------------------------------- */
< 
<   sprintf(header,"# vtk DataFile Version 2.0\n"); 
158a127,131
> 
> /* ------------------------------------------
>    3. File format
>    ------------------------------------------ */
> 
160,164d132
<   #if VTK_FORMAT == RECTILINEAR_GRID
<    sprintf(header+strlen(header),"DATASET %s\n","RECTILINEAR_GRID");
<   #elif VTK_FORMAT == STRUCTURED_GRID
<    sprintf(header+strlen(header),"DATASET %s\n","STRUCTURED_GRID");
<   #endif
166c134,142
<   VTK_HEADER_WRITE_STRING(header);
---
> /* ------------------------------------------
>    4. Dataset structure
>    ------------------------------------------ */
> 
> #if VTK_FORMAT == VTK_RECTILINEAR_GRID
>   sprintf(header+strlen(header),"DATASET %s\n","RECTILINEAR_GRID");
>  #elif VTK_FORMAT == VTK_STRUCTURED_GRID
>   sprintf(header+strlen(header),"DATASET %s\n","STRUCTURED_GRID");
> #endif
168c144
<   /* -- generate time info -- */
---
>   VTK_HEADER_WRITE_STRING(header);
170,177c146
<   #if VTK_TIME_INFO == YES
<    sprintf (header,"FIELD FieldData 1\n");
<    sprintf (header+strlen(header),"TIME 1 1 double\n");
<    double tt=g_time;
<    if (IsLittleEndian()) SWAP_VAR(tt);
<    VTK_HEADER_WRITE_STRING(header);
<    VTK_HEADER_WRITE_DBLARR(&tt, 1);
<    VTK_HEADER_WRITE_STRING("\n");
---
> /* -- Generate time info (VisIt reader only) -- */
179c148,156
<   #endif /* VTK_TIME_INFO */
---
> #if VTK_TIME_INFO == YES
>   sprintf (header,"FIELD FieldData 1\n");
>   sprintf (header+strlen(header),"TIME 1 1 double\n");
>   double tt=g_time;
>   if (IsLittleEndian()) SWAP_VAR(tt);
>   VTK_HEADER_WRITE_STRING(header);
>   VTK_HEADER_WRITE_DBLARR(&tt, 1);
>   VTK_HEADER_WRITE_STRING("\n");
> #endif /* VTK_TIME_INFO */
185c162
< #if VTK_FORMAT == RECTILINEAR_GRID
---
> #if VTK_FORMAT == VTK_RECTILINEAR_GRID
187c164,192
<   /* -- reset header string and keep going -- */
---
> /* -- Allocate memory and define node coordinates only once -- */
> 
>   if (xnode == NULL){
>     xnode = ARRAY_1D(nx1 + IOFFSET, float);
>     ynode = ARRAY_1D(nx2 + JOFFSET, float);
>     znode = ARRAY_1D(nx3 + KOFFSET, float);
> 
>     for (i = 0; i < nx1 + IOFFSET; i++){
>       x1 = (float)(grid->xl_glob[IDIR][i+IBEG]);
>       if (IsLittleEndian()) SWAP_VAR(x1);
>       xnode[i] = x1;
>     }
>     for (j = 0; j < nx2 + JOFFSET; j++){
>       x2 = (float)(grid->xl_glob[JDIR][j+JBEG]);
>       if (IsLittleEndian()) SWAP_VAR(x2);
>       ynode[j] = x2;
>     }
>     for (k = 0; k < nx3 + KOFFSET; k++){
>       x3 = (float)(grid->xl_glob[KDIR][k+KBEG]);
>       if (IsLittleEndian()) SWAP_VAR(x3);
>       #if DIMENSIONS == 2
>        znode[k] = 0.0;
>       #else
>        znode[k] = x3;
>       #endif
>     }
>   }
> 
> /* -- Write rectilinear grid information -- */
201,202c206
<    sprintf (header,"\nCELL_DATA %d\n", nx1*nx2*nx3);
<    VTK_HEADER_WRITE_STRING (header);
---
> #elif VTK_FORMAT == VTK_STRUCTURED_GRID
204c208,210
< #elif VTK_FORMAT == STRUCTURED_GRID
---
> /* -- Allocate memory and define node_coord -- */
> 
>   if (node_coord == NULL) node_coord = ARRAY_2D(nx1 + IOFFSET, 3, float);
209,211c215
< /* ---------------------------------------------------------------
<     Part IV: (structured) grid information 
<    --------------------------------------------------------------- */
---
> /* -- Write structured grid information -- */
215c219
<     for (j = 0; j < nx2 + JOFFSET; j++){ 
---
>   for (j = 0; j < nx2 + JOFFSET; j++){ 
217,219c221,223
<       D_EXPAND(x1 = grid[IDIR].xl_glob[IBEG + i];  ,
<                x2 = grid[JDIR].xl_glob[JBEG + j];  ,
<                x3 = grid[KDIR].xl_glob[KBEG + k];)
---
>       D_EXPAND(x1 = grid->xl_glob[IDIR][IBEG + i];  ,
>                x2 = grid->xl_glob[JDIR][JBEG + j];  ,
>                x3 = grid->xl_glob[KDIR][KBEG + k];)
221,238c225,241
<       #if (GEOMETRY == CARTESIAN) || (GEOMETRY == CYLINDRICAL)
<        node_coord[j][i][0] = x1;
<        node_coord[j][i][1] = x2;
<        node_coord[j][i][2] = x3;
<       #elif GEOMETRY == POLAR
<        node_coord[j][i][0] = x1*cos(x2);
<        node_coord[j][i][1] = x1*sin(x2);
<        node_coord[j][i][2] = x3;
<       #elif GEOMETRY == SPHERICAL
<        #if DIMENSIONS == 2
<         node_coord[j][i][0] = x1*sin(x2);
<         node_coord[j][i][1] = x1*cos(x2);
<         node_coord[j][i][2] = 0.0;
<        #elif DIMENSIONS == 3
<         node_coord[j][i][0] = x1*sin(x2)*cos(x3);
<         node_coord[j][i][1] = x1*sin(x2)*sin(x3);
<         node_coord[j][i][2] = x1*cos(x2);
<        #endif
---
>     #if (GEOMETRY == CARTESIAN) || (GEOMETRY == CYLINDRICAL)
>       node_coord[i][0] = x1;
>       node_coord[i][1] = x2;
>       node_coord[i][2] = x3;
>     #elif GEOMETRY == POLAR
>       node_coord[i][0] = x1*cos(x2);
>       node_coord[i][1] = x1*sin(x2);
>       node_coord[i][2] = x3;
>     #elif GEOMETRY == SPHERICAL
>       #if DIMENSIONS == 2
>       node_coord[i][0] = x1*sin(x2);
>       node_coord[i][1] = x1*cos(x2);
>       node_coord[i][2] = 0.0;
>       #elif DIMENSIONS == 3
>       node_coord[i][0] = x1*sin(x2)*cos(x3);
>       node_coord[i][1] = x1*sin(x2)*sin(x3);
>       node_coord[i][2] = x1*cos(x2);
239a243
>     #endif
242,244c246,248
<         SWAP_VAR(node_coord[j][i][0]);
<         SWAP_VAR(node_coord[j][i][1]);
<         SWAP_VAR(node_coord[j][i][2]);
---
>         SWAP_VAR(node_coord[i][0]);
>         SWAP_VAR(node_coord[i][1]);
>         SWAP_VAR(node_coord[i][2]);
246,248c250,259
<     }}
<     VTK_HEADER_WRITE_FLTARR(node_coord[0][0],3*(nx1+IOFFSET)*(nx2+JOFFSET));
<   }
---
>     }
>     VTK_HEADER_WRITE_FLTARR(node_coord[0],3*(nx1+IOFFSET));
>   }}
> 
> #endif
> 
> /* -----------------------------------------------------
>    5. Dataset attributes [will continue by later calls
>       to WriteVTK_Vector() or WriteVTK_Scalar()...]
>    ----------------------------------------------------- */
251c262
<   VTK_HEADER_WRITE_STRING(header);
---
>   VTK_HEADER_WRITE_STRING (header);
253d263
< #endif
255,256c265,266
< #undef STRUCTERED_GRID    
< #undef RECTILINEAR_GRID  
---
> #undef VTK_STRUCTERED_GRID    
> #undef VTK_RECTILINEAR_GRID  
313,315c323,325
<       D_EXPAND(v[0] = V[0][k][j][i]; x1 = grid[IDIR].x[i]; ,
<                v[1] = V[1][k][j][i]; x2 = grid[JDIR].x[j]; ,
<                v[2] = V[2][k][j][i]; x3 = grid[KDIR].x[k];)
---
>       D_EXPAND(v[0] = V[0][k][j][i]; x1 = grid->x[IDIR][i]; ,
>                v[1] = V[1][k][j][i]; x2 = grid->x[JDIR][j]; ,
>                v[2] = V[2][k][j][i]; x3 = grid->x[KDIR][k];)
336c346
<     WriteBinaryArray (vect3D[0][0], sizeof(Float_Vect), SZ_Float_Vect, fvtk, -1);
---
>     FileWriteData (vect3D[0][0], sizeof(Float_Vect), SZ_Float_Vect, fvtk, -1);
358c368
<   sprintf (header,"%sLOOKUP_TABLE default\n",header);
---
>   sprintf (header+strlen(header),"LOOKUP_TABLE default\n");
362a373
>    MPI_Barrier (MPI_COMM_WORLD);
368c379
<   WriteBinaryArray (Vflt[0][0], sizeof(float), SZ_float, fvtk, -1);
---
>   FileWriteData (Vflt[0][0], sizeof(float), SZ_float, fvtk, -1);
Only in ../old: write_vtk_proc.c
